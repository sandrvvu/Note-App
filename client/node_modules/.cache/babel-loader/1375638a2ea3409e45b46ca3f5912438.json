{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/markercollection\n */\nimport LiveRange from './liverange';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * The collection of all {@link module:engine/model/markercollection~Marker markers} attached to the document.\n * It lets you {@link module:engine/model/markercollection~MarkerCollection#get get} markers or track them using\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} event.\n *\n * To create, change or remove makers use {@link module:engine/model/writer~Writer model writers'} methods:\n * {@link module:engine/model/writer~Writer#addMarker} or {@link module:engine/model/writer~Writer#removeMarker}. Since\n * the writer is the only proper way to change the data model it is not possible to change markers directly using this\n * collection. All markers created by the writer will be automatically added to this collection.\n *\n * By default there is one marker collection available as {@link module:engine/model/model~Model#markers model property}.\n *\n * @see module:engine/model/markercollection~Marker\n */\n\nexport default class MarkerCollection {\n  /**\n   * Creates a markers collection.\n   */\n  constructor() {\n    /**\n     * Stores {@link ~Marker markers} added to the collection.\n     *\n     * @private\n     * @member {Map} #_markers\n     */\n    this._markers = new Map();\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all {@link ~Marker markers} added to the collection.\n   *\n   * @returns {Iterable}\n   */\n\n\n  [Symbol.iterator]() {\n    return this._markers.values();\n  }\n  /**\n   * Checks if given {@link ~Marker marker} or marker name is in the collection.\n   *\n   * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker or marker instance to check.\n   * @returns {Boolean} `true` if marker is in the collection, `false` otherwise.\n   */\n\n\n  has(markerOrName) {\n    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n    return this._markers.has(markerName);\n  }\n  /**\n   * Returns {@link ~Marker marker} with given `markerName`.\n   *\n   * @param {String} markerName Name of marker to get.\n   * @returns {module:engine/model/markercollection~Marker|null} Marker with given name or `null` if such marker was\n   * not added to the collection.\n   */\n\n\n  get(markerName) {\n    return this._markers.get(markerName) || null;\n  }\n  /**\n   * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given\n   * {@link module:engine/model/range~Range range}.\n   *\n   * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in\n   * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired\n   * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}\n   * flag has changed.\n   *\n   * @protected\n   * @fires module:engine/model/markercollection~MarkerCollection#event:update\n   * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker to set or marker instance to update.\n   * @param {module:engine/model/range~Range} range Marker range.\n   * @param {Boolean} [managedUsingOperations=false] Specifies whether the marker is managed using operations.\n   * @param {Boolean} [affectsData=false] Specifies whether the marker affects the data produced by the data pipeline\n   * (is persisted in the editor's data).\n   * @returns {module:engine/model/markercollection~Marker} `Marker` instance which was added or updated.\n   */\n\n\n  _set(markerOrName, range) {\n    let managedUsingOperations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let affectsData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\n    if (markerName.includes(',')) {\n      /**\n       * Marker name cannot contain the \",\" character.\n       *\n       * @error markercollection-incorrect-marker-name\n       */\n      throw new CKEditorError('markercollection-incorrect-marker-name', this);\n    }\n\n    const oldMarker = this._markers.get(markerName);\n\n    if (oldMarker) {\n      const oldMarkerData = oldMarker.getData();\n      const oldRange = oldMarker.getRange();\n      let hasChanged = false;\n\n      if (!oldRange.isEqual(range)) {\n        oldMarker._attachLiveRange(LiveRange.fromRange(range));\n\n        hasChanged = true;\n      }\n\n      if (managedUsingOperations != oldMarker.managedUsingOperations) {\n        oldMarker._managedUsingOperations = managedUsingOperations;\n        hasChanged = true;\n      }\n\n      if (typeof affectsData === 'boolean' && affectsData != oldMarker.affectsData) {\n        oldMarker._affectsData = affectsData;\n        hasChanged = true;\n      }\n\n      if (hasChanged) {\n        this.fire('update:' + markerName, oldMarker, oldRange, range, oldMarkerData);\n      }\n\n      return oldMarker;\n    }\n\n    const liveRange = LiveRange.fromRange(range);\n    const marker = new Marker(markerName, liveRange, managedUsingOperations, affectsData);\n\n    this._markers.set(markerName, marker);\n\n    this.fire('update:' + markerName, marker, null, range, { ...marker.getData(),\n      range: null\n    });\n    return marker;\n  }\n  /**\n   * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.\n   *\n   * @protected\n   * @fires module:engine/model/markercollection~MarkerCollection#event:update\n   * @param {String} markerOrName Marker or name of a marker to remove.\n   * @returns {Boolean} `true` if marker was found and removed, `false` otherwise.\n   */\n\n\n  _remove(markerOrName) {\n    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\n    const oldMarker = this._markers.get(markerName);\n\n    if (oldMarker) {\n      this._markers.delete(markerName);\n\n      this.fire('update:' + markerName, oldMarker, oldMarker.getRange(), null, oldMarker.getData());\n\n      this._destroyMarker(oldMarker);\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}\n   * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast\n   * conversion} for the marker.\n   *\n   * @protected\n   * @fires module:engine/model/markercollection~MarkerCollection#event:update\n   * @param {String} markerOrName Marker or name of a marker to refresh.\n   */\n\n\n  _refresh(markerOrName) {\n    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\n    const marker = this._markers.get(markerName);\n\n    if (!marker) {\n      /**\n       * Marker with provided name does not exists.\n       *\n       * @error markercollection-refresh-marker-not-exists\n       */\n      throw new CKEditorError('markercollection-refresh-marker-not-exists', this);\n    }\n\n    const range = marker.getRange();\n    this.fire('update:' + markerName, marker, range, range, marker.getData());\n  }\n  /**\n   * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.\n   *\n   * @param {module:engine/model/position~Position} position\n   * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n   */\n\n\n  *getMarkersAtPosition(position) {\n    for (const marker of this) {\n      if (marker.getRange().containsPosition(position)) {\n        yield marker;\n      }\n    }\n  }\n  /**\n   * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.\n   *\n   * @param {module:engine/model/range~Range} range\n   * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n   */\n\n\n  *getMarkersIntersectingRange(range) {\n    for (const marker of this) {\n      if (marker.getRange().getIntersection(range) !== null) {\n        yield marker;\n      }\n    }\n  }\n  /**\n   * Destroys marker collection and all markers inside it.\n   */\n\n\n  destroy() {\n    for (const marker of this._markers.values()) {\n      this._destroyMarker(marker);\n    }\n\n    this._markers = null;\n    this.stopListening();\n  }\n  /**\n   * Iterates over all markers that starts with given `prefix`.\n   *\n   *\t\tconst markerFooA = markersCollection.set( 'foo:a', rangeFooA );\n   *\t\tconst markerFooB = markersCollection.set( 'foo:b', rangeFooB );\n   *\t\tconst markerBarA = markersCollection.set( 'bar:a', rangeBarA );\n   *\t\tconst markerFooBarA = markersCollection.set( 'foobar:a', rangeFooBarA );\n   *\t\tArray.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]\n   *\t\tArray.from( markersCollection.getMarkersGroup( 'a' ) ); // []\n   *\n   * @param prefix\n   * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n   */\n\n\n  *getMarkersGroup(prefix) {\n    for (const marker of this._markers.values()) {\n      if (marker.name.startsWith(prefix + ':')) {\n        yield marker;\n      }\n    }\n  }\n  /**\n   * Destroys the marker.\n   *\n   * @private\n   * @param {module:engine/model/markercollection~Marker} marker Marker to destroy.\n   */\n\n\n  _destroyMarker(marker) {\n    marker.stopListening();\n\n    marker._detachLiveRange();\n  }\n  /**\n   * Fired whenever marker is added, updated or removed from `MarkerCollection`.\n   *\n   * @event update\n   * @param {module:engine/model/markercollection~Marker} marker Updated Marker.\n   * @param {module:engine/model/range~Range|null} oldRange Marker range before the update. When is not defined it\n   * means that marker is just added.\n   * @param {module:engine/model/range~Range|null} newRange Marker range after update. When is not defined it\n   * means that marker is just removed.\n   * @param {module:engine/model/markercollection~MarkerData} oldMarkerData Data of the marker before the change.\n   */\n\n\n}\nmix(MarkerCollection, EmitterMixin);\n/**\n * @typedef {Object} module:engine/model/markercollection~MarkerData\n *\n * @property {module:engine/model/range~Range|null} range Marker range. `null` if the marker was removed.\n * @property {Boolean} affectsData A property defining if the marker affects data.\n * @property {Boolean} managedUsingOperations A property defining if the marker is managed using operations.\n */\n\n/**\n * `Marker` is a continuous parts of model (like a range), is named and represent some kind of information about marked\n * part of model document. In contrary to {@link module:engine/model/node~Node nodes}, which are building blocks of\n * model document tree, markers are not stored directly in document tree but in\n * {@link module:engine/model/model~Model#markers model markers' collection}. Still, they are document data, by giving\n * additional meaning to the part of a model document between marker start and marker end.\n *\n * In this sense, markers are similar to adding and converting attributes on nodes. The difference is that attribute is\n * connected with a given node (e.g. a character is bold no matter if it gets moved or content around it changes).\n * Markers on the other hand are continuous ranges and are characterized by their start and end position. This means that\n * any character in the marker is marked by the marker. For example, if a character is moved outside of marker it stops being\n * \"special\" and the marker is shrunk. Similarly, when a character is moved into the marker from other place in document\n * model, it starts being \"special\" and the marker is enlarged.\n *\n * Another upside of markers is that finding marked part of document is fast and easy. Using attributes to mark some nodes\n * and then trying to find that part of document would require traversing whole document tree. Marker gives instant access\n * to the range which it is marking at the moment.\n *\n * Markers are built from a name and a range.\n *\n * Range of the marker is updated automatically when document changes, using\n * {@link module:engine/model/liverange~LiveRange live range} mechanism.\n *\n * Name is used to group and identify markers. Names have to be unique, but markers can be grouped by\n * using common prefixes, separated with `:`, for example: `user:john` or `search:3`. That's useful in term of creating\n * namespaces for custom elements (e.g. comments, highlights). You can use this prefixes in\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} listeners to listen on changes in a group of markers.\n * For instance: `model.markers.on( 'update:user', callback );` will be called whenever any `user:*` markers changes.\n *\n * There are two types of markers.\n *\n * 1. Markers managed directly, without using operations. They are added directly by {@link module:engine/model/writer~Writer}\n * to the {@link module:engine/model/markercollection~MarkerCollection} without any additional mechanism. They can be used\n * as bookmarks or visual markers. They are great for showing results of the find, or select link when the focus is in the input.\n *\n * 1. Markers managed using operations. These markers are also stored in {@link module:engine/model/markercollection~MarkerCollection}\n * but changes in these markers is managed the same way all other changes in the model structure - using operations.\n * Therefore, they are handled in the undo stack and synchronized between clients if the collaboration plugin is enabled.\n * This type of markers is useful for solutions like spell checking or comments.\n *\n * Both type of them should be added / updated by {@link module:engine/model/writer~Writer#addMarker}\n * and removed by {@link module:engine/model/writer~Writer#removeMarker} methods.\n *\n *\t\tmodel.change( ( writer ) => {\n * \t\t\tconst marker = writer.addMarker( name, { range, usingOperation: true } );\n *\n * \t\t\t// ...\n *\n * \t\t\twriter.removeMarker( marker );\n *\t\t} );\n *\n * See {@link module:engine/model/writer~Writer} to find more examples.\n *\n * Since markers need to track change in the document, for efficiency reasons, it is best to create and keep as little\n * markers as possible and remove them as soon as they are not needed anymore.\n *\n * Markers can be downcasted and upcasted.\n *\n * Markers downcast happens on {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} and\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} events.\n * Use {@link module:engine/conversion/downcasthelpers downcast converters} or attach a custom converter to mentioned events.\n * For {@link module:engine/controller/datacontroller~DataController data pipeline}, marker should be downcasted to an element.\n * Then, it can be upcasted back to a marker. Again, use {@link module:engine/conversion/upcasthelpers upcast converters} or\n * attach a custom converter to {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element}.\n *\n * `Marker` instances are created and destroyed only by {@link ~MarkerCollection MarkerCollection}.\n */\n\nclass Marker {\n  /**\n   * Creates a marker instance.\n   *\n   * @param {String} name Marker name.\n   * @param {module:engine/model/liverange~LiveRange} liveRange Range marked by the marker.\n   * @param {Boolean} managedUsingOperations Specifies whether the marker is managed using operations.\n   * @param {Boolean} affectsData Specifies whether the marker affects the data produced by the data pipeline\n   * (is persisted in the editor's data).\n   */\n  constructor(name, liveRange, managedUsingOperations, affectsData) {\n    /**\n     * Marker's name.\n     *\n     * @readonly\n     * @type {String}\n     */\n    this.name = name;\n    /**\n     * Range marked by the marker.\n     *\n     * @protected\n     * @member {module:engine/model/liverange~LiveRange}\n     */\n\n    this._liveRange = this._attachLiveRange(liveRange);\n    /**\n     * Flag indicates if the marker is managed using operations or not.\n     *\n     * @private\n     * @member {Boolean}\n     */\n\n    this._managedUsingOperations = managedUsingOperations;\n    /**\n     * Specifies whether the marker affects the data produced by the data pipeline\n     * (is persisted in the editor's data).\n     *\n     * @private\n     * @member {Boolean}\n     */\n\n    this._affectsData = affectsData;\n  }\n  /**\n   * A value indicating if the marker is managed using operations.\n   * See {@link ~Marker marker class description} to learn more about marker types.\n   * See {@link module:engine/model/writer~Writer#addMarker}.\n   *\n   * @returns {Boolean}\n   */\n\n\n  get managedUsingOperations() {\n    if (!this._liveRange) {\n      throw new CKEditorError('marker-destroyed', this);\n    }\n\n    return this._managedUsingOperations;\n  }\n  /**\n   * A value indicating if the marker changes the data.\n   *\n   * @returns {Boolean}\n   */\n\n\n  get affectsData() {\n    if (!this._liveRange) {\n      throw new CKEditorError('marker-destroyed', this);\n    }\n\n    return this._affectsData;\n  }\n  /**\n   * Returns the marker data (properties defining the marker).\n   *\n   * @returns {module:engine/model/markercollection~MarkerData}\n   */\n\n\n  getData() {\n    return {\n      range: this.getRange(),\n      affectsData: this.affectsData,\n      managedUsingOperations: this.managedUsingOperations\n    };\n  }\n  /**\n   * Returns current marker start position.\n   *\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  getStart() {\n    if (!this._liveRange) {\n      throw new CKEditorError('marker-destroyed', this);\n    }\n\n    return this._liveRange.start.clone();\n  }\n  /**\n   * Returns current marker end position.\n   *\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  getEnd() {\n    if (!this._liveRange) {\n      throw new CKEditorError('marker-destroyed', this);\n    }\n\n    return this._liveRange.end.clone();\n  }\n  /**\n   * Returns a range that represents the current state of the marker.\n   *\n   * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a\n   * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only\n   * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}\n   * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every\n   * time there is a need to read marker properties. This will guarantee that the marker has not been removed and\n   * that it's data is up-to-date.\n   *\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  getRange() {\n    if (!this._liveRange) {\n      throw new CKEditorError('marker-destroyed', this);\n    }\n\n    return this._liveRange.toRange();\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\tmarker.is( 'marker' ); // -> true\n   *\t\tmarker.is( 'model:marker' ); // -> true\n   *\n   *\t\tmarker.is( 'view:element' ); // -> false\n   *\t\tmarker.is( 'documentSelection' ); // -> false\n   *\n   * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'marker' || type === 'model:marker';\n  }\n  /**\n   * Binds new live range to the marker and detach the old one if is attached.\n   *\n   * @protected\n   * @param {module:engine/model/liverange~LiveRange} liveRange Live range to attach\n   * @returns {module:engine/model/liverange~LiveRange} Attached live range.\n   */\n\n\n  _attachLiveRange(liveRange) {\n    if (this._liveRange) {\n      this._detachLiveRange();\n    } // Delegating does not work with namespaces. Alternatively, we could delegate all events (using `*`).\n\n\n    liveRange.delegate('change:range').to(this);\n    liveRange.delegate('change:content').to(this);\n    this._liveRange = liveRange;\n    return liveRange;\n  }\n  /**\n   * Unbinds and destroys currently attached live range.\n   *\n   * @protected\n   */\n\n\n  _detachLiveRange() {\n    this._liveRange.stopDelegating('change:range', this);\n\n    this._liveRange.stopDelegating('change:content', this);\n\n    this._liveRange.detach();\n\n    this._liveRange = null;\n  }\n  /**\n   * Fired whenever {@link ~Marker#_liveRange marker range} is changed due to changes on {@link module:engine/model/document~Document}.\n   * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:range LiveRange change:range event}.\n   *\n   * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},\n   * all event listeners listening to it should be removed. It is best to do it on\n   * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.\n   *\n   * @see module:engine/model/liverange~LiveRange#event:change:range\n   * @event change:range\n   * @param {module:engine/model/range~Range} oldRange\n   * @param {Object} data\n   */\n\n  /**\n   * Fired whenever change on {@link module:engine/model/document~Document} is done inside {@link ~Marker#_liveRange marker range}.\n   * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:content LiveRange change:content event}.\n   *\n   * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},\n   * all event listeners listening to it should be removed. It is best to do it on\n   * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.\n   *\n   * @see module:engine/model/liverange~LiveRange#event:change:content\n   * @event change:content\n   * @param {module:engine/model/range~Range} oldRange\n   * @param {Object} data\n   */\n\n\n}\n\nmix(Marker, EmitterMixin);\n/**\n * Cannot use a {@link module:engine/model/markercollection~MarkerCollection#destroy destroyed marker} instance.\n *\n * @error marker-destroyed\n */","map":{"version":3,"names":["LiveRange","EmitterMixin","CKEditorError","mix","MarkerCollection","constructor","_markers","Map","Symbol","iterator","values","has","markerOrName","markerName","Marker","name","get","_set","range","managedUsingOperations","affectsData","includes","oldMarker","oldMarkerData","getData","oldRange","getRange","hasChanged","isEqual","_attachLiveRange","fromRange","_managedUsingOperations","_affectsData","fire","liveRange","marker","set","_remove","delete","_destroyMarker","_refresh","getMarkersAtPosition","position","containsPosition","getMarkersIntersectingRange","getIntersection","destroy","stopListening","getMarkersGroup","prefix","startsWith","_detachLiveRange","_liveRange","getStart","start","clone","getEnd","end","toRange","is","type","delegate","to","stopDelegating","detach"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/model/markercollection.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/markercollection\n */\n\nimport LiveRange from './liverange';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * The collection of all {@link module:engine/model/markercollection~Marker markers} attached to the document.\n * It lets you {@link module:engine/model/markercollection~MarkerCollection#get get} markers or track them using\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} event.\n *\n * To create, change or remove makers use {@link module:engine/model/writer~Writer model writers'} methods:\n * {@link module:engine/model/writer~Writer#addMarker} or {@link module:engine/model/writer~Writer#removeMarker}. Since\n * the writer is the only proper way to change the data model it is not possible to change markers directly using this\n * collection. All markers created by the writer will be automatically added to this collection.\n *\n * By default there is one marker collection available as {@link module:engine/model/model~Model#markers model property}.\n *\n * @see module:engine/model/markercollection~Marker\n */\nexport default class MarkerCollection {\n\t/**\n\t * Creates a markers collection.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Stores {@link ~Marker markers} added to the collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} #_markers\n\t\t */\n\t\tthis._markers = new Map();\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link ~Marker markers} added to the collection.\n\t *\n\t * @returns {Iterable}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._markers.values();\n\t}\n\n\t/**\n\t * Checks if given {@link ~Marker marker} or marker name is in the collection.\n\t *\n\t * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker or marker instance to check.\n\t * @returns {Boolean} `true` if marker is in the collection, `false` otherwise.\n\t */\n\thas( markerOrName ) {\n\t\tconst markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\t\treturn this._markers.has( markerName );\n\t}\n\n\t/**\n\t * Returns {@link ~Marker marker} with given `markerName`.\n\t *\n\t * @param {String} markerName Name of marker to get.\n\t * @returns {module:engine/model/markercollection~Marker|null} Marker with given name or `null` if such marker was\n\t * not added to the collection.\n\t */\n\tget( markerName ) {\n\t\treturn this._markers.get( markerName ) || null;\n\t}\n\n\t/**\n\t * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given\n\t * {@link module:engine/model/range~Range range}.\n\t *\n\t * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in\n\t * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired\n\t * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}\n\t * flag has changed.\n\t *\n\t * @protected\n\t * @fires module:engine/model/markercollection~MarkerCollection#event:update\n\t * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker to set or marker instance to update.\n\t * @param {module:engine/model/range~Range} range Marker range.\n\t * @param {Boolean} [managedUsingOperations=false] Specifies whether the marker is managed using operations.\n\t * @param {Boolean} [affectsData=false] Specifies whether the marker affects the data produced by the data pipeline\n\t * (is persisted in the editor's data).\n\t * @returns {module:engine/model/markercollection~Marker} `Marker` instance which was added or updated.\n\t */\n\t_set( markerOrName, range, managedUsingOperations = false, affectsData = false ) {\n\t\tconst markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\n\t\tif ( markerName.includes( ',' ) ) {\n\t\t\t/**\n\t\t\t * Marker name cannot contain the \",\" character.\n\t\t\t *\n\t\t\t * @error markercollection-incorrect-marker-name\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'markercollection-incorrect-marker-name', this );\n\t\t}\n\n\t\tconst oldMarker = this._markers.get( markerName );\n\n\t\tif ( oldMarker ) {\n\t\t\tconst oldMarkerData = oldMarker.getData();\n\n\t\t\tconst oldRange = oldMarker.getRange();\n\t\t\tlet hasChanged = false;\n\n\t\t\tif ( !oldRange.isEqual( range ) ) {\n\t\t\t\toldMarker._attachLiveRange( LiveRange.fromRange( range ) );\n\t\t\t\thasChanged = true;\n\t\t\t}\n\n\t\t\tif ( managedUsingOperations != oldMarker.managedUsingOperations ) {\n\t\t\t\toldMarker._managedUsingOperations = managedUsingOperations;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\n\t\t\tif ( typeof affectsData === 'boolean' && affectsData != oldMarker.affectsData ) {\n\t\t\t\toldMarker._affectsData = affectsData;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\n\t\t\tif ( hasChanged ) {\n\t\t\t\tthis.fire( 'update:' + markerName, oldMarker, oldRange, range, oldMarkerData );\n\t\t\t}\n\n\t\t\treturn oldMarker;\n\t\t}\n\n\t\tconst liveRange = LiveRange.fromRange( range );\n\t\tconst marker = new Marker( markerName, liveRange, managedUsingOperations, affectsData );\n\n\t\tthis._markers.set( markerName, marker );\n\t\tthis.fire( 'update:' + markerName, marker, null, range, { ...marker.getData(), range: null } );\n\n\t\treturn marker;\n\t}\n\n\t/**\n\t * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.\n\t *\n\t * @protected\n\t * @fires module:engine/model/markercollection~MarkerCollection#event:update\n\t * @param {String} markerOrName Marker or name of a marker to remove.\n\t * @returns {Boolean} `true` if marker was found and removed, `false` otherwise.\n\t */\n\t_remove( markerOrName ) {\n\t\tconst markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\t\tconst oldMarker = this._markers.get( markerName );\n\n\t\tif ( oldMarker ) {\n\t\t\tthis._markers.delete( markerName );\n\t\t\tthis.fire( 'update:' + markerName, oldMarker, oldMarker.getRange(), null, oldMarker.getData() );\n\n\t\t\tthis._destroyMarker( oldMarker );\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}\n\t * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast\n\t * conversion} for the marker.\n\t *\n\t * @protected\n\t * @fires module:engine/model/markercollection~MarkerCollection#event:update\n\t * @param {String} markerOrName Marker or name of a marker to refresh.\n\t */\n\t_refresh( markerOrName ) {\n\t\tconst markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\t\tconst marker = this._markers.get( markerName );\n\n\t\tif ( !marker ) {\n\t\t\t/**\n\t\t\t * Marker with provided name does not exists.\n\t\t\t *\n\t\t\t * @error markercollection-refresh-marker-not-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'markercollection-refresh-marker-not-exists', this );\n\t\t}\n\n\t\tconst range = marker.getRange();\n\n\t\tthis.fire( 'update:' + markerName, marker, range, range, marker.getData() );\n\t}\n\n\t/**\n\t * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.\n\t *\n\t * @param {module:engine/model/position~Position} position\n\t * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n\t */\n\t* getMarkersAtPosition( position ) {\n\t\tfor ( const marker of this ) {\n\t\t\tif ( marker.getRange().containsPosition( position ) ) {\n\t\t\t\tyield marker;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {module:engine/model/range~Range} range\n\t * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n\t */\n\t* getMarkersIntersectingRange( range ) {\n\t\tfor ( const marker of this ) {\n\t\t\tif ( marker.getRange().getIntersection( range ) !== null ) {\n\t\t\t\tyield marker;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Destroys marker collection and all markers inside it.\n\t */\n\tdestroy() {\n\t\tfor ( const marker of this._markers.values() ) {\n\t\t\tthis._destroyMarker( marker );\n\t\t}\n\n\t\tthis._markers = null;\n\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Iterates over all markers that starts with given `prefix`.\n\t *\n\t *\t\tconst markerFooA = markersCollection.set( 'foo:a', rangeFooA );\n\t *\t\tconst markerFooB = markersCollection.set( 'foo:b', rangeFooB );\n\t *\t\tconst markerBarA = markersCollection.set( 'bar:a', rangeBarA );\n\t *\t\tconst markerFooBarA = markersCollection.set( 'foobar:a', rangeFooBarA );\n\t *\t\tArray.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]\n\t *\t\tArray.from( markersCollection.getMarkersGroup( 'a' ) ); // []\n\t *\n\t * @param prefix\n\t * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n\t */\n\t* getMarkersGroup( prefix ) {\n\t\tfor ( const marker of this._markers.values() ) {\n\t\t\tif ( marker.name.startsWith( prefix + ':' ) ) {\n\t\t\t\tyield marker;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Destroys the marker.\n\t *\n\t * @private\n\t * @param {module:engine/model/markercollection~Marker} marker Marker to destroy.\n\t */\n\t_destroyMarker( marker ) {\n\t\tmarker.stopListening();\n\t\tmarker._detachLiveRange();\n\t}\n\n\t/**\n\t * Fired whenever marker is added, updated or removed from `MarkerCollection`.\n\t *\n\t * @event update\n\t * @param {module:engine/model/markercollection~Marker} marker Updated Marker.\n\t * @param {module:engine/model/range~Range|null} oldRange Marker range before the update. When is not defined it\n\t * means that marker is just added.\n\t * @param {module:engine/model/range~Range|null} newRange Marker range after update. When is not defined it\n\t * means that marker is just removed.\n\t * @param {module:engine/model/markercollection~MarkerData} oldMarkerData Data of the marker before the change.\n\t */\n}\n\nmix( MarkerCollection, EmitterMixin );\n\n/**\n * @typedef {Object} module:engine/model/markercollection~MarkerData\n *\n * @property {module:engine/model/range~Range|null} range Marker range. `null` if the marker was removed.\n * @property {Boolean} affectsData A property defining if the marker affects data.\n * @property {Boolean} managedUsingOperations A property defining if the marker is managed using operations.\n */\n\n/**\n * `Marker` is a continuous parts of model (like a range), is named and represent some kind of information about marked\n * part of model document. In contrary to {@link module:engine/model/node~Node nodes}, which are building blocks of\n * model document tree, markers are not stored directly in document tree but in\n * {@link module:engine/model/model~Model#markers model markers' collection}. Still, they are document data, by giving\n * additional meaning to the part of a model document between marker start and marker end.\n *\n * In this sense, markers are similar to adding and converting attributes on nodes. The difference is that attribute is\n * connected with a given node (e.g. a character is bold no matter if it gets moved or content around it changes).\n * Markers on the other hand are continuous ranges and are characterized by their start and end position. This means that\n * any character in the marker is marked by the marker. For example, if a character is moved outside of marker it stops being\n * \"special\" and the marker is shrunk. Similarly, when a character is moved into the marker from other place in document\n * model, it starts being \"special\" and the marker is enlarged.\n *\n * Another upside of markers is that finding marked part of document is fast and easy. Using attributes to mark some nodes\n * and then trying to find that part of document would require traversing whole document tree. Marker gives instant access\n * to the range which it is marking at the moment.\n *\n * Markers are built from a name and a range.\n *\n * Range of the marker is updated automatically when document changes, using\n * {@link module:engine/model/liverange~LiveRange live range} mechanism.\n *\n * Name is used to group and identify markers. Names have to be unique, but markers can be grouped by\n * using common prefixes, separated with `:`, for example: `user:john` or `search:3`. That's useful in term of creating\n * namespaces for custom elements (e.g. comments, highlights). You can use this prefixes in\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} listeners to listen on changes in a group of markers.\n * For instance: `model.markers.on( 'update:user', callback );` will be called whenever any `user:*` markers changes.\n *\n * There are two types of markers.\n *\n * 1. Markers managed directly, without using operations. They are added directly by {@link module:engine/model/writer~Writer}\n * to the {@link module:engine/model/markercollection~MarkerCollection} without any additional mechanism. They can be used\n * as bookmarks or visual markers. They are great for showing results of the find, or select link when the focus is in the input.\n *\n * 1. Markers managed using operations. These markers are also stored in {@link module:engine/model/markercollection~MarkerCollection}\n * but changes in these markers is managed the same way all other changes in the model structure - using operations.\n * Therefore, they are handled in the undo stack and synchronized between clients if the collaboration plugin is enabled.\n * This type of markers is useful for solutions like spell checking or comments.\n *\n * Both type of them should be added / updated by {@link module:engine/model/writer~Writer#addMarker}\n * and removed by {@link module:engine/model/writer~Writer#removeMarker} methods.\n *\n *\t\tmodel.change( ( writer ) => {\n * \t\t\tconst marker = writer.addMarker( name, { range, usingOperation: true } );\n *\n * \t\t\t// ...\n *\n * \t\t\twriter.removeMarker( marker );\n *\t\t} );\n *\n * See {@link module:engine/model/writer~Writer} to find more examples.\n *\n * Since markers need to track change in the document, for efficiency reasons, it is best to create and keep as little\n * markers as possible and remove them as soon as they are not needed anymore.\n *\n * Markers can be downcasted and upcasted.\n *\n * Markers downcast happens on {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} and\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} events.\n * Use {@link module:engine/conversion/downcasthelpers downcast converters} or attach a custom converter to mentioned events.\n * For {@link module:engine/controller/datacontroller~DataController data pipeline}, marker should be downcasted to an element.\n * Then, it can be upcasted back to a marker. Again, use {@link module:engine/conversion/upcasthelpers upcast converters} or\n * attach a custom converter to {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element}.\n *\n * `Marker` instances are created and destroyed only by {@link ~MarkerCollection MarkerCollection}.\n */\nclass Marker {\n\t/**\n\t * Creates a marker instance.\n\t *\n\t * @param {String} name Marker name.\n\t * @param {module:engine/model/liverange~LiveRange} liveRange Range marked by the marker.\n\t * @param {Boolean} managedUsingOperations Specifies whether the marker is managed using operations.\n\t * @param {Boolean} affectsData Specifies whether the marker affects the data produced by the data pipeline\n\t * (is persisted in the editor's data).\n\t */\n\tconstructor( name, liveRange, managedUsingOperations, affectsData ) {\n\t\t/**\n\t\t * Marker's name.\n\t\t *\n\t\t * @readonly\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Range marked by the marker.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:engine/model/liverange~LiveRange}\n\t\t */\n\t\tthis._liveRange = this._attachLiveRange( liveRange );\n\n\t\t/**\n\t\t * Flag indicates if the marker is managed using operations or not.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._managedUsingOperations = managedUsingOperations;\n\n\t\t/**\n\t\t * Specifies whether the marker affects the data produced by the data pipeline\n\t\t * (is persisted in the editor's data).\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._affectsData = affectsData;\n\t}\n\n\t/**\n\t * A value indicating if the marker is managed using operations.\n\t * See {@link ~Marker marker class description} to learn more about marker types.\n\t * See {@link module:engine/model/writer~Writer#addMarker}.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget managedUsingOperations() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed', this );\n\t\t}\n\n\t\treturn this._managedUsingOperations;\n\t}\n\n\t/**\n\t * A value indicating if the marker changes the data.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget affectsData() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed', this );\n\t\t}\n\n\t\treturn this._affectsData;\n\t}\n\n\t/**\n\t * Returns the marker data (properties defining the marker).\n\t *\n\t * @returns {module:engine/model/markercollection~MarkerData}\n\t */\n\tgetData() {\n\t\treturn {\n\t\t\trange: this.getRange(),\n\t\t\taffectsData: this.affectsData,\n\t\t\tmanagedUsingOperations: this.managedUsingOperations\n\t\t};\n\t}\n\n\t/**\n\t * Returns current marker start position.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tgetStart() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed', this );\n\t\t}\n\n\t\treturn this._liveRange.start.clone();\n\t}\n\n\t/**\n\t * Returns current marker end position.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tgetEnd() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed', this );\n\t\t}\n\n\t\treturn this._liveRange.end.clone();\n\t}\n\n\t/**\n\t * Returns a range that represents the current state of the marker.\n\t *\n\t * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a\n\t * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only\n\t * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}\n\t * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every\n\t * time there is a need to read marker properties. This will guarantee that the marker has not been removed and\n\t * that it's data is up-to-date.\n\t *\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tgetRange() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed', this );\n\t\t}\n\n\t\treturn this._liveRange.toRange();\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\tmarker.is( 'marker' ); // -> true\n\t *\t\tmarker.is( 'model:marker' ); // -> true\n\t *\n\t *\t\tmarker.is( 'view:element' ); // -> false\n\t *\t\tmarker.is( 'documentSelection' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'marker' || type === 'model:marker';\n\t}\n\n\t/**\n\t * Binds new live range to the marker and detach the old one if is attached.\n\t *\n\t * @protected\n\t * @param {module:engine/model/liverange~LiveRange} liveRange Live range to attach\n\t * @returns {module:engine/model/liverange~LiveRange} Attached live range.\n\t */\n\t_attachLiveRange( liveRange ) {\n\t\tif ( this._liveRange ) {\n\t\t\tthis._detachLiveRange();\n\t\t}\n\n\t\t// Delegating does not work with namespaces. Alternatively, we could delegate all events (using `*`).\n\t\tliveRange.delegate( 'change:range' ).to( this );\n\t\tliveRange.delegate( 'change:content' ).to( this );\n\n\t\tthis._liveRange = liveRange;\n\n\t\treturn liveRange;\n\t}\n\n\t/**\n\t * Unbinds and destroys currently attached live range.\n\t *\n\t * @protected\n\t */\n\t_detachLiveRange() {\n\t\tthis._liveRange.stopDelegating( 'change:range', this );\n\t\tthis._liveRange.stopDelegating( 'change:content', this );\n\t\tthis._liveRange.detach();\n\t\tthis._liveRange = null;\n\t}\n\n\t/**\n\t * Fired whenever {@link ~Marker#_liveRange marker range} is changed due to changes on {@link module:engine/model/document~Document}.\n\t * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:range LiveRange change:range event}.\n\t *\n\t * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},\n\t * all event listeners listening to it should be removed. It is best to do it on\n\t * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.\n\t *\n\t * @see module:engine/model/liverange~LiveRange#event:change:range\n\t * @event change:range\n\t * @param {module:engine/model/range~Range} oldRange\n\t * @param {Object} data\n\t */\n\n\t/**\n\t * Fired whenever change on {@link module:engine/model/document~Document} is done inside {@link ~Marker#_liveRange marker range}.\n\t * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:content LiveRange change:content event}.\n\t *\n\t * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},\n\t * all event listeners listening to it should be removed. It is best to do it on\n\t * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.\n\t *\n\t * @see module:engine/model/liverange~LiveRange#event:change:content\n\t * @event change:content\n\t * @param {module:engine/model/range~Range} oldRange\n\t * @param {Object} data\n\t */\n}\n\nmix( Marker, EmitterMixin );\n\n/**\n * Cannot use a {@link module:engine/model/markercollection~MarkerCollection#destroy destroyed marker} instance.\n *\n * @error marker-destroyed\n */\n"],"mappings":"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AACT,QAAP,GAAkBmB,eAAlB,CAAmC3B,KAAnC,MAA+C,IAApD,EAA2D;QAC1D,MAAMiB,MAAN;MACA;IACD;EACD;EAED;AACD;AACA;;;EACCW,OAAO,GAAG;IACT,KAAM,MAAMX,MAAZ,IAAsB,KAAK7B,QAAL,CAAcI,MAAd,EAAtB,EAA+C;MAC9C,KAAK6B,cAAL,CAAqBJ,MAArB;IACA;;IAED,KAAK7B,QAAL,GAAgB,IAAhB;IAEA,KAAKyC,aAAL;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACkB,CAAfC,eAAe,CAAEC,MAAF,EAAW;IAC3B,KAAM,MAAMd,MAAZ,IAAsB,KAAK7B,QAAL,CAAcI,MAAd,EAAtB,EAA+C;MAC9C,IAAKyB,MAAM,CAACpB,IAAP,CAAYmC,UAAZ,CAAwBD,MAAM,GAAG,GAAjC,CAAL,EAA8C;QAC7C,MAAMd,MAAN;MACA;IACD;EACD;EAED;AACD;AACA;AACA;AACA;AACA;;;EACCI,cAAc,CAAEJ,MAAF,EAAW;IACxBA,MAAM,CAACY,aAAP;;IACAZ,MAAM,CAACgB,gBAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA1PsC;AA6PtChD,GAAG,CAAEC,gBAAF,EAAoBH,YAApB,CAAH;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMa,MAAN,CAAa;EACZ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA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"},"metadata":{},"sourceType":"module"}