{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/differ\n */\nimport Position from './position';\nimport Range from './range';\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\n\nexport default class Differ {\n  /**\n   * Creates a `Differ` instance.\n   *\n   * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n   */\n  constructor(markerCollection) {\n    /**\n     * Reference to the model's marker collection.\n     *\n     * @private\n     * @type {module:engine/model/markercollection~MarkerCollection}\n     */\n    this._markerCollection = markerCollection;\n    /**\n     * A map that stores changes that happened in a given element.\n     *\n     * The keys of the map are references to the model elements.\n     * The values of the map are arrays with changes that were done on this element.\n     *\n     * @private\n     * @type {Map}\n     */\n\n    this._changesInElement = new Map();\n    /**\n     * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n     * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n     * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n     *\n     * @private\n     * @type {Map}\n     */\n\n    this._elementSnapshots = new Map();\n    /**\n     * A map that stores all changed markers.\n     *\n     * The keys of the map are marker names.\n     * The values of the map are objects with the following properties:\n     * - `oldMarkerData`,\n     * - `newMarkerData`.\n     *\n     * @private\n     * @type {Map.<String, Object>}\n     */\n\n    this._changedMarkers = new Map();\n    /**\n     * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n     * when changes are sorted.\n     *\n     * @private\n     * @type {Number}\n     */\n\n    this._changeCount = 0;\n    /**\n     * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n     * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n     * return the cached value instead of calculating it again.\n     *\n     * This property stores those changes that did not take place in graveyard root.\n     *\n     * @private\n     * @type {Array.<Object>|null}\n     */\n\n    this._cachedChanges = null;\n    /**\n     * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n     * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n     * return the cached value instead of calculating it again.\n     *\n     * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n     *\n     * @private\n     * @type {Array.<Object>|null}\n     */\n\n    this._cachedChangesWithGraveyard = null;\n    /**\n     * Set of model items that were marked to get refreshed in {@link #_refreshItem}.\n     *\n     * @private\n     * @type {Set.<module:engine/model/item~Item>}\n     */\n\n    this._refreshedItems = new Set();\n  }\n  /**\n   * Informs whether there are any changes buffered in `Differ`.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isEmpty() {\n    return this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n  }\n  /**\n   * Buffers the given operation. An operation has to be buffered before it is executed.\n   *\n   * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n   * in the state before the operation is executed.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation An operation to buffer.\n   */\n\n\n  bufferOperation(operation) {\n    // Below we take an operation, check its type, then use its parameters in marking (private) methods.\n    // The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.\n    // Marking changes in them would cause a \"double\" changing then.\n    //\n    switch (operation.type) {\n      case 'insert':\n        {\n          if (this._isInInsertedElement(operation.position.parent)) {\n            return;\n          }\n\n          this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);\n\n          break;\n        }\n\n      case 'addAttribute':\n      case 'removeAttribute':\n      case 'changeAttribute':\n        {\n          for (const item of operation.range.getItems({\n            shallow: true\n          })) {\n            if (this._isInInsertedElement(item.parent)) {\n              continue;\n            }\n\n            this._markAttribute(item);\n          }\n\n          break;\n        }\n\n      case 'remove':\n      case 'move':\n      case 'reinsert':\n        {\n          // When range is moved to the same position then not mark it as a change.\n          // See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.\n          if (operation.sourcePosition.isEqual(operation.targetPosition) || operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {\n            return;\n          }\n\n          const sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);\n\n          const targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);\n\n          if (!sourceParentInserted) {\n            this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);\n          }\n\n          if (!targetParentInserted) {\n            this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);\n          }\n\n          break;\n        }\n\n      case 'rename':\n        {\n          if (this._isInInsertedElement(operation.position.parent)) {\n            return;\n          }\n\n          this._markRemove(operation.position.parent, operation.position.offset, 1);\n\n          this._markInsert(operation.position.parent, operation.position.offset, 1);\n\n          const range = Range._createFromPositionAndShift(operation.position, 1);\n\n          for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {\n            const markerData = marker.getData();\n            this.bufferMarkerChange(marker.name, markerData, markerData);\n          }\n\n          break;\n        }\n\n      case 'split':\n        {\n          const splitElement = operation.splitPosition.parent; // Mark that children of the split element were removed.\n\n          if (!this._isInInsertedElement(splitElement)) {\n            this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);\n          } // Mark that the new element (split copy) was inserted.\n\n\n          if (!this._isInInsertedElement(operation.insertionPosition.parent)) {\n            this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);\n          } // If the split took the element from the graveyard, mark that the element from the graveyard was removed.\n\n\n          if (operation.graveyardPosition) {\n            this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);\n          }\n\n          break;\n        }\n\n      case 'merge':\n        {\n          // Mark that the merged element was removed.\n          const mergedElement = operation.sourcePosition.parent;\n\n          if (!this._isInInsertedElement(mergedElement.parent)) {\n            this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);\n          } // Mark that the merged element was inserted into graveyard.\n\n\n          const graveyardParent = operation.graveyardPosition.parent;\n\n          this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1); // Mark that children of merged element were inserted at new parent.\n\n\n          const mergedIntoElement = operation.targetPosition.parent;\n\n          if (!this._isInInsertedElement(mergedIntoElement)) {\n            this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);\n          }\n\n          break;\n        }\n    } // Clear cache after each buffered operation as it is no longer valid.\n\n\n    this._cachedChanges = null;\n  }\n  /**\n   * Buffers a marker change.\n   *\n   * @param {String} markerName The name of the marker that changed.\n   * @param {module:engine/model/markercollection~MarkerData} oldMarkerData Marker data before the change.\n   * @param {module:engine/model/markercollection~MarkerData} newMarkerData Marker data after the change.\n   */\n\n\n  bufferMarkerChange(markerName, oldMarkerData, newMarkerData) {\n    const buffered = this._changedMarkers.get(markerName);\n\n    if (!buffered) {\n      this._changedMarkers.set(markerName, {\n        newMarkerData,\n        oldMarkerData\n      });\n    } else {\n      buffered.newMarkerData = newMarkerData;\n\n      if (buffered.oldMarkerData.range == null && newMarkerData.range == null) {\n        // The marker is going to be removed (`newMarkerData.range == null`) but it did not exist before the first buffered change\n        // (`buffered.oldMarkerData.range == null`). In this case, do not keep the marker in buffer at all.\n        this._changedMarkers.delete(markerName);\n      }\n    }\n  }\n  /**\n   * Returns all markers that should be removed as a result of buffered changes.\n   *\n   * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n   */\n\n\n  getMarkersToRemove() {\n    const result = [];\n\n    for (const [name, change] of this._changedMarkers) {\n      if (change.oldMarkerData.range != null) {\n        result.push({\n          name,\n          range: change.oldMarkerData.range\n        });\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Returns all markers which should be added as a result of buffered changes.\n   *\n   * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n   */\n\n\n  getMarkersToAdd() {\n    const result = [];\n\n    for (const [name, change] of this._changedMarkers) {\n      if (change.newMarkerData.range != null) {\n        result.push({\n          name,\n          range: change.newMarkerData.range\n        });\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Returns all markers which changed.\n   *\n   * @returns {Array.<Object>}\n   */\n\n\n  getChangedMarkers() {\n    return Array.from(this._changedMarkers).map(_ref => {\n      let [name, change] = _ref;\n      return {\n        name,\n        data: {\n          oldRange: change.oldMarkerData.range,\n          newRange: change.newMarkerData.range\n        }\n      };\n    });\n  }\n  /**\n   * Checks whether some of the buffered changes affect the editor data.\n   *\n   * Types of changes which affect the editor data:\n   *\n   * * model structure changes,\n   * * attribute changes,\n   * * changes of markers which were defined as `affectsData`,\n   * * changes of markers' `affectsData` property.\n   *\n   * @returns {Boolean}\n   */\n\n\n  hasDataChanges() {\n    if (this._changesInElement.size > 0) {\n      return true;\n    }\n\n    for (const {\n      newMarkerData,\n      oldMarkerData\n    } of this._changedMarkers.values()) {\n      if (newMarkerData.affectsData !== oldMarkerData.affectsData) {\n        return true;\n      }\n\n      if (newMarkerData.affectsData) {\n        const markerAdded = newMarkerData.range && !oldMarkerData.range;\n        const markerRemoved = !newMarkerData.range && oldMarkerData.range;\n        const markerChanged = newMarkerData.range && oldMarkerData.range && !newMarkerData.range.isEqual(oldMarkerData.range);\n\n        if (markerAdded || markerRemoved || markerChanged) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n   * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n   *\n   * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done\n   * on the model. The items are sorted by the position on which the change happened. If a position\n   * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.\n   *\n   * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.\n   *\n   * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n   * previous {@link #getChanges} call, the next call will return the cached value.\n   *\n   * @param {Object} options Additional options.\n   * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n   * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n   * @returns {Array.<module:engine/model/differ~DiffItem>} Diff between the old and the new model tree state.\n   */\n\n\n  getChanges() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      includeChangesInGraveyard: false\n    };\n\n    // If there are cached changes, just return them instead of calculating changes again.\n    if (this._cachedChanges) {\n      if (options.includeChangesInGraveyard) {\n        return this._cachedChangesWithGraveyard.slice();\n      } else {\n        return this._cachedChanges.slice();\n      }\n    } // Will contain returned results.\n\n\n    let diffSet = []; // Check all changed elements.\n\n    for (const element of this._changesInElement.keys()) {\n      // Get changes for this element and sort them.\n      const changes = this._changesInElement.get(element).sort((a, b) => {\n        if (a.offset === b.offset) {\n          if (a.type != b.type) {\n            // If there are multiple changes at the same position, \"remove\" change should be first.\n            // If the order is different, for example, we would first add some nodes and then removed them\n            // (instead of the nodes that we should remove).\n            return a.type == 'remove' ? -1 : 1;\n          }\n\n          return 0;\n        }\n\n        return a.offset < b.offset ? -1 : 1;\n      }); // Get children of this element before any change was applied on it.\n\n\n      const snapshotChildren = this._elementSnapshots.get(element); // Get snapshot of current element's children.\n\n\n      const elementChildren = _getChildrenSnapshot(element.getChildren()); // Generate actions basing on changes done on element.\n\n\n      const actions = _generateActionsFromChanges(snapshotChildren.length, changes);\n\n      let i = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n\n      let j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n      // Process every action.\n\n      for (const action of actions) {\n        if (action === 'i') {\n          // Generate diff item for this element and insert it into the diff set.\n          diffSet.push(this._getInsertDiff(element, i, elementChildren[i]));\n          i++;\n        } else if (action === 'r') {\n          // Generate diff item for this element and insert it into the diff set.\n          diffSet.push(this._getRemoveDiff(element, i, snapshotChildren[j]));\n          j++;\n        } else if (action === 'a') {\n          // Take attributes from saved and current children.\n          const elementAttributes = elementChildren[i].attributes;\n          const snapshotAttributes = snapshotChildren[j].attributes;\n          let range;\n\n          if (elementChildren[i].name == '$text') {\n            range = new Range(Position._createAt(element, i), Position._createAt(element, i + 1));\n          } else {\n            const index = element.offsetToIndex(i);\n            range = new Range(Position._createAt(element, i), Position._createAt(element.getChild(index), 0));\n          } // Generate diff items for this change (there might be multiple attributes changed and\n          // there is a single diff for each of them) and insert them into the diff set.\n\n\n          diffSet.push(...this._getAttributesDiff(range, snapshotAttributes, elementAttributes));\n          i++;\n          j++;\n        } else {\n          // `action` is 'equal'. Child not changed.\n          i++;\n          j++;\n        }\n      }\n    } // Then, sort the changes by the position (change at position before other changes is first).\n\n\n    diffSet.sort((a, b) => {\n      // If the change is in different root, we don't care much, but we'd like to have all changes in given\n      // root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n      // will be processed first.\n      if (a.position.root != b.position.root) {\n        return a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n      } // If change happens at the same position...\n\n\n      if (a.position.isEqual(b.position)) {\n        // Keep chronological order of operations.\n        return a.changeCount - b.changeCount;\n      } // If positions differ, position \"on the left\" should be earlier in the result.\n\n\n      return a.position.isBefore(b.position) ? -1 : 1;\n    }); // Glue together multiple changes (mostly on text nodes).\n\n    for (let i = 1, prevIndex = 0; i < diffSet.length; i++) {\n      const prevDiff = diffSet[prevIndex];\n      const thisDiff = diffSet[i]; // Glue remove changes if they happen on text on same position.\n\n      const isConsecutiveTextRemove = prevDiff.type == 'remove' && thisDiff.type == 'remove' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.isEqual(thisDiff.position); // Glue insert changes if they happen on text on consecutive fragments.\n\n      const isConsecutiveTextAdd = prevDiff.type == 'insert' && thisDiff.type == 'insert' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset; // Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n\n      const isConsecutiveAttributeChange = prevDiff.type == 'attribute' && thisDiff.type == 'attribute' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.range.isFlat && thisDiff.range.isFlat && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset && prevDiff.attributeKey == thisDiff.attributeKey && prevDiff.attributeOldValue == thisDiff.attributeOldValue && prevDiff.attributeNewValue == thisDiff.attributeNewValue;\n\n      if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {\n        prevDiff.length++;\n\n        if (isConsecutiveAttributeChange) {\n          prevDiff.range.end = prevDiff.range.end.getShiftedBy(1);\n        }\n\n        diffSet[i] = null;\n      } else {\n        prevIndex = i;\n      }\n    }\n\n    diffSet = diffSet.filter(v => v); // Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n\n    for (const item of diffSet) {\n      delete item.changeCount;\n\n      if (item.type == 'attribute') {\n        delete item.position;\n        delete item.length;\n      }\n    }\n\n    this._changeCount = 0; // Cache changes.\n\n    this._cachedChangesWithGraveyard = diffSet;\n    this._cachedChanges = diffSet.filter(_changesInGraveyardFilter);\n\n    if (options.includeChangesInGraveyard) {\n      return this._cachedChangesWithGraveyard.slice();\n    } else {\n      return this._cachedChanges.slice();\n    }\n  }\n  /**\n   * Returns a set of model items that were marked to get refreshed.\n   *\n   * @return {Set.<module:engine/model/item~Item>}\n   */\n\n\n  getRefreshedItems() {\n    return new Set(this._refreshedItems);\n  }\n  /**\n   * Resets `Differ`. Removes all buffered changes.\n   */\n\n\n  reset() {\n    this._changesInElement.clear();\n\n    this._elementSnapshots.clear();\n\n    this._changedMarkers.clear();\n\n    this._refreshedItems = new Set();\n    this._cachedChanges = null;\n  }\n  /**\n   * Marks the given `item` in differ to be \"refreshed\". It means that the item will be marked as removed and inserted\n   * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.\n   *\n   * @protected\n   * @param {module:engine/model/item~Item} item Item to refresh.\n   */\n\n\n  _refreshItem(item) {\n    if (this._isInInsertedElement(item.parent)) {\n      return;\n    }\n\n    this._markRemove(item.parent, item.startOffset, item.offsetSize);\n\n    this._markInsert(item.parent, item.startOffset, item.offsetSize);\n\n    this._refreshedItems.add(item);\n\n    const range = Range._createOn(item);\n\n    for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {\n      const markerData = marker.getData();\n      this.bufferMarkerChange(marker.name, markerData, markerData);\n    } // Clear cache after each buffered operation as it is no longer valid.\n\n\n    this._cachedChanges = null;\n  }\n  /**\n   * Saves and handles an insert change.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Number} offset\n   * @param {Number} howMany\n   */\n\n\n  _markInsert(parent, offset, howMany) {\n    const changeItem = {\n      type: 'insert',\n      offset,\n      howMany,\n      count: this._changeCount++\n    };\n\n    this._markChange(parent, changeItem);\n  }\n  /**\n   * Saves and handles a remove change.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Number} offset\n   * @param {Number} howMany\n   */\n\n\n  _markRemove(parent, offset, howMany) {\n    const changeItem = {\n      type: 'remove',\n      offset,\n      howMany,\n      count: this._changeCount++\n    };\n\n    this._markChange(parent, changeItem);\n\n    this._removeAllNestedChanges(parent, offset, howMany);\n  }\n  /**\n   * Saves and handles an attribute change.\n   *\n   * @private\n   * @param {module:engine/model/item~Item} item\n   */\n\n\n  _markAttribute(item) {\n    const changeItem = {\n      type: 'attribute',\n      offset: item.startOffset,\n      howMany: item.offsetSize,\n      count: this._changeCount++\n    };\n\n    this._markChange(item.parent, changeItem);\n  }\n  /**\n   * Saves and handles a model change.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Object} changeItem\n   */\n\n\n  _markChange(parent, changeItem) {\n    // First, make a snapshot of this parent's children (it will be made only if it was not made before).\n    this._makeSnapshot(parent); // Then, get all changes that already were done on the element (empty array if this is the first change).\n\n\n    const changes = this._getChangesForElement(parent); // Then, look through all the changes, and transform them or the new change.\n\n\n    this._handleChange(changeItem, changes); // Add the new change.\n\n\n    changes.push(changeItem); // Remove incorrect changes. During transformation some change might be, for example, included in another.\n    // In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n\n    for (let i = 0; i < changes.length; i++) {\n      if (changes[i].howMany < 1) {\n        changes.splice(i, 1);\n        i--;\n      }\n    }\n  }\n  /**\n   * Gets an array of changes that have already been saved for a given element.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} element\n   * @returns {Array.<Object>}\n   */\n\n\n  _getChangesForElement(element) {\n    let changes;\n\n    if (this._changesInElement.has(element)) {\n      changes = this._changesInElement.get(element);\n    } else {\n      changes = [];\n\n      this._changesInElement.set(element, changes);\n    }\n\n    return changes;\n  }\n  /**\n   * Saves a children snapshot for a given element.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} element\n   */\n\n\n  _makeSnapshot(element) {\n    if (!this._elementSnapshots.has(element)) {\n      this._elementSnapshots.set(element, _getChildrenSnapshot(element.getChildren()));\n    }\n  }\n  /**\n   * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n   * change and/or the old change.\n   *\n   * @private\n   * @param {Object} inc Incoming (new) change.\n   * @param {Array.<Object>} changes An array containing all the changes done on that element.\n   */\n\n\n  _handleChange(inc, changes) {\n    // We need a helper variable that will store how many nodes are to be still handled for this change item.\n    // `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n    // needs to be differentiated.\n    //\n    // This comes up when there are multiple changes that are affected by `inc` change item.\n    //\n    // For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n    // Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n    //\n    // Then, we:\n    // - \"forget\" about first insert change (it is \"eaten\" by remove),\n    // - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n    // - but still we have to change offset of the second insert change from `5` to `3`!\n    //\n    // So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n    // while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n    inc.nodesToHandle = inc.howMany;\n\n    for (const old of changes) {\n      const incEnd = inc.offset + inc.howMany;\n      const oldEnd = old.offset + old.howMany;\n\n      if (inc.type == 'insert') {\n        if (old.type == 'insert') {\n          if (inc.offset <= old.offset) {\n            old.offset += inc.howMany;\n          } else if (inc.offset < oldEnd) {\n            old.howMany += inc.nodesToHandle;\n            inc.nodesToHandle = 0;\n          }\n        }\n\n        if (old.type == 'remove') {\n          if (inc.offset < old.offset) {\n            old.offset += inc.howMany;\n          }\n        }\n\n        if (old.type == 'attribute') {\n          if (inc.offset <= old.offset) {\n            old.offset += inc.howMany;\n          } else if (inc.offset < oldEnd) {\n            // This case is more complicated, because attribute change has to be split into two.\n            // Example (assume that uppercase and lowercase letters mean different attributes):\n            //\n            // initial state:\t\tabcxyz\n            // attribute change:\taBCXYz\n            // incoming insert:\t\taBCfooXYz\n            //\n            // Change ranges cannot intersect because each item has to be described exactly (it was either\n            // not changed, inserted, removed, or its attribute was changed). That's why old attribute\n            // change has to be split and both parts has to be handled separately from now on.\n            const howMany = old.howMany;\n            old.howMany = inc.offset - old.offset; // Add the second part of attribute change to the beginning of processed array so it won't\n            // be processed again in this loop.\n\n            changes.unshift({\n              type: 'attribute',\n              offset: incEnd,\n              howMany: howMany - old.howMany,\n              count: this._changeCount++\n            });\n          }\n        }\n      }\n\n      if (inc.type == 'remove') {\n        if (old.type == 'insert') {\n          if (incEnd <= old.offset) {\n            old.offset -= inc.howMany;\n          } else if (incEnd <= oldEnd) {\n            if (inc.offset < old.offset) {\n              const intersectionLength = incEnd - old.offset;\n              old.offset = inc.offset;\n              old.howMany -= intersectionLength;\n              inc.nodesToHandle -= intersectionLength;\n            } else {\n              old.howMany -= inc.nodesToHandle;\n              inc.nodesToHandle = 0;\n            }\n          } else {\n            if (inc.offset <= old.offset) {\n              inc.nodesToHandle -= old.howMany;\n              old.howMany = 0;\n            } else if (inc.offset < oldEnd) {\n              const intersectionLength = oldEnd - inc.offset;\n              old.howMany -= intersectionLength;\n              inc.nodesToHandle -= intersectionLength;\n            }\n          }\n        }\n\n        if (old.type == 'remove') {\n          if (incEnd <= old.offset) {\n            old.offset -= inc.howMany;\n          } else if (inc.offset < old.offset) {\n            inc.nodesToHandle += old.howMany;\n            old.howMany = 0;\n          }\n        }\n\n        if (old.type == 'attribute') {\n          if (incEnd <= old.offset) {\n            old.offset -= inc.howMany;\n          } else if (inc.offset < old.offset) {\n            const intersectionLength = incEnd - old.offset;\n            old.offset = inc.offset;\n            old.howMany -= intersectionLength;\n          } else if (inc.offset < oldEnd) {\n            if (incEnd <= oldEnd) {\n              // On first sight in this case we don't need to split attribute operation into two.\n              // However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n              // For that reason, no two changes may intersect.\n              // So we cannot have an attribute change that \"contains\" remove change.\n              // Attribute change needs to be split.\n              const howMany = old.howMany;\n              old.howMany = inc.offset - old.offset;\n              const howManyAfter = howMany - old.howMany - inc.nodesToHandle; // Add the second part of attribute change to the beginning of processed array so it won't\n              // be processed again in this loop.\n\n              changes.unshift({\n                type: 'attribute',\n                offset: inc.offset,\n                howMany: howManyAfter,\n                count: this._changeCount++\n              });\n            } else {\n              old.howMany -= oldEnd - inc.offset;\n            }\n          }\n        }\n      }\n\n      if (inc.type == 'attribute') {\n        // In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n        if (old.type == 'insert') {\n          if (inc.offset < old.offset && incEnd > old.offset) {\n            if (incEnd > oldEnd) {\n              // This case is similar to a case described when incoming change was insert and old change was attribute.\n              // See comment above.\n              //\n              // This time incoming change is attribute. We need to split incoming change in this case too.\n              // However this time, the second part of the attribute change needs to be processed further\n              // because there might be other changes that it collides with.\n              const attributePart = {\n                type: 'attribute',\n                offset: oldEnd,\n                howMany: incEnd - oldEnd,\n                count: this._changeCount++\n              };\n\n              this._handleChange(attributePart, changes);\n\n              changes.push(attributePart);\n            }\n\n            inc.nodesToHandle = old.offset - inc.offset;\n            inc.howMany = inc.nodesToHandle;\n          } else if (inc.offset >= old.offset && inc.offset < oldEnd) {\n            if (incEnd > oldEnd) {\n              inc.nodesToHandle = incEnd - oldEnd;\n              inc.offset = oldEnd;\n            } else {\n              inc.nodesToHandle = 0;\n            }\n          }\n        }\n\n        if (old.type == 'remove') {\n          // This is a case when attribute change \"contains\" remove change.\n          // The attribute change needs to be split into two because changes cannot intersect.\n          if (inc.offset < old.offset && incEnd > old.offset) {\n            const attributePart = {\n              type: 'attribute',\n              offset: old.offset,\n              howMany: incEnd - old.offset,\n              count: this._changeCount++\n            };\n\n            this._handleChange(attributePart, changes);\n\n            changes.push(attributePart);\n            inc.nodesToHandle = old.offset - inc.offset;\n            inc.howMany = inc.nodesToHandle;\n          }\n        }\n\n        if (old.type == 'attribute') {\n          // There are only two conflicting scenarios possible here:\n          if (inc.offset >= old.offset && incEnd <= oldEnd) {\n            // `old` change includes `inc` change, or they are the same.\n            inc.nodesToHandle = 0;\n            inc.howMany = 0;\n            inc.offset = 0;\n          } else if (inc.offset <= old.offset && incEnd >= oldEnd) {\n            // `inc` change includes `old` change.\n            old.howMany = 0;\n          }\n        }\n      }\n    }\n\n    inc.howMany = inc.nodesToHandle;\n    delete inc.nodesToHandle;\n  }\n  /**\n   * Returns an object with a single insert change description.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent The element in which the change happened.\n   * @param {Number} offset The offset at which change happened.\n   * @param {Object} elementSnapshot The snapshot of the removed element a character.\n   * @returns {Object} The diff item.\n   */\n\n\n  _getInsertDiff(parent, offset, elementSnapshot) {\n    return {\n      type: 'insert',\n      position: Position._createAt(parent, offset),\n      name: elementSnapshot.name,\n      attributes: new Map(elementSnapshot.attributes),\n      length: 1,\n      changeCount: this._changeCount++\n    };\n  }\n  /**\n   * Returns an object with a single remove change description.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent The element in which change happened.\n   * @param {Number} offset The offset at which change happened.\n   * @param {Object} elementSnapshot The snapshot of the removed element a character.\n   * @returns {Object} The diff item.\n   */\n\n\n  _getRemoveDiff(parent, offset, elementSnapshot) {\n    return {\n      type: 'remove',\n      position: Position._createAt(parent, offset),\n      name: elementSnapshot.name,\n      attributes: new Map(elementSnapshot.attributes),\n      length: 1,\n      changeCount: this._changeCount++\n    };\n  }\n  /**\n   * Returns an array of objects where each one is a single attribute change description.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range The range where the change happened.\n   * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n   * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n   * @returns {Array.<Object>} An array containing one or more diff items.\n   */\n\n\n  _getAttributesDiff(range, oldAttributes, newAttributes) {\n    // Results holder.\n    const diffs = []; // Clone new attributes as we will be performing changes on this object.\n\n    newAttributes = new Map(newAttributes); // Look through old attributes.\n\n    for (const [key, oldValue] of oldAttributes) {\n      // Check what is the new value of the attribute (or if it was removed).\n      const newValue = newAttributes.has(key) ? newAttributes.get(key) : null; // If values are different (or attribute was removed)...\n\n      if (newValue !== oldValue) {\n        // Add diff item.\n        diffs.push({\n          type: 'attribute',\n          position: range.start,\n          range: range.clone(),\n          length: 1,\n          attributeKey: key,\n          attributeOldValue: oldValue,\n          attributeNewValue: newValue,\n          changeCount: this._changeCount++\n        });\n      } // Prevent returning two diff items for the same change.\n\n\n      newAttributes.delete(key);\n    } // Look through new attributes that weren't handled above.\n\n\n    for (const [key, newValue] of newAttributes) {\n      // Each of them is a new attribute. Add diff item.\n      diffs.push({\n        type: 'attribute',\n        position: range.start,\n        range: range.clone(),\n        length: 1,\n        attributeKey: key,\n        attributeOldValue: null,\n        attributeNewValue: newValue,\n        changeCount: this._changeCount++\n      });\n    }\n\n    return diffs;\n  }\n  /**\n   * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} element Element to check.\n   * @returns {Boolean}\n   */\n\n\n  _isInInsertedElement(element) {\n    const parent = element.parent;\n\n    if (!parent) {\n      return false;\n    }\n\n    const changes = this._changesInElement.get(parent);\n\n    const offset = element.startOffset;\n\n    if (changes) {\n      for (const change of changes) {\n        if (change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany) {\n          return true;\n        }\n      }\n    }\n\n    return this._isInInsertedElement(parent);\n  }\n  /**\n   * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n   * and `howMany`.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Number} offset\n   * @param {Number} howMany\n   */\n\n\n  _removeAllNestedChanges(parent, offset, howMany) {\n    const range = new Range(Position._createAt(parent, offset), Position._createAt(parent, offset + howMany));\n\n    for (const item of range.getItems({\n      shallow: true\n    })) {\n      if (item.is('element')) {\n        this._elementSnapshots.delete(item);\n\n        this._changesInElement.delete(item);\n\n        this._removeAllNestedChanges(item, 0, item.maxOffset);\n      }\n    }\n  }\n\n} // Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\n\nfunction _getChildrenSnapshot(children) {\n  const snapshot = [];\n\n  for (const child of children) {\n    if (child.is('$text')) {\n      for (let i = 0; i < child.data.length; i++) {\n        snapshot.push({\n          name: '$text',\n          attributes: new Map(child.getAttributes())\n        });\n      }\n    } else {\n      snapshot.push({\n        name: child.name,\n        attributes: new Map(child.getAttributes())\n      });\n    }\n  }\n\n  return snapshot;\n} // Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\n\n\nfunction _generateActionsFromChanges(oldChildrenLength, changes) {\n  const actions = [];\n  let offset = 0;\n  let oldChildrenHandled = 0; // Go through all buffered changes.\n\n  for (const change of changes) {\n    // First, fill \"holes\" between changes with \"equal\" actions.\n    if (change.offset > offset) {\n      for (let i = 0; i < change.offset - offset; i++) {\n        actions.push('e');\n      }\n\n      oldChildrenHandled += change.offset - offset;\n    } // Then, fill up actions accordingly to change type.\n\n\n    if (change.type == 'insert') {\n      for (let i = 0; i < change.howMany; i++) {\n        actions.push('i');\n      } // The last handled offset is after inserted range.\n\n\n      offset = change.offset + change.howMany;\n    } else if (change.type == 'remove') {\n      for (let i = 0; i < change.howMany; i++) {\n        actions.push('r');\n      } // The last handled offset is at the position where the nodes were removed.\n\n\n      offset = change.offset; // We removed `howMany` old nodes, update `oldChildrenHandled`.\n\n      oldChildrenHandled += change.howMany;\n    } else {\n      actions.push(...'a'.repeat(change.howMany).split('')); // The last handled offset is at the position after the changed range.\n\n      offset = change.offset + change.howMany; // We changed `howMany` old nodes, update `oldChildrenHandled`.\n\n      oldChildrenHandled += change.howMany;\n    }\n  } // Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n  // has not been changed / removed at the end of their parent.\n\n\n  if (oldChildrenHandled < oldChildrenLength) {\n    for (let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++) {\n      actions.push('e');\n    }\n  }\n\n  return actions;\n} // Filter callback for Array.filter that filters out change entries that are in graveyard.\n\n\nfunction _changesInGraveyardFilter(entry) {\n  const posInGy = entry.position && entry.position.root.rootName == '$graveyard';\n  const rangeInGy = entry.range && entry.range.root.rootName == '$graveyard';\n  return !posInGy && !rangeInGy;\n}\n/**\n * The single diff item.\n *\n * Could be one of:\n *\n * * {@link module:engine/model/differ~DiffItemInsert `DiffItemInsert`},\n * * {@link module:engine/model/differ~DiffItemRemove `DiffItemRemove`},\n * * {@link module:engine/model/differ~DiffItemAttribute `DiffItemAttribute`}.\n *\n * @interface DiffItem\n */\n\n/**\n * The single diff item for inserted nodes.\n *\n * @class DiffItemInsert\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'insert'} module:engine/model/differ~DiffItemInsert#type\n */\n\n/**\n * The name of the inserted elements or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemInsert#name\n */\n\n/**\n * Map of attributes that were set on the item while it was inserted.\n *\n * @member {Map.<String,*>} module:engine/model/differ~DiffItemInsert#attributes\n */\n\n/**\n * The position where the node was inserted.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemInsert#position\n */\n\n/**\n * The length of an inserted text node. For elements it is always 1 as each inserted element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemInsert#length\n */\n\n/**\n * The single diff item for removed nodes.\n *\n * @class DiffItemRemove\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'remove'} module:engine/model/differ~DiffItemRemove#type\n */\n\n/**\n * The name of the removed element or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemRemove#name\n */\n\n/**\n * Map of attributes that were set on the item while it was removed.\n *\n * @member {Map.<String,*>} module:engine/model/differ~DiffItemRemove#attributes\n */\n\n/**\n * The position where the node was removed.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemRemove#position\n */\n\n/**\n * The length of a removed text node. For elements it is always 1 as each removed element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemRemove#length\n */\n\n/**\n * The single diff item for attribute change.\n *\n * @class DiffItemAttribute\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'attribute'} module:engine/model/differ~DiffItemAttribute#type\n */\n\n/**\n * The name of the changed attribute.\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeKey\n */\n\n/**\n * An attribute previous value (before change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeOldValue\n */\n\n/**\n * An attribute new value (after change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeNewValue\n */\n\n/**\n * The range where the change happened.\n *\n * @member {module:engine/model/range~Range} module:engine/model/differ~DiffItemAttribute#range\n */","map":{"version":3,"names":["Position","Range","Differ","constructor","markerCollection","_markerCollection","_changesInElement","Map","_elementSnapshots","_changedMarkers","_changeCount","_cachedChanges","_cachedChangesWithGraveyard","_refreshedItems","Set","isEmpty","size","bufferOperation","operation","type","_isInInsertedElement","position","parent","_markInsert","offset","nodes","maxOffset","item","range","getItems","shallow","_markAttribute","sourcePosition","isEqual","targetPosition","getShiftedBy","howMany","sourceParentInserted","targetParentInserted","_markRemove","getMovedRangeStart","_createFromPositionAndShift","marker","getMarkersIntersectingRange","markerData","getData","bufferMarkerChange","name","splitElement","splitPosition","insertionPosition","graveyardPosition","mergedElement","startOffset","graveyardParent","mergedIntoElement","markerName","oldMarkerData","newMarkerData","buffered","get","set","delete","getMarkersToRemove","result","change","push","getMarkersToAdd","getChangedMarkers","Array","from","map","data","oldRange","newRange","hasDataChanges","values","affectsData","markerAdded","markerRemoved","markerChanged","getChanges","options","includeChangesInGraveyard","slice","diffSet","element","keys","changes","sort","a","b","snapshotChildren","elementChildren","_getChildrenSnapshot","getChildren","actions","_generateActionsFromChanges","length","i","j","action","_getInsertDiff","_getRemoveDiff","elementAttributes","attributes","snapshotAttributes","_createAt","index","offsetToIndex","getChild","_getAttributesDiff","root","rootName","changeCount","isBefore","prevIndex","prevDiff","thisDiff","isConsecutiveTextRemove","isConsecutiveTextAdd","isConsecutiveAttributeChange","isFlat","attributeKey","attributeOldValue","attributeNewValue","end","filter","v","_changesInGraveyardFilter","getRefreshedItems","reset","clear","_refreshItem","offsetSize","add","_createOn","changeItem","count","_markChange","_removeAllNestedChanges","_makeSnapshot","_getChangesForElement","_handleChange","splice","has","inc","nodesToHandle","old","incEnd","oldEnd","unshift","intersectionLength","howManyAfter","attributePart","elementSnapshot","oldAttributes","newAttributes","diffs","key","oldValue","newValue","start","clone","is","children","snapshot","child","getAttributes","oldChildrenLength","oldChildrenHandled","repeat","split","entry","posInGy","rangeInGy"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/differ\n */\n\nimport Position from './position';\nimport Range from './range';\n\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\nexport default class Differ {\n\t/**\n\t * Creates a `Differ` instance.\n\t *\n\t * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n\t */\n\tconstructor( markerCollection ) {\n\t\t/**\n\t\t * Reference to the model's marker collection.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis._markerCollection = markerCollection;\n\n\t\t/**\n\t\t * A map that stores changes that happened in a given element.\n\t\t *\n\t\t * The keys of the map are references to the model elements.\n\t\t * The values of the map are arrays with changes that were done on this element.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._changesInElement = new Map();\n\n\t\t/**\n\t\t * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n\t\t * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n\t\t * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._elementSnapshots = new Map();\n\n\t\t/**\n\t\t * A map that stores all changed markers.\n\t\t *\n\t\t * The keys of the map are marker names.\n\t\t * The values of the map are objects with the following properties:\n\t\t * - `oldMarkerData`,\n\t\t * - `newMarkerData`.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<String, Object>}\n\t\t */\n\t\tthis._changedMarkers = new Map();\n\n\t\t/**\n\t\t * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n\t\t * when changes are sorted.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t */\n\t\tthis._changeCount = 0;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n\t\t * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores those changes that did not take place in graveyard root.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChanges = null;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n\t\t * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChangesWithGraveyard = null;\n\n\t\t/**\n\t\t * Set of model items that were marked to get refreshed in {@link #_refreshItem}.\n\t\t *\n\t\t * @private\n\t\t * @type {Set.<module:engine/model/item~Item>}\n\t\t */\n\t\tthis._refreshedItems = new Set();\n\t}\n\n\t/**\n\t * Informs whether there are any changes buffered in `Differ`.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n\t}\n\n\t/**\n\t * Buffers the given operation. An operation has to be buffered before it is executed.\n\t *\n\t * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n\t * in the state before the operation is executed.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation An operation to buffer.\n\t */\n\tbufferOperation( operation ) {\n\t\t// Below we take an operation, check its type, then use its parameters in marking (private) methods.\n\t\t// The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.\n\t\t// Marking changes in them would cause a \"double\" changing then.\n\t\t//\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, operation.nodes.maxOffset );\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'addAttribute':\n\t\t\tcase 'removeAttribute':\n\t\t\tcase 'changeAttribute': {\n\t\t\t\tfor ( const item of operation.range.getItems( { shallow: true } ) ) {\n\t\t\t\t\tif ( this._isInInsertedElement( item.parent ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._markAttribute( item );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'remove':\n\t\t\tcase 'move':\n\t\t\tcase 'reinsert': {\n\t\t\t\t// When range is moved to the same position then not mark it as a change.\n\t\t\t\t// See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.\n\t\t\t\tif (\n\t\t\t\t\toperation.sourcePosition.isEqual( operation.targetPosition ) ||\n\t\t\t\t\toperation.sourcePosition.getShiftedBy( operation.howMany ).isEqual( operation.targetPosition )\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst sourceParentInserted = this._isInInsertedElement( operation.sourcePosition.parent );\n\t\t\t\tconst targetParentInserted = this._isInInsertedElement( operation.targetPosition.parent );\n\n\t\t\t\tif ( !sourceParentInserted ) {\n\t\t\t\t\tthis._markRemove( operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tif ( !targetParentInserted ) {\n\t\t\t\t\tthis._markInsert( operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'rename': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markRemove( operation.position.parent, operation.position.offset, 1 );\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, 1 );\n\n\t\t\t\tconst range = Range._createFromPositionAndShift( operation.position, 1 );\n\n\t\t\t\tfor ( const marker of this._markerCollection.getMarkersIntersectingRange( range ) ) {\n\t\t\t\t\tconst markerData = marker.getData();\n\n\t\t\t\t\tthis.bufferMarkerChange( marker.name, markerData, markerData );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'split': {\n\t\t\t\tconst splitElement = operation.splitPosition.parent;\n\n\t\t\t\t// Mark that children of the split element were removed.\n\t\t\t\tif ( !this._isInInsertedElement( splitElement ) ) {\n\t\t\t\t\tthis._markRemove( splitElement, operation.splitPosition.offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\t// Mark that the new element (split copy) was inserted.\n\t\t\t\tif ( !this._isInInsertedElement( operation.insertionPosition.parent ) ) {\n\t\t\t\t\tthis._markInsert( operation.insertionPosition.parent, operation.insertionPosition.offset, 1 );\n\t\t\t\t}\n\n\t\t\t\t// If the split took the element from the graveyard, mark that the element from the graveyard was removed.\n\t\t\t\tif ( operation.graveyardPosition ) {\n\t\t\t\t\tthis._markRemove( operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1 );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'merge': {\n\t\t\t\t// Mark that the merged element was removed.\n\t\t\t\tconst mergedElement = operation.sourcePosition.parent;\n\n\t\t\t\tif ( !this._isInInsertedElement( mergedElement.parent ) ) {\n\t\t\t\t\tthis._markRemove( mergedElement.parent, mergedElement.startOffset, 1 );\n\t\t\t\t}\n\n\t\t\t\t// Mark that the merged element was inserted into graveyard.\n\t\t\t\tconst graveyardParent = operation.graveyardPosition.parent;\n\n\t\t\t\tthis._markInsert( graveyardParent, operation.graveyardPosition.offset, 1 );\n\n\t\t\t\t// Mark that children of merged element were inserted at new parent.\n\t\t\t\tconst mergedIntoElement = operation.targetPosition.parent;\n\n\t\t\t\tif ( !this._isInInsertedElement( mergedIntoElement ) ) {\n\t\t\t\t\tthis._markInsert( mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Clear cache after each buffered operation as it is no longer valid.\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Buffers a marker change.\n\t *\n\t * @param {String} markerName The name of the marker that changed.\n\t * @param {module:engine/model/markercollection~MarkerData} oldMarkerData Marker data before the change.\n\t * @param {module:engine/model/markercollection~MarkerData} newMarkerData Marker data after the change.\n\t */\n\tbufferMarkerChange( markerName, oldMarkerData, newMarkerData ) {\n\t\tconst buffered = this._changedMarkers.get( markerName );\n\n\t\tif ( !buffered ) {\n\t\t\tthis._changedMarkers.set( markerName, {\n\t\t\t\tnewMarkerData,\n\t\t\t\toldMarkerData\n\t\t\t} );\n\t\t} else {\n\t\t\tbuffered.newMarkerData = newMarkerData;\n\n\t\t\tif ( buffered.oldMarkerData.range == null && newMarkerData.range == null ) {\n\t\t\t\t// The marker is going to be removed (`newMarkerData.range == null`) but it did not exist before the first buffered change\n\t\t\t\t// (`buffered.oldMarkerData.range == null`). In this case, do not keep the marker in buffer at all.\n\t\t\t\tthis._changedMarkers.delete( markerName );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all markers that should be removed as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToRemove() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.oldMarkerData.range != null ) {\n\t\t\t\tresult.push( { name, range: change.oldMarkerData.range } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all markers which should be added as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToAdd() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.newMarkerData.range != null ) {\n\t\t\t\tresult.push( { name, range: change.newMarkerData.range } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all markers which changed.\n\t *\n\t * @returns {Array.<Object>}\n\t */\n\tgetChangedMarkers() {\n\t\treturn Array.from( this._changedMarkers ).map( ( [ name, change ] ) => (\n\t\t\t{\n\t\t\t\tname,\n\t\t\t\tdata: {\n\t\t\t\t\toldRange: change.oldMarkerData.range,\n\t\t\t\t\tnewRange: change.newMarkerData.range\n\t\t\t\t}\n\t\t\t}\n\t\t) );\n\t}\n\n\t/**\n\t * Checks whether some of the buffered changes affect the editor data.\n\t *\n\t * Types of changes which affect the editor data:\n\t *\n\t * * model structure changes,\n\t * * attribute changes,\n\t * * changes of markers which were defined as `affectsData`,\n\t * * changes of markers' `affectsData` property.\n\t *\n\t * @returns {Boolean}\n\t */\n\thasDataChanges() {\n\t\tif ( this._changesInElement.size > 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfor ( const { newMarkerData, oldMarkerData } of this._changedMarkers.values() ) {\n\t\t\tif ( newMarkerData.affectsData !== oldMarkerData.affectsData ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( newMarkerData.affectsData ) {\n\t\t\t\tconst markerAdded = newMarkerData.range && !oldMarkerData.range;\n\t\t\t\tconst markerRemoved = !newMarkerData.range && oldMarkerData.range;\n\t\t\t\tconst markerChanged = newMarkerData.range && oldMarkerData.range && !newMarkerData.range.isEqual( oldMarkerData.range );\n\n\t\t\t\tif ( markerAdded || markerRemoved || markerChanged ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n\t * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n\t *\n\t * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done\n\t * on the model. The items are sorted by the position on which the change happened. If a position\n\t * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.\n\t *\n\t * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.\n\t *\n\t * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n\t * previous {@link #getChanges} call, the next call will return the cached value.\n\t *\n\t * @param {Object} options Additional options.\n\t * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n\t * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n\t * @returns {Array.<module:engine/model/differ~DiffItem>} Diff between the old and the new model tree state.\n\t */\n\tgetChanges( options = { includeChangesInGraveyard: false } ) {\n\t\t// If there are cached changes, just return them instead of calculating changes again.\n\t\tif ( this._cachedChanges ) {\n\t\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\t\treturn this._cachedChangesWithGraveyard.slice();\n\t\t\t} else {\n\t\t\t\treturn this._cachedChanges.slice();\n\t\t\t}\n\t\t}\n\n\t\t// Will contain returned results.\n\t\tlet diffSet = [];\n\n\t\t// Check all changed elements.\n\t\tfor ( const element of this._changesInElement.keys() ) {\n\t\t\t// Get changes for this element and sort them.\n\t\t\tconst changes = this._changesInElement.get( element ).sort( ( a, b ) => {\n\t\t\t\tif ( a.offset === b.offset ) {\n\t\t\t\t\tif ( a.type != b.type ) {\n\t\t\t\t\t\t// If there are multiple changes at the same position, \"remove\" change should be first.\n\t\t\t\t\t\t// If the order is different, for example, we would first add some nodes and then removed them\n\t\t\t\t\t\t// (instead of the nodes that we should remove).\n\t\t\t\t\t\treturn a.type == 'remove' ? -1 : 1;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn a.offset < b.offset ? -1 : 1;\n\t\t\t} );\n\n\t\t\t// Get children of this element before any change was applied on it.\n\t\t\tconst snapshotChildren = this._elementSnapshots.get( element );\n\t\t\t// Get snapshot of current element's children.\n\t\t\tconst elementChildren = _getChildrenSnapshot( element.getChildren() );\n\n\t\t\t// Generate actions basing on changes done on element.\n\t\t\tconst actions = _generateActionsFromChanges( snapshotChildren.length, changes );\n\n\t\t\tlet i = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n\t\t\tlet j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n\n\t\t\t// Process every action.\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action === 'i' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getInsertDiff( element, i, elementChildren[ i ] ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t} else if ( action === 'r' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getRemoveDiff( element, i, snapshotChildren[ j ] ) );\n\n\t\t\t\t\tj++;\n\t\t\t\t} else if ( action === 'a' ) {\n\t\t\t\t\t// Take attributes from saved and current children.\n\t\t\t\t\tconst elementAttributes = elementChildren[ i ].attributes;\n\t\t\t\t\tconst snapshotAttributes = snapshotChildren[ j ].attributes;\n\t\t\t\t\tlet range;\n\n\t\t\t\t\tif ( elementChildren[ i ].name == '$text' ) {\n\t\t\t\t\t\trange = new Range( Position._createAt( element, i ), Position._createAt( element, i + 1 ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst index = element.offsetToIndex( i );\n\t\t\t\t\t\trange = new Range( Position._createAt( element, i ), Position._createAt( element.getChild( index ), 0 ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Generate diff items for this change (there might be multiple attributes changed and\n\t\t\t\t\t// there is a single diff for each of them) and insert them into the diff set.\n\t\t\t\t\tdiffSet.push( ...this._getAttributesDiff( range, snapshotAttributes, elementAttributes ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\t// `action` is 'equal'. Child not changed.\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Then, sort the changes by the position (change at position before other changes is first).\n\t\tdiffSet.sort( ( a, b ) => {\n\t\t\t// If the change is in different root, we don't care much, but we'd like to have all changes in given\n\t\t\t// root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n\t\t\t// will be processed first.\n\t\t\tif ( a.position.root != b.position.root ) {\n\t\t\t\treturn a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n\t\t\t}\n\n\t\t\t// If change happens at the same position...\n\t\t\tif ( a.position.isEqual( b.position ) ) {\n\t\t\t\t// Keep chronological order of operations.\n\t\t\t\treturn a.changeCount - b.changeCount;\n\t\t\t}\n\n\t\t\t// If positions differ, position \"on the left\" should be earlier in the result.\n\t\t\treturn a.position.isBefore( b.position ) ? -1 : 1;\n\t\t} );\n\n\t\t// Glue together multiple changes (mostly on text nodes).\n\t\tfor ( let i = 1, prevIndex = 0; i < diffSet.length; i++ ) {\n\t\t\tconst prevDiff = diffSet[ prevIndex ];\n\t\t\tconst thisDiff = diffSet[ i ];\n\n\t\t\t// Glue remove changes if they happen on text on same position.\n\t\t\tconst isConsecutiveTextRemove =\n\t\t\t\tprevDiff.type == 'remove' && thisDiff.type == 'remove' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.isEqual( thisDiff.position );\n\n\t\t\t// Glue insert changes if they happen on text on consecutive fragments.\n\t\t\tconst isConsecutiveTextAdd =\n\t\t\t\tprevDiff.type == 'insert' && thisDiff.type == 'insert' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset;\n\n\t\t\t// Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n\t\t\tconst isConsecutiveAttributeChange =\n\t\t\t\tprevDiff.type == 'attribute' && thisDiff.type == 'attribute' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.range.isFlat && thisDiff.range.isFlat &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset &&\n\t\t\t\tprevDiff.attributeKey == thisDiff.attributeKey &&\n\t\t\t\tprevDiff.attributeOldValue == thisDiff.attributeOldValue &&\n\t\t\t\tprevDiff.attributeNewValue == thisDiff.attributeNewValue;\n\n\t\t\tif ( isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange ) {\n\t\t\t\tprevDiff.length++;\n\n\t\t\t\tif ( isConsecutiveAttributeChange ) {\n\t\t\t\t\tprevDiff.range.end = prevDiff.range.end.getShiftedBy( 1 );\n\t\t\t\t}\n\n\t\t\t\tdiffSet[ i ] = null;\n\t\t\t} else {\n\t\t\t\tprevIndex = i;\n\t\t\t}\n\t\t}\n\n\t\tdiffSet = diffSet.filter( v => v );\n\n\t\t// Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n\t\tfor ( const item of diffSet ) {\n\t\t\tdelete item.changeCount;\n\n\t\t\tif ( item.type == 'attribute' ) {\n\t\t\t\tdelete item.position;\n\t\t\t\tdelete item.length;\n\t\t\t}\n\t\t}\n\n\t\tthis._changeCount = 0;\n\n\t\t// Cache changes.\n\t\tthis._cachedChangesWithGraveyard = diffSet;\n\t\tthis._cachedChanges = diffSet.filter( _changesInGraveyardFilter );\n\n\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\treturn this._cachedChangesWithGraveyard.slice();\n\t\t} else {\n\t\t\treturn this._cachedChanges.slice();\n\t\t}\n\t}\n\n\t/**\n\t * Returns a set of model items that were marked to get refreshed.\n\t *\n\t * @return {Set.<module:engine/model/item~Item>}\n\t */\n\tgetRefreshedItems() {\n\t\treturn new Set( this._refreshedItems );\n\t}\n\n\t/**\n\t * Resets `Differ`. Removes all buffered changes.\n\t */\n\treset() {\n\t\tthis._changesInElement.clear();\n\t\tthis._elementSnapshots.clear();\n\t\tthis._changedMarkers.clear();\n\t\tthis._refreshedItems = new Set();\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Marks the given `item` in differ to be \"refreshed\". It means that the item will be marked as removed and inserted\n\t * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.\n\t *\n\t * @protected\n\t * @param {module:engine/model/item~Item} item Item to refresh.\n\t */\n\t_refreshItem( item ) {\n\t\tif ( this._isInInsertedElement( item.parent ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._markRemove( item.parent, item.startOffset, item.offsetSize );\n\t\tthis._markInsert( item.parent, item.startOffset, item.offsetSize );\n\n\t\tthis._refreshedItems.add( item );\n\n\t\tconst range = Range._createOn( item );\n\n\t\tfor ( const marker of this._markerCollection.getMarkersIntersectingRange( range ) ) {\n\t\t\tconst markerData = marker.getData();\n\n\t\t\tthis.bufferMarkerChange( marker.name, markerData, markerData );\n\t\t}\n\n\t\t// Clear cache after each buffered operation as it is no longer valid.\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Saves and handles an insert change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markInsert( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'insert', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a remove change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markRemove( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'remove', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\n\t\tthis._removeAllNestedChanges( parent, offset, howMany );\n\t}\n\n\t/**\n\t * Saves and handles an attribute change.\n\t *\n\t * @private\n\t * @param {module:engine/model/item~Item} item\n\t */\n\t_markAttribute( item ) {\n\t\tconst changeItem = { type: 'attribute', offset: item.startOffset, howMany: item.offsetSize, count: this._changeCount++ };\n\n\t\tthis._markChange( item.parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a model change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Object} changeItem\n\t */\n\t_markChange( parent, changeItem ) {\n\t\t// First, make a snapshot of this parent's children (it will be made only if it was not made before).\n\t\tthis._makeSnapshot( parent );\n\n\t\t// Then, get all changes that already were done on the element (empty array if this is the first change).\n\t\tconst changes = this._getChangesForElement( parent );\n\n\t\t// Then, look through all the changes, and transform them or the new change.\n\t\tthis._handleChange( changeItem, changes );\n\n\t\t// Add the new change.\n\t\tchanges.push( changeItem );\n\n\t\t// Remove incorrect changes. During transformation some change might be, for example, included in another.\n\t\t// In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n\t\tfor ( let i = 0; i < changes.length; i++ ) {\n\t\t\tif ( changes[ i ].howMany < 1 ) {\n\t\t\t\tchanges.splice( i, 1 );\n\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets an array of changes that have already been saved for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t * @returns {Array.<Object>}\n\t */\n\t_getChangesForElement( element ) {\n\t\tlet changes;\n\n\t\tif ( this._changesInElement.has( element ) ) {\n\t\t\tchanges = this._changesInElement.get( element );\n\t\t} else {\n\t\t\tchanges = [];\n\n\t\t\tthis._changesInElement.set( element, changes );\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\t/**\n\t * Saves a children snapshot for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t */\n\t_makeSnapshot( element ) {\n\t\tif ( !this._elementSnapshots.has( element ) ) {\n\t\t\tthis._elementSnapshots.set( element, _getChildrenSnapshot( element.getChildren() ) );\n\t\t}\n\t}\n\n\t/**\n\t * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n\t * change and/or the old change.\n\t *\n\t * @private\n\t * @param {Object} inc Incoming (new) change.\n\t * @param {Array.<Object>} changes An array containing all the changes done on that element.\n\t */\n\t_handleChange( inc, changes ) {\n\t\t// We need a helper variable that will store how many nodes are to be still handled for this change item.\n\t\t// `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n\t\t// needs to be differentiated.\n\t\t//\n\t\t// This comes up when there are multiple changes that are affected by `inc` change item.\n\t\t//\n\t\t// For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n\t\t// Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n\t\t//\n\t\t// Then, we:\n\t\t// - \"forget\" about first insert change (it is \"eaten\" by remove),\n\t\t// - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n\t\t// - but still we have to change offset of the second insert change from `5` to `3`!\n\t\t//\n\t\t// So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n\t\t// while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n\t\tinc.nodesToHandle = inc.howMany;\n\n\t\tfor ( const old of changes ) {\n\t\t\tconst incEnd = inc.offset + inc.howMany;\n\t\t\tconst oldEnd = old.offset + old.howMany;\n\n\t\t\tif ( inc.type == 'insert' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\told.howMany += inc.nodesToHandle;\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t// This case is more complicated, because attribute change has to be split into two.\n\t\t\t\t\t\t// Example (assume that uppercase and lowercase letters mean different attributes):\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// initial state:\t\tabcxyz\n\t\t\t\t\t\t// attribute change:\taBCXYz\n\t\t\t\t\t\t// incoming insert:\t\taBCfooXYz\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Change ranges cannot intersect because each item has to be described exactly (it was either\n\t\t\t\t\t\t// not changed, inserted, removed, or its attribute was changed). That's why old attribute\n\t\t\t\t\t\t// change has to be split and both parts has to be handled separately from now on.\n\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\toffset: incEnd,\n\t\t\t\t\t\t\thowMany: howMany - old.howMany,\n\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'remove' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( incEnd <= oldEnd ) {\n\t\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\t\told.offset = inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= inc.nodesToHandle;\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\t\tinc.nodesToHandle -= old.howMany;\n\t\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t\tconst intersectionLength = oldEnd - inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tinc.nodesToHandle += old.howMany;\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\told.offset = inc.offset;\n\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd <= oldEnd ) {\n\t\t\t\t\t\t\t// On first sight in this case we don't need to split attribute operation into two.\n\t\t\t\t\t\t\t// However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n\t\t\t\t\t\t\t// For that reason, no two changes may intersect.\n\t\t\t\t\t\t\t// So we cannot have an attribute change that \"contains\" remove change.\n\t\t\t\t\t\t\t// Attribute change needs to be split.\n\t\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t\tconst howManyAfter = howMany - old.howMany - inc.nodesToHandle;\n\n\t\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: inc.offset,\n\t\t\t\t\t\t\t\thowMany: howManyAfter,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= oldEnd - inc.offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'attribute' ) {\n\t\t\t\t// In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset < old.offset && incEnd > old.offset ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\t// This case is similar to a case described when incoming change was insert and old change was attribute.\n\t\t\t\t\t\t\t// See comment above.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// This time incoming change is attribute. We need to split incoming change in this case too.\n\t\t\t\t\t\t\t// However this time, the second part of the attribute change needs to be processed further\n\t\t\t\t\t\t\t// because there might be other changes that it collides with.\n\t\t\t\t\t\t\tconst attributePart = {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: oldEnd,\n\t\t\t\t\t\t\t\thowMany: incEnd - oldEnd,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis._handleChange( attributePart, changes );\n\n\t\t\t\t\t\t\tchanges.push( attributePart );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinc.nodesToHandle = old.offset - inc.offset;\n\t\t\t\t\t\tinc.howMany = inc.nodesToHandle;\n\t\t\t\t\t} else if ( inc.offset >= old.offset && inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\tinc.nodesToHandle = incEnd - oldEnd;\n\t\t\t\t\t\t\tinc.offset = oldEnd;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\t// This is a case when attribute change \"contains\" remove change.\n\t\t\t\t\t// The attribute change needs to be split into two because changes cannot intersect.\n\t\t\t\t\tif ( inc.offset < old.offset && incEnd > old.offset ) {\n\t\t\t\t\t\tconst attributePart = {\n\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\toffset: old.offset,\n\t\t\t\t\t\t\thowMany: incEnd - old.offset,\n\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis._handleChange( attributePart, changes );\n\n\t\t\t\t\t\tchanges.push( attributePart );\n\n\t\t\t\t\t\tinc.nodesToHandle = old.offset - inc.offset;\n\t\t\t\t\t\tinc.howMany = inc.nodesToHandle;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\t// There are only two conflicting scenarios possible here:\n\t\t\t\t\tif ( inc.offset >= old.offset && incEnd <= oldEnd ) {\n\t\t\t\t\t\t// `old` change includes `inc` change, or they are the same.\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\tinc.howMany = 0;\n\t\t\t\t\t\tinc.offset = 0;\n\t\t\t\t\t} else if ( inc.offset <= old.offset && incEnd >= oldEnd ) {\n\t\t\t\t\t\t// `inc` change includes `old` change.\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinc.howMany = inc.nodesToHandle;\n\t\tdelete inc.nodesToHandle;\n\t}\n\n\t/**\n\t * Returns an object with a single insert change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which the change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {Object} elementSnapshot The snapshot of the removed element a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getInsertDiff( parent, offset, elementSnapshot ) {\n\t\treturn {\n\t\t\ttype: 'insert',\n\t\t\tposition: Position._createAt( parent, offset ),\n\t\t\tname: elementSnapshot.name,\n\t\t\tattributes: new Map( elementSnapshot.attributes ),\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an object with a single remove change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {Object} elementSnapshot The snapshot of the removed element a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getRemoveDiff( parent, offset, elementSnapshot ) {\n\t\treturn {\n\t\t\ttype: 'remove',\n\t\t\tposition: Position._createAt( parent, offset ),\n\t\t\tname: elementSnapshot.name,\n\t\t\tattributes: new Map( elementSnapshot.attributes ),\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an array of objects where each one is a single attribute change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range The range where the change happened.\n\t * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n\t * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n\t * @returns {Array.<Object>} An array containing one or more diff items.\n\t */\n\t_getAttributesDiff( range, oldAttributes, newAttributes ) {\n\t\t// Results holder.\n\t\tconst diffs = [];\n\n\t\t// Clone new attributes as we will be performing changes on this object.\n\t\tnewAttributes = new Map( newAttributes );\n\n\t\t// Look through old attributes.\n\t\tfor ( const [ key, oldValue ] of oldAttributes ) {\n\t\t\t// Check what is the new value of the attribute (or if it was removed).\n\t\t\tconst newValue = newAttributes.has( key ) ? newAttributes.get( key ) : null;\n\n\t\t\t// If values are different (or attribute was removed)...\n\t\t\tif ( newValue !== oldValue ) {\n\t\t\t\t// Add diff item.\n\t\t\t\tdiffs.push( {\n\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\tposition: range.start,\n\t\t\t\t\trange: range.clone(),\n\t\t\t\t\tlength: 1,\n\t\t\t\t\tattributeKey: key,\n\t\t\t\t\tattributeOldValue: oldValue,\n\t\t\t\t\tattributeNewValue: newValue,\n\t\t\t\t\tchangeCount: this._changeCount++\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Prevent returning two diff items for the same change.\n\t\t\tnewAttributes.delete( key );\n\t\t}\n\n\t\t// Look through new attributes that weren't handled above.\n\t\tfor ( const [ key, newValue ] of newAttributes ) {\n\t\t\t// Each of them is a new attribute. Add diff item.\n\t\t\tdiffs.push( {\n\t\t\t\ttype: 'attribute',\n\t\t\t\tposition: range.start,\n\t\t\t\trange: range.clone(),\n\t\t\t\tlength: 1,\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: null,\n\t\t\t\tattributeNewValue: newValue,\n\t\t\t\tchangeCount: this._changeCount++\n\t\t\t} );\n\t\t}\n\n\t\treturn diffs;\n\t}\n\n\t/**\n\t * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element Element to check.\n\t * @returns {Boolean}\n\t */\n\t_isInInsertedElement( element ) {\n\t\tconst parent = element.parent;\n\n\t\tif ( !parent ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst changes = this._changesInElement.get( parent );\n\t\tconst offset = element.startOffset;\n\n\t\tif ( changes ) {\n\t\t\tfor ( const change of changes ) {\n\t\t\t\tif ( change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._isInInsertedElement( parent );\n\t}\n\n\t/**\n\t * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n\t * and `howMany`.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_removeAllNestedChanges( parent, offset, howMany ) {\n\t\tconst range = new Range( Position._createAt( parent, offset ), Position._createAt( parent, offset + howMany ) );\n\n\t\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\tthis._elementSnapshots.delete( item );\n\t\t\t\tthis._changesInElement.delete( item );\n\n\t\t\t\tthis._removeAllNestedChanges( item, 0, item.maxOffset );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\nfunction _getChildrenSnapshot( children ) {\n\tconst snapshot = [];\n\n\tfor ( const child of children ) {\n\t\tif ( child.is( '$text' ) ) {\n\t\t\tfor ( let i = 0; i < child.data.length; i++ ) {\n\t\t\t\tsnapshot.push( {\n\t\t\t\t\tname: '$text',\n\t\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\tsnapshot.push( {\n\t\t\t\tname: child.name,\n\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn snapshot;\n}\n\n// Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\nfunction _generateActionsFromChanges( oldChildrenLength, changes ) {\n\tconst actions = [];\n\n\tlet offset = 0;\n\tlet oldChildrenHandled = 0;\n\n\t// Go through all buffered changes.\n\tfor ( const change of changes ) {\n\t\t// First, fill \"holes\" between changes with \"equal\" actions.\n\t\tif ( change.offset > offset ) {\n\t\t\tfor ( let i = 0; i < change.offset - offset; i++ ) {\n\t\t\t\tactions.push( 'e' );\n\t\t\t}\n\n\t\t\toldChildrenHandled += change.offset - offset;\n\t\t}\n\n\t\t// Then, fill up actions accordingly to change type.\n\t\tif ( change.type == 'insert' ) {\n\t\t\tfor ( let i = 0; i < change.howMany; i++ ) {\n\t\t\t\tactions.push( 'i' );\n\t\t\t}\n\n\t\t\t// The last handled offset is after inserted range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t} else if ( change.type == 'remove' ) {\n\t\t\tfor ( let i = 0; i < change.howMany; i++ ) {\n\t\t\t\tactions.push( 'r' );\n\t\t\t}\n\n\t\t\t// The last handled offset is at the position where the nodes were removed.\n\t\t\toffset = change.offset;\n\t\t\t// We removed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t} else {\n\t\t\tactions.push( ...'a'.repeat( change.howMany ).split( '' ) );\n\n\t\t\t// The last handled offset is at the position after the changed range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t\t// We changed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t}\n\t}\n\n\t// Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n\t// has not been changed / removed at the end of their parent.\n\tif ( oldChildrenHandled < oldChildrenLength ) {\n\t\tfor ( let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++ ) {\n\t\t\tactions.push( 'e' );\n\t\t}\n\t}\n\n\treturn actions;\n}\n\n// Filter callback for Array.filter that filters out change entries that are in graveyard.\nfunction _changesInGraveyardFilter( entry ) {\n\tconst posInGy = entry.position && entry.position.root.rootName == '$graveyard';\n\tconst rangeInGy = entry.range && entry.range.root.rootName == '$graveyard';\n\n\treturn !posInGy && !rangeInGy;\n}\n\n/**\n * The single diff item.\n *\n * Could be one of:\n *\n * * {@link module:engine/model/differ~DiffItemInsert `DiffItemInsert`},\n * * {@link module:engine/model/differ~DiffItemRemove `DiffItemRemove`},\n * * {@link module:engine/model/differ~DiffItemAttribute `DiffItemAttribute`}.\n *\n * @interface DiffItem\n */\n\n/**\n * The single diff item for inserted nodes.\n *\n * @class DiffItemInsert\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'insert'} module:engine/model/differ~DiffItemInsert#type\n */\n\n/**\n * The name of the inserted elements or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemInsert#name\n */\n\n/**\n * Map of attributes that were set on the item while it was inserted.\n *\n * @member {Map.<String,*>} module:engine/model/differ~DiffItemInsert#attributes\n */\n\n/**\n * The position where the node was inserted.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemInsert#position\n */\n\n/**\n * The length of an inserted text node. For elements it is always 1 as each inserted element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemInsert#length\n */\n\n/**\n * The single diff item for removed nodes.\n *\n * @class DiffItemRemove\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'remove'} module:engine/model/differ~DiffItemRemove#type\n */\n\n/**\n * The name of the removed element or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemRemove#name\n */\n\n/**\n * Map of attributes that were set on the item while it was removed.\n *\n * @member {Map.<String,*>} module:engine/model/differ~DiffItemRemove#attributes\n */\n\n/**\n * The position where the node was removed.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemRemove#position\n */\n\n/**\n * The length of a removed text node. For elements it is always 1 as each removed element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemRemove#length\n */\n\n/**\n * The single diff item for attribute change.\n *\n * @class DiffItemAttribute\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'attribute'} module:engine/model/differ~DiffItemAttribute#type\n */\n\n/**\n * The name of the changed attribute.\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeKey\n */\n\n/**\n * An attribute previous value (before change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeOldValue\n */\n\n/**\n * An attribute new value (after change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeNewValue\n */\n\n/**\n * The range where the change happened.\n *\n * @member {module:engine/model/range~Range} module:engine/model/differ~DiffItemAttribute#range\n */\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,QAAP,MAAqB,YAArB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,MAAN,CAAa;EAC3B;AACD;AACA;AACA;AACA;EACCC,WAAW,CAAEC,gBAAF,EAAqB;IAC/B;AACF;AACA;AACA;AACA;AACA;IACE,KAAKC,iBAAL,GAAyBD,gBAAzB;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACE,KAAKE,iBAAL,GAAyB,IAAIC,GAAJ,EAAzB;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;IACE,KAAKC,iBAAL,GAAyB,IAAID,GAAJ,EAAzB;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACE,KAAKE,eAAL,GAAuB,IAAIF,GAAJ,EAAvB;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;;IACE,KAAKG,YAAL,GAAoB,CAApB;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACE,KAAKC,cAAL,GAAsB,IAAtB;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACE,KAAKC,2BAAL,GAAmC,IAAnC;IAEA;AACF;AACA;AACA;AACA;AACA;;IACE,KAAKC,eAAL,GAAuB,IAAIC,GAAJ,EAAvB;EACA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACY,IAAPC,OAAO,GAAG;IACb,OAAO,KAAKT,iBAAL,CAAuBU,IAAvB,IAA+B,CAA/B,IAAoC,KAAKP,eAAL,CAAqBO,IAArB,IAA6B,CAAxE;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCC,eAAe,CAAEC,SAAF,EAAc;IAC5B;IACA;IACA;IACA;IACA,QAASA,SAAS,CAACC,IAAnB;MACC,KAAK,QAAL;QAAe;UACd,IAAK,KAAKC,oBAAL,CAA2BF,SAAS,CAACG,QAAV,CAAmBC,MAA9C,CAAL,EAA8D;YAC7D;UACA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AkB,IAAIzG,MAAM,CAAC7B,OAA7B;IACA;EACD,CA1CiE,CA4ClE;EACA;;;EACA,IAAKsI,kBAAkB,GAAGD,iBAA1B,EAA8C;IAC7C,KAAM,IAAItE,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGsE,iBAAiB,GAAGC,kBAApB,GAAyClJ,MAA9D,EAAsE2E,CAAC,EAAvE,EAA4E;MAC3EH,OAAO,CAAC9B,IAAR,CAAc,GAAd;IACA;EACD;;EAED,OAAO8B,OAAP;AACA,C,CAED;;;AACA,SAASiC,yBAAT,CAAoC4C,KAApC,EAA4C;EAC3C,MAAMC,OAAO,GAAGD,KAAK,CAACxJ,QAAN,IAAkBwJ,KAAK,CAACxJ,QAAN,CAAe2F,IAAf,CAAoBC,QAApB,IAAgC,YAAlE;EACA,MAAM8D,SAAS,GAAGF,KAAK,CAACjJ,KAAN,IAAeiJ,KAAK,CAACjJ,KAAN,CAAYoF,IAAZ,CAAiBC,QAAjB,IAA6B,YAA9D;EAEA,OAAO,CAAC6D,OAAD,IAAY,CAACC,SAApB;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}