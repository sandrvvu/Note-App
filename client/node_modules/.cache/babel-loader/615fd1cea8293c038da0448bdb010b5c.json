{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/document\n */\nimport Differ from './differ';\nimport RootElement from './rootelement';\nimport History from './history';\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport { clone } from 'lodash-es'; // @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n\nconst graveyardName = '$graveyard';\n/**\n * Data model's document. It contains the model's structure, its selection and the history of changes.\n *\n * Read more about working with the model in\n * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.\n *\n * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so\n * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:\n *\n *\t\tmodel.document.getRoot(); // -> returns the main root\n *\n * However, the document may contain multiple roots – e.g. when the editor has multiple editable areas\n * (e.g. a title and a body of a message).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class Document {\n  /**\n   * Creates an empty document instance with no {@link #roots} (other than\n   * the {@link #graveyard graveyard root}).\n   */\n  constructor(model) {\n    /**\n     * The {@link module:engine/model/model~Model model} that the document is a part of.\n     *\n     * @readonly\n     * @type {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * The document's history.\n     *\n     * @readonly\n     * @type {module:engine/model/history~History}\n     */\n\n    this.history = new History();\n    /**\n     * The selection in this document.\n     *\n     * @readonly\n     * @type {module:engine/model/documentselection~DocumentSelection}\n     */\n\n    this.selection = new DocumentSelection(this);\n    /**\n     * A list of roots that are owned and managed by this document. Use {@link #createRoot} and\n     * {@link #getRoot} to manipulate it.\n     *\n     * @readonly\n     * @type {module:utils/collection~Collection}\n     */\n\n    this.roots = new Collection({\n      idProperty: 'rootName'\n    });\n    /**\n     * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.\n     *\n     * @readonly\n     * @type {module:engine/model/differ~Differ}\n     */\n\n    this.differ = new Differ(model.markers);\n    /**\n     * Post-fixer callbacks registered to the model document.\n     *\n     * @private\n     * @type {Set.<Function>}\n     */\n\n    this._postFixers = new Set();\n    /**\n     * A boolean indicates whether the selection has changed until\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    this._hasSelectionChangedFromTheLastChangeBlock = false; // Graveyard tree root. Document always have a graveyard root, which stores removed nodes.\n\n    this.createRoot('$root', graveyardName); // Then, still before an operation is applied on model, buffer the change in differ.\n\n    this.listenTo(model, 'applyOperation', (evt, args) => {\n      const operation = args[0];\n\n      if (operation.isDocumentOperation) {\n        this.differ.bufferOperation(operation);\n      }\n    }, {\n      priority: 'high'\n    }); // After the operation is applied, bump document's version and add the operation to the history.\n\n    this.listenTo(model, 'applyOperation', (evt, args) => {\n      const operation = args[0];\n\n      if (operation.isDocumentOperation) {\n        this.history.addOperation(operation);\n      }\n    }, {\n      priority: 'low'\n    }); // Listen to selection changes. If selection changed, mark it.\n\n    this.listenTo(this.selection, 'change', () => {\n      this._hasSelectionChangedFromTheLastChangeBlock = true;\n    }); // Buffer marker changes.\n    // This is not covered in buffering operations because markers may change outside of them (when they\n    // are modified using `model.markers` collection, not through `MarkerOperation`).\n\n    this.listenTo(model.markers, 'update', (evt, marker, oldRange, newRange, oldMarkerData) => {\n      // Copy the `newRange` to the new marker data as during the marker removal the range is not updated.\n      const newMarkerData = { ...marker.getData(),\n        range: newRange\n      }; // Whenever marker is updated, buffer that change.\n\n      this.differ.bufferMarkerChange(marker.name, oldMarkerData, newMarkerData);\n\n      if (oldRange === null) {\n        // If this is a new marker, add a listener that will buffer change whenever marker changes.\n        marker.on('change', (evt, oldRange) => {\n          const markerData = marker.getData();\n          this.differ.bufferMarkerChange(marker.name, { ...markerData,\n            range: oldRange\n          }, markerData);\n        });\n      }\n    });\n  }\n  /**\n   * The document version. Every applied operation increases the version number. It is used to\n   * ensure that operations are applied on a proper document version.\n   *\n   * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.\n   *\n   * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,\n   * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.\n   *\n   * @type {Number}\n   */\n\n\n  get version() {\n    return this.history.version;\n  }\n\n  set version(version) {\n    this.history.version = version;\n  }\n  /**\n   * The graveyard tree root. A document always has a graveyard root that stores removed nodes.\n   *\n   * @readonly\n   * @member {module:engine/model/rootelement~RootElement}\n   */\n\n\n  get graveyard() {\n    return this.getRoot(graveyardName);\n  }\n  /**\n   * Creates a new root.\n   *\n   * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined\n   * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.\n   * @param {String} [rootName='main'] A unique root name.\n   * @returns {module:engine/model/rootelement~RootElement} The created root.\n   */\n\n\n  createRoot() {\n    let elementName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$root';\n    let rootName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'main';\n\n    if (this.roots.get(rootName)) {\n      /**\n       * A root with the specified name already exists.\n       *\n       * @error model-document-createroot-name-exists\n       * @param {module:engine/model/document~Document} doc\n       * @param {String} name\n       */\n      throw new CKEditorError('model-document-createroot-name-exists', this, {\n        name: rootName\n      });\n    }\n\n    const root = new RootElement(this, elementName, rootName);\n    this.roots.add(root);\n    return root;\n  }\n  /**\n   * Removes all event listeners set by the document instance.\n   */\n\n\n  destroy() {\n    this.selection.destroy();\n    this.stopListening();\n  }\n  /**\n   * Returns a root by its name.\n   *\n   * @param {String} [name='main'] A unique root name.\n   * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when\n   * there is no root with the given name.\n   */\n\n\n  getRoot() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n    return this.roots.get(name);\n  }\n  /**\n   * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.\n   *\n   * @returns {Array.<String>} Roots names.\n   */\n\n\n  getRootNames() {\n    return Array.from(this.roots, root => root.rootName).filter(name => name != graveyardName);\n  }\n  /**\n   * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features\n   * will operate on a correct model state.\n   *\n   * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after\n   * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but\n   * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made\n   * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n   * not be fixed in the new document tree state.\n   *\n   * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the\n   * executed changes block. Thanks to that, all changes done by the callback will be added to the same\n   * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent\n   * for the user.\n   *\n   * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the\n   * callback should add an empty paragraph so that the editor is never empty:\n   *\n   *\t\tdocument.registerPostFixer( writer => {\n   *\t\t\tconst changes = document.differ.getChanges();\n   *\n   *\t\t\t// Check if the changes lead to an empty root in the editor.\n   *\t\t\tfor ( const entry of changes ) {\n   *\t\t\t\tif ( entry.type == 'remove' && entry.position.root.isEmpty ) {\n   *\t\t\t\t\twriter.insertElement( 'paragraph', entry.position.root, 0 );\n   *\n   *\t\t\t\t\t// It is fine to return early, even if multiple roots would need to be fixed.\n   *\t\t\t\t\t// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.\n   *\t\t\t\t\treturn true;\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   * @param {Function} postFixer\n   */\n\n\n  registerPostFixer(postFixer) {\n    this._postFixers.add(postFixer);\n  }\n  /**\n   * A custom `toJSON()` method to solve child-parent circular dependencies.\n   *\n   * @returns {Object} A clone of this object with the document property changed to a string.\n   */\n\n\n  toJSON() {\n    const json = clone(this); // Due to circular references we need to remove parent reference.\n\n    json.selection = '[engine.model.DocumentSelection]';\n    json.model = '[engine.model.Model]';\n    return json;\n  }\n  /**\n   * Check if there were any changes done on document, and if so, call post-fixers,\n   * fire `change` event for features and conversion and then reset the differ.\n   * Fire `change:data` event when at least one operation or buffered marker changes the data.\n   *\n   * @protected\n   * @fires change\n   * @fires change:data\n   * @param {module:engine/model/writer~Writer} writer The writer on which post-fixers will be called.\n   */\n\n\n  _handleChangeBlock(writer) {\n    if (this._hasDocumentChangedFromTheLastChangeBlock()) {\n      this._callPostFixers(writer); // Refresh selection attributes according to the final position in the model after the change.\n\n\n      this.selection.refresh();\n\n      if (this.differ.hasDataChanges()) {\n        this.fire('change:data', writer.batch);\n      } else {\n        this.fire('change', writer.batch);\n      } // Theoretically, it is not necessary to refresh selection after change event because\n      // post-fixers are the last who should change the model, but just in case...\n\n\n      this.selection.refresh();\n      this.differ.reset();\n    }\n\n    this._hasSelectionChangedFromTheLastChangeBlock = false;\n  }\n  /**\n   * Returns whether there is a buffered change or if the selection has changed from the last\n   * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}\n   * or {@link module:engine/model/model~Model#change `change()` block}.\n   *\n   * @protected\n   * @returns {Boolean} Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.\n   */\n\n\n  _hasDocumentChangedFromTheLastChangeBlock() {\n    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;\n  }\n  /**\n   * Returns the default root for this document which is either the first root that was added to the document using\n   * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.\n   *\n   * @protected\n   * @returns {module:engine/model/rootelement~RootElement} The default root for this document.\n   */\n\n\n  _getDefaultRoot() {\n    for (const root of this.roots) {\n      if (root !== this.graveyard) {\n        return root;\n      }\n    }\n\n    return this.graveyard;\n  }\n  /**\n   * Returns the default range for this selection. The default range is a collapsed range that starts and ends\n   * at the beginning of this selection's document {@link #_getDefaultRoot default root}.\n   *\n   * @protected\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  _getDefaultRange() {\n    const defaultRoot = this._getDefaultRoot();\n\n    const model = this.model;\n    const schema = model.schema; // Find the first position where the selection can be put.\n\n    const position = model.createPositionFromPath(defaultRoot, [0]);\n    const nearestRange = schema.getNearestSelectionRange(position); // If valid selection range is not found - return range collapsed at the beginning of the root.\n\n    return nearestRange || model.createRange(position);\n  }\n  /**\n   * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for\n   * the {@link #selection document's selection}.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range A range to check.\n   * @returns {Boolean} `true` if `range` is valid, `false` otherwise.\n   */\n\n\n  _validateSelectionRange(range) {\n    return validateTextNodePosition(range.start) && validateTextNodePosition(range.end);\n  }\n  /**\n   * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n   *\n   * @private\n   * @param {module:engine/model/writer~Writer} writer The writer on which post-fixer callbacks will be called.\n   */\n\n\n  _callPostFixers(writer) {\n    let wasFixed = false;\n\n    do {\n      for (const callback of this._postFixers) {\n        // Ensure selection attributes are up to date before each post-fixer.\n        // https://github.com/ckeditor/ckeditor5-engine/issues/1673.\n        //\n        // It might be good to refresh the selection after each operation but at the moment it leads\n        // to losing attributes for composition or and spell checking\n        // https://github.com/ckeditor/ckeditor5-typing/issues/188\n        this.selection.refresh();\n        wasFixed = callback(writer);\n\n        if (wasFixed) {\n          break;\n        }\n      }\n    } while (wasFixed);\n  }\n  /**\n   * Fired after each {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block} or the outermost\n   * {@link module:engine/model/model~Model#change `change()` block} was executed and the document was changed\n   * during that block's execution.\n   *\n   * The changes which this event will cover include:\n   *\n   * * document structure changes,\n   * * selection changes,\n   * * marker changes.\n   *\n   * If you want to be notified about all these changes, then simply listen to this event like this:\n   *\n   *\t\tmodel.document.on( 'change', () => {\n   *\t\t\tconsole.log( 'The document has changed!' );\n   *\t\t} );\n   *\n   * If, however, you only want to be notified about the data changes, then use the\n   * {@link module:engine/model/document~Document#event:change:data change:data} event,\n   * which is fired for document structure changes and marker changes (which affects the data).\n   *\n   *\t\tmodel.document.on( 'change:data', () => {\n   *\t\t\tconsole.log( 'The data has changed!' );\n   *\t\t} );\n   *\n   * @event change\n   * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n   */\n\n  /**\n   * It is a narrower version of the {@link #event:change} event. It is fired for changes which\n   * affect the editor data. This is:\n   *\n   * * document structure changes,\n   * * marker changes (which affects the data).\n   *\n   * If you want to be notified about the data changes, then listen to this event:\n   *\n   *\t\tmodel.document.on( 'change:data', () => {\n   *\t\t\tconsole.log( 'The data has changed!' );\n   *\t\t} );\n   *\n   * If you would like to listen to all document changes, then check out the\n   * {@link module:engine/model/document~Document#event:change change} event.\n   *\n   * @event change:data\n   * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n   */\n  // @if CK_DEBUG_ENGINE // log( version = null ) {\n  // @if CK_DEBUG_ENGINE // \tversion = version === null ? this.version : version;\n  // @if CK_DEBUG_ENGINE // \tlogDocument( this, version );\n  // @if CK_DEBUG_ENGINE // }\n\n\n}\nmix(Document, EmitterMixin); // Checks whether given range boundary position is valid for document selection, meaning that is not between\n// unicode surrogate pairs or base character and combining marks.\n\nfunction validateTextNodePosition(rangeBoundary) {\n  const textNode = rangeBoundary.textNode;\n\n  if (textNode) {\n    const data = textNode.data;\n    const offset = rangeBoundary.offset - textNode.startOffset;\n    return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);\n  }\n\n  return true;\n}","map":{"version":3,"names":["Differ","RootElement","History","DocumentSelection","Collection","EmitterMixin","CKEditorError","mix","isInsideSurrogatePair","isInsideCombinedSymbol","clone","graveyardName","Document","constructor","model","history","selection","roots","idProperty","differ","markers","_postFixers","Set","_hasSelectionChangedFromTheLastChangeBlock","createRoot","listenTo","evt","args","operation","isDocumentOperation","bufferOperation","priority","addOperation","marker","oldRange","newRange","oldMarkerData","newMarkerData","getData","range","bufferMarkerChange","name","on","markerData","version","graveyard","getRoot","elementName","rootName","get","root","add","destroy","stopListening","getRootNames","Array","from","filter","registerPostFixer","postFixer","toJSON","json","_handleChangeBlock","writer","_hasDocumentChangedFromTheLastChangeBlock","_callPostFixers","refresh","hasDataChanges","fire","batch","reset","isEmpty","_getDefaultRoot","_getDefaultRange","defaultRoot","schema","position","createPositionFromPath","nearestRange","getNearestSelectionRange","createRange","_validateSelectionRange","validateTextNodePosition","start","end","wasFixed","callback","rangeBoundary","textNode","data","offset","startOffset"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/model/document.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/document\n */\n\nimport Differ from './differ';\nimport RootElement from './rootelement';\nimport History from './history';\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport { clone } from 'lodash-es';\n\n// @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n\nconst graveyardName = '$graveyard';\n\n/**\n * Data model's document. It contains the model's structure, its selection and the history of changes.\n *\n * Read more about working with the model in\n * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.\n *\n * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so\n * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:\n *\n *\t\tmodel.document.getRoot(); // -> returns the main root\n *\n * However, the document may contain multiple roots – e.g. when the editor has multiple editable areas\n * (e.g. a title and a body of a message).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Document {\n\t/**\n\t * Creates an empty document instance with no {@link #roots} (other than\n\t * the {@link #graveyard graveyard root}).\n\t */\n\tconstructor( model ) {\n\t\t/**\n\t\t * The {@link module:engine/model/model~Model model} that the document is a part of.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The document's history.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/history~History}\n\t\t */\n\t\tthis.history = new History();\n\n\t\t/**\n\t\t * The selection in this document.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/documentselection~DocumentSelection}\n\t\t */\n\t\tthis.selection = new DocumentSelection( this );\n\n\t\t/**\n\t\t * A list of roots that are owned and managed by this document. Use {@link #createRoot} and\n\t\t * {@link #getRoot} to manipulate it.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:utils/collection~Collection}\n\t\t */\n\t\tthis.roots = new Collection( { idProperty: 'rootName' } );\n\n\t\t/**\n\t\t * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/differ~Differ}\n\t\t */\n\t\tthis.differ = new Differ( model.markers );\n\n\t\t/**\n\t\t * Post-fixer callbacks registered to the model document.\n\t\t *\n\t\t * @private\n\t\t * @type {Set.<Function>}\n\t\t */\n\t\tthis._postFixers = new Set();\n\n\t\t/**\n\t\t * A boolean indicates whether the selection has changed until\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._hasSelectionChangedFromTheLastChangeBlock = false;\n\n\t\t// Graveyard tree root. Document always have a graveyard root, which stores removed nodes.\n\t\tthis.createRoot( '$root', graveyardName );\n\n\t\t// Then, still before an operation is applied on model, buffer the change in differ.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation ) {\n\t\t\t\tthis.differ.bufferOperation( operation );\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\n\t\t// After the operation is applied, bump document's version and add the operation to the history.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation ) {\n\t\t\t\tthis.history.addOperation( operation );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// Listen to selection changes. If selection changed, mark it.\n\t\tthis.listenTo( this.selection, 'change', () => {\n\t\t\tthis._hasSelectionChangedFromTheLastChangeBlock = true;\n\t\t} );\n\n\t\t// Buffer marker changes.\n\t\t// This is not covered in buffering operations because markers may change outside of them (when they\n\t\t// are modified using `model.markers` collection, not through `MarkerOperation`).\n\t\tthis.listenTo( model.markers, 'update', ( evt, marker, oldRange, newRange, oldMarkerData ) => {\n\t\t\t// Copy the `newRange` to the new marker data as during the marker removal the range is not updated.\n\t\t\tconst newMarkerData = { ...marker.getData(), range: newRange };\n\n\t\t\t// Whenever marker is updated, buffer that change.\n\t\t\tthis.differ.bufferMarkerChange( marker.name, oldMarkerData, newMarkerData );\n\n\t\t\tif ( oldRange === null ) {\n\t\t\t\t// If this is a new marker, add a listener that will buffer change whenever marker changes.\n\t\t\t\tmarker.on( 'change', ( evt, oldRange ) => {\n\t\t\t\t\tconst markerData = marker.getData();\n\n\t\t\t\t\tthis.differ.bufferMarkerChange(\n\t\t\t\t\t\tmarker.name,\n\t\t\t\t\t\t{ ...markerData, range: oldRange },\n\t\t\t\t\t\tmarkerData\n\t\t\t\t\t);\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * The document version. Every applied operation increases the version number. It is used to\n\t * ensure that operations are applied on a proper document version.\n\t *\n\t * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.\n\t *\n\t * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,\n\t * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.\n\t *\n\t * @type {Number}\n\t */\n\tget version() {\n\t\treturn this.history.version;\n\t}\n\n\tset version( version ) {\n\t\tthis.history.version = version;\n\t}\n\n\t/**\n\t * The graveyard tree root. A document always has a graveyard root that stores removed nodes.\n\t *\n\t * @readonly\n\t * @member {module:engine/model/rootelement~RootElement}\n\t */\n\tget graveyard() {\n\t\treturn this.getRoot( graveyardName );\n\t}\n\n\t/**\n\t * Creates a new root.\n\t *\n\t * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined\n\t * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.\n\t * @param {String} [rootName='main'] A unique root name.\n\t * @returns {module:engine/model/rootelement~RootElement} The created root.\n\t */\n\tcreateRoot( elementName = '$root', rootName = 'main' ) {\n\t\tif ( this.roots.get( rootName ) ) {\n\t\t\t/**\n\t\t\t * A root with the specified name already exists.\n\t\t\t *\n\t\t\t * @error model-document-createroot-name-exists\n\t\t\t * @param {module:engine/model/document~Document} doc\n\t\t\t * @param {String} name\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-document-createroot-name-exists', this, { name: rootName } );\n\t\t}\n\n\t\tconst root = new RootElement( this, elementName, rootName );\n\t\tthis.roots.add( root );\n\n\t\treturn root;\n\t}\n\n\t/**\n\t * Removes all event listeners set by the document instance.\n\t */\n\tdestroy() {\n\t\tthis.selection.destroy();\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Returns a root by its name.\n\t *\n\t * @param {String} [name='main'] A unique root name.\n\t * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when\n\t * there is no root with the given name.\n\t */\n\tgetRoot( name = 'main' ) {\n\t\treturn this.roots.get( name );\n\t}\n\n\t/**\n\t * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.\n\t *\n\t * @returns {Array.<String>} Roots names.\n\t */\n\tgetRootNames() {\n\t\treturn Array.from( this.roots, root => root.rootName ).filter( name => name != graveyardName );\n\t}\n\n\t/**\n\t * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features\n\t * will operate on a correct model state.\n\t *\n\t * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after\n\t * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but\n\t * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made\n\t * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n\t * not be fixed in the new document tree state.\n\t *\n\t * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the\n\t * executed changes block. Thanks to that, all changes done by the callback will be added to the same\n\t * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent\n\t * for the user.\n\t *\n\t * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the\n\t * callback should add an empty paragraph so that the editor is never empty:\n\t *\n\t *\t\tdocument.registerPostFixer( writer => {\n\t *\t\t\tconst changes = document.differ.getChanges();\n\t *\n\t *\t\t\t// Check if the changes lead to an empty root in the editor.\n\t *\t\t\tfor ( const entry of changes ) {\n\t *\t\t\t\tif ( entry.type == 'remove' && entry.position.root.isEmpty ) {\n\t *\t\t\t\t\twriter.insertElement( 'paragraph', entry.position.root, 0 );\n\t *\n\t *\t\t\t\t\t// It is fine to return early, even if multiple roots would need to be fixed.\n\t *\t\t\t\t\t// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.\n\t *\t\t\t\t\treturn true;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @param {Function} postFixer\n\t */\n\tregisterPostFixer( postFixer ) {\n\t\tthis._postFixers.add( postFixer );\n\t}\n\n\t/**\n\t * A custom `toJSON()` method to solve child-parent circular dependencies.\n\t *\n\t * @returns {Object} A clone of this object with the document property changed to a string.\n\t */\n\ttoJSON() {\n\t\tconst json = clone( this );\n\n\t\t// Due to circular references we need to remove parent reference.\n\t\tjson.selection = '[engine.model.DocumentSelection]';\n\t\tjson.model = '[engine.model.Model]';\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Check if there were any changes done on document, and if so, call post-fixers,\n\t * fire `change` event for features and conversion and then reset the differ.\n\t * Fire `change:data` event when at least one operation or buffered marker changes the data.\n\t *\n\t * @protected\n\t * @fires change\n\t * @fires change:data\n\t * @param {module:engine/model/writer~Writer} writer The writer on which post-fixers will be called.\n\t */\n\t_handleChangeBlock( writer ) {\n\t\tif ( this._hasDocumentChangedFromTheLastChangeBlock() ) {\n\t\t\tthis._callPostFixers( writer );\n\n\t\t\t// Refresh selection attributes according to the final position in the model after the change.\n\t\t\tthis.selection.refresh();\n\n\t\t\tif ( this.differ.hasDataChanges() ) {\n\t\t\t\tthis.fire( 'change:data', writer.batch );\n\t\t\t} else {\n\t\t\t\tthis.fire( 'change', writer.batch );\n\t\t\t}\n\n\t\t\t// Theoretically, it is not necessary to refresh selection after change event because\n\t\t\t// post-fixers are the last who should change the model, but just in case...\n\t\t\tthis.selection.refresh();\n\n\t\t\tthis.differ.reset();\n\t\t}\n\n\t\tthis._hasSelectionChangedFromTheLastChangeBlock = false;\n\t}\n\n\t/**\n\t * Returns whether there is a buffered change or if the selection has changed from the last\n\t * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}\n\t * or {@link module:engine/model/model~Model#change `change()` block}.\n\t *\n\t * @protected\n\t * @returns {Boolean} Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.\n\t */\n\t_hasDocumentChangedFromTheLastChangeBlock() {\n\t\treturn !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;\n\t}\n\n\t/**\n\t * Returns the default root for this document which is either the first root that was added to the document using\n\t * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/rootelement~RootElement} The default root for this document.\n\t */\n\t_getDefaultRoot() {\n\t\tfor ( const root of this.roots ) {\n\t\t\tif ( root !== this.graveyard ) {\n\t\t\t\treturn root;\n\t\t\t}\n\t\t}\n\n\t\treturn this.graveyard;\n\t}\n\n\t/**\n\t * Returns the default range for this selection. The default range is a collapsed range that starts and ends\n\t * at the beginning of this selection's document {@link #_getDefaultRoot default root}.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getDefaultRange() {\n\t\tconst defaultRoot = this._getDefaultRoot();\n\t\tconst model = this.model;\n\t\tconst schema = model.schema;\n\n\t\t// Find the first position where the selection can be put.\n\t\tconst position = model.createPositionFromPath( defaultRoot, [ 0 ] );\n\t\tconst nearestRange = schema.getNearestSelectionRange( position );\n\n\t\t// If valid selection range is not found - return range collapsed at the beginning of the root.\n\t\treturn nearestRange || model.createRange( position );\n\t}\n\n\t/**\n\t * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for\n\t * the {@link #selection document's selection}.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range A range to check.\n\t * @returns {Boolean} `true` if `range` is valid, `false` otherwise.\n\t */\n\t_validateSelectionRange( range ) {\n\t\treturn validateTextNodePosition( range.start ) && validateTextNodePosition( range.end );\n\t}\n\n\t/**\n\t * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n\t *\n\t * @private\n\t * @param {module:engine/model/writer~Writer} writer The writer on which post-fixer callbacks will be called.\n\t */\n\t_callPostFixers( writer ) {\n\t\tlet wasFixed = false;\n\n\t\tdo {\n\t\t\tfor ( const callback of this._postFixers ) {\n\t\t\t\t// Ensure selection attributes are up to date before each post-fixer.\n\t\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/1673.\n\t\t\t\t//\n\t\t\t\t// It might be good to refresh the selection after each operation but at the moment it leads\n\t\t\t\t// to losing attributes for composition or and spell checking\n\t\t\t\t// https://github.com/ckeditor/ckeditor5-typing/issues/188\n\t\t\t\tthis.selection.refresh();\n\n\t\t\t\twasFixed = callback( writer );\n\n\t\t\t\tif ( wasFixed ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while ( wasFixed );\n\t}\n\n\t/**\n\t * Fired after each {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block} or the outermost\n\t * {@link module:engine/model/model~Model#change `change()` block} was executed and the document was changed\n\t * during that block's execution.\n\t *\n\t * The changes which this event will cover include:\n\t *\n\t * * document structure changes,\n\t * * selection changes,\n\t * * marker changes.\n\t *\n\t * If you want to be notified about all these changes, then simply listen to this event like this:\n\t *\n\t *\t\tmodel.document.on( 'change', () => {\n\t *\t\t\tconsole.log( 'The document has changed!' );\n\t *\t\t} );\n\t *\n\t * If, however, you only want to be notified about the data changes, then use the\n\t * {@link module:engine/model/document~Document#event:change:data change:data} event,\n\t * which is fired for document structure changes and marker changes (which affects the data).\n\t *\n\t *\t\tmodel.document.on( 'change:data', () => {\n\t *\t\t\tconsole.log( 'The data has changed!' );\n\t *\t\t} );\n\t *\n\t * @event change\n\t * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n\t */\n\n\t/**\n\t * It is a narrower version of the {@link #event:change} event. It is fired for changes which\n\t * affect the editor data. This is:\n\t *\n\t * * document structure changes,\n\t * * marker changes (which affects the data).\n\t *\n\t * If you want to be notified about the data changes, then listen to this event:\n\t *\n\t *\t\tmodel.document.on( 'change:data', () => {\n\t *\t\t\tconsole.log( 'The data has changed!' );\n\t *\t\t} );\n\t *\n\t * If you would like to listen to all document changes, then check out the\n\t * {@link module:engine/model/document~Document#event:change change} event.\n\t *\n\t * @event change:data\n\t * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n\t */\n\n\t// @if CK_DEBUG_ENGINE // log( version = null ) {\n\t// @if CK_DEBUG_ENGINE // \tversion = version === null ? this.version : version;\n\t// @if CK_DEBUG_ENGINE // \tlogDocument( this, version );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\nmix( Document, EmitterMixin );\n\n// Checks whether given range boundary position is valid for document selection, meaning that is not between\n// unicode surrogate pairs or base character and combining marks.\nfunction validateTextNodePosition( rangeBoundary ) {\n\tconst textNode = rangeBoundary.textNode;\n\n\tif ( textNode ) {\n\t\tconst data = textNode.data;\n\t\tconst offset = rangeBoundary.offset - textNode.startOffset;\n\n\t\treturn !isInsideSurrogatePair( data, offset ) && !isInsideCombinedSymbol( data, offset );\n\t}\n\n\treturn true;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,MAAP,MAAmB,UAAnB;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,iBAAP,MAA8B,qBAA9B;AACA,OAAOC,UAAP,MAAuB,0CAAvB;AACA,OAAOC,YAAP,MAAyB,4CAAzB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AACA,SAASC,qBAAT,EAAgCC,sBAAhC,QAA8D,uCAA9D;AACA,SAASC,KAAT,QAAsB,WAAtB,C,CAEA;;AAEA,MAAMC,aAAa,GAAG,YAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,QAAN,CAAe;EAC7B;AACD;AACA;AACA;EACCC,WAAW,CAAEC,KAAF,EAAU;IACpB;AACF;AACA;AACA;AACA;AACA;IACE,KAAKA,KAAL,GAAaA,KAAb;IAEA;AACF;AACA;AACA;AACA;AACA;;IACE,KAAKC,OAAL,GAAe,IAAIb,OAAJ,EAAf;IAEA;AACF;AACA;AACA;AACA;AACA;;IACE,KAAKc,SAAL,GAAiB,IAAIb,iBAAJ,CAAuB,IAAvB,CAAjB;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;;IACE,KAAKc,KAAL,GAAa,IAAIb,UAAJ,CAAgB;MAAEc,UAAU,EAAE;IAAd,CAAhB,CAAb;IAEA;AACF;AACA;AACA;AACA;AACA;;IACE,KAAKC,MAAL,GAAc,IAAInB,MAAJ,CAAYc,KAAK,CAACM,OAAlB,CAAd;IAEA;AACF;AACA;AACA;AACA;AACA;;IACE,KAAKC,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;IAEA;AACF;AACA;AACA;AACA;AACA;;IACE,KAAKC,0CAAL,GAAkD,KAAlD,CAxDoB,CA0DpB;;IACA,KAAKC,UAAL,CAAiB,OAAjB,EAA0Bb,aAA1B,EA3DoB,CA6DpB;;IACA,KAAKc,QAAL,CAAeX,KAAf,EAAsB,gBAAtB,EAAwC,CAAEY,GAAF,EAAOC,IAAP,KAAiB;MACxD,MAAMC,SAAS,GAAGD,IAAI,CAAE,CAAF,CAAtB;;MAEA,IAAKC,SAAS,CAACC,mBAAf,EAAqC;QACpC,KAAKV,MAAL,CAAYW,eAAZ,CAA6BF,SAA7B;MACA;IACD,CAND,EAMG;MAAEG,QAAQ,EAAE;IAAZ,CANH,EA9DoB,CAsEpB;;IACA,KAAKN,QAAL,CAAeX,KAAf,EAAsB,gBAAtB,EAAwC,CAAEY,GAAF,EAAOC,IAAP,KAAiB;MACxD,MAAMC,SAAS,GAAGD,IAAI,CAAE,CAAF,CAAtB;;MAEA,IAAKC,SAAS,CAACC,mBAAf,EAAqC;QACpC,KAAKd,OAAL,CAAaiB,YAAb,CAA2BJ,SAA3B;MACA;IACD,CAND,EAMG;MAAEG,QAAQ,EAAE;IAAZ,CANH,EAvEoB,CA+EpB;;IACA,KAAKN,QAAL,CAAe,KAAKT,SAApB,EAA+B,QAA/B,EAAyC,MAAM;MAC9C,KAAKO,0CAAL,GAAkD,IAAlD;IACA,CAFD,EAhFoB,CAoFpB;IACA;IACA;;IACA,KAAKE,QAAL,CAAeX,KAAK,CAACM,OAArB,EAA8B,QAA9B,EAAwC,CAAEM,GAAF,EAAOO,MAAP,EAAeC,QAAf,EAAyBC,QAAzB,EAAmCC,aAAnC,KAAsD;MAC7F;MACA,MAAMC,aAAa,GAAG,EAAE,GAAGJ,MAAM,CAACK,OAAP,EAAL;QAAuBC,KAAK,EAAEJ;MAA9B,CAAtB,CAF6F,CAI7F;;MACA,KAAKhB,MAAL,CAAYqB,kBAAZ,CAAgCP,MAAM,CAACQ,IAAvC,EAA6CL,aAA7C,EAA4DC,aAA5D;;MAEA,IAAKH,QAAQ,KAAK,IAAlB,EAAyB;QACxB;QACAD,MAAM,CAACS,EAAP,CAAW,QAAX,EAAqB,CAAEhB,GAAF,EAAOQ,QAAP,KAAqB;UACzC,MAAMS,UAAU,GAAGV,MAAM,CAACK,OAAP,EAAnB;UAEA,KAAKnB,MAAL,CAAYqB,kBAAZ,CACCP,MAAM,CAACQ,IADR,EAEC,EAAE,GAAGE,UAAL;YAAiBJ,KAAK,EAAEL;UAAxB,CAFD,EAGCS,UAHD;QAKA,CARD;MASA;IACD,CAnBD;EAoBA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACY,IAAPC,OAAO,GAAG;IACb,OAAO,KAAK7B,OAAL,CAAa6B,OAApB;EACA;;EAEU,IAAPA,OAAO,CAAEA,OAAF,EAAY;IACtB,KAAK7B,OAAL,CAAa6B,OAAb,GAAuBA,OAAvB;EACA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACc,IAATC,SAAS,GAAG;IACf,OAAO,KAAKC,OAAL,CAAcnC,aAAd,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCa,UAAU,GAA6C;IAAA,IAA3CuB,WAA2C,uEAA7B,OAA6B;IAAA,IAApBC,QAAoB,uEAAT,MAAS;;IACtD,IAAK,KAAK/B,KAAL,CAAWgC,GAAX,CAAgBD,QAAhB,CAAL,EAAkC;MACjC;AACH;AACA;AACA;AACA;AACA;AACA;MACG,MAAM,IAAI1C,aAAJ,CAAmB,uCAAnB,EAA4D,IAA5D,EAAkE;QAAEmC,IAAI,EAAEO;MAAR,CAAlE,CAAN;IACA;;IAED,MAAME,IAAI,GAAG,IAAIjD,WAAJ,CAAiB,IAAjB,EAAuB8C,WAAvB,EAAoCC,QAApC,CAAb;IACA,KAAK/B,KAAL,CAAWkC,GAAX,CAAgBD,IAAhB;IAEA,OAAOA,IAAP;EACA;EAED;AACD;AACA;;;EACCE,OAAO,GAAG;IACT,KAAKpC,SAAL,CAAeoC,OAAf;IACA,KAAKC,aAAL;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;;;EACCP,OAAO,GAAkB;IAAA,IAAhBL,IAAgB,uEAAT,MAAS;IACxB,OAAO,KAAKxB,KAAL,CAAWgC,GAAX,CAAgBR,IAAhB,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCa,YAAY,GAAG;IACd,OAAOC,KAAK,CAACC,IAAN,CAAY,KAAKvC,KAAjB,EAAwBiC,IAAI,IAAIA,IAAI,CAACF,QAArC,EAAgDS,MAAhD,CAAwDhB,IAAI,IAAIA,IAAI,IAAI9B,aAAxE,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACC+C,iBAAiB,CAAEC,SAAF,EAAc;IAC9B,KAAKtC,WAAL,CAAiB8B,GAAjB,CAAsBQ,SAAtB;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCC,MAAM,GAAG;IACR,MAAMC,IAAI,GAAGnD,KAAK,CAAE,IAAF,CAAlB,CADQ,CAGR;;IACAmD,IAAI,CAAC7C,SAAL,GAAiB,kCAAjB;IACA6C,IAAI,CAAC/C,KAAL,GAAa,sBAAb;IAEA,OAAO+C,IAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCC,kBAAkB,CAAEC,MAAF,EAAW;IAC5B,IAAK,KAAKC,yCAAL,EAAL,EAAwD;MACvD,KAAKC,eAAL,CAAsBF,MAAtB,EADuD,CAGvD;;;MACA,KAAK/C,SAAL,CAAekD,OAAf;;MAEA,IAAK,KAAK/C,MAAL,CAAYgD,cAAZ,EAAL,EAAoC;QACnC,KAAKC,IAAL,CAAW,aAAX,EAA0BL,MAAM,CAACM,KAAjC;MACA,CAFD,MAEO;QACN,KAAKD,IAAL,CAAW,QAAX,EAAqBL,MAAM,CAACM,KAA5B;MACA,CAVsD,CAYvD;MACA;;;MACA,KAAKrD,SAAL,CAAekD,OAAf;MAEA,KAAK/C,MAAL,CAAYmD,KAAZ;IACA;;IAED,KAAK/C,0CAAL,GAAkD,KAAlD;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCyC,yCAAyC,GAAG;IAC3C,OAAO,CAAC,KAAK7C,MAAL,CAAYoD,OAAb,IAAwB,KAAKhD,0CAApC;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;;;EACCiD,eAAe,GAAG;IACjB,KAAM,MAAMtB,IAAZ,IAAoB,KAAKjC,KAAzB,EAAiC;MAChC,IAAKiC,IAAI,KAAK,KAAKL,SAAnB,EAA+B;QAC9B,OAAOK,IAAP;MACA;IACD;;IAED,OAAO,KAAKL,SAAZ;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;;;EACC4B,gBAAgB,GAAG;IAClB,MAAMC,WAAW,GAAG,KAAKF,eAAL,EAApB;;IACA,MAAM1D,KAAK,GAAG,KAAKA,KAAnB;IACA,MAAM6D,MAAM,GAAG7D,KAAK,CAAC6D,MAArB,CAHkB,CAKlB;;IACA,MAAMC,QAAQ,GAAG9D,KAAK,CAAC+D,sBAAN,CAA8BH,WAA9B,EAA2C,CAAE,CAAF,CAA3C,CAAjB;IACA,MAAMI,YAAY,GAAGH,MAAM,CAACI,wBAAP,CAAiCH,QAAjC,CAArB,CAPkB,CASlB;;IACA,OAAOE,YAAY,IAAIhE,KAAK,CAACkE,WAAN,CAAmBJ,QAAnB,CAAvB;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCK,uBAAuB,CAAE1C,KAAF,EAAU;IAChC,OAAO2C,wBAAwB,CAAE3C,KAAK,CAAC4C,KAAR,CAAxB,IAA2CD,wBAAwB,CAAE3C,KAAK,CAAC6C,GAAR,CAA1E;EACA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACCnB,eAAe,CAAEF,MAAF,EAAW;IACzB,IAAIsB,QAAQ,GAAG,KAAf;;IAEA,GAAG;MACF,KAAM,MAAMC,QAAZ,IAAwB,KAAKjE,WAA7B,EAA2C;QAC1C;QACA;QACA;QACA;QACA;QACA;QACA,KAAKL,SAAL,CAAekD,OAAf;QAEAmB,QAAQ,GAAGC,QAAQ,CAAEvB,MAAF,CAAnB;;QAEA,IAAKsB,QAAL,EAAgB;UACf;QACA;MACD;IACD,CAhBD,QAgBUA,QAhBV;EAiBA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEC;EACA;EACA;EACA;;;AAza6B;AA4a9B9E,GAAG,CAAEK,QAAF,EAAYP,YAAZ,CAAH,C,CAEA;AACA;;AACA,SAAS6E,wBAAT,CAAmCK,aAAnC,EAAmD;EAClD,MAAMC,QAAQ,GAAGD,aAAa,CAACC,QAA/B;;EAEA,IAAKA,QAAL,EAAgB;IACf,MAAMC,IAAI,GAAGD,QAAQ,CAACC,IAAtB;IACA,MAAMC,MAAM,GAAGH,aAAa,CAACG,MAAd,GAAuBF,QAAQ,CAACG,WAA/C;IAEA,OAAO,CAACnF,qBAAqB,CAAEiF,IAAF,EAAQC,MAAR,CAAtB,IAA0C,CAACjF,sBAAsB,CAAEgF,IAAF,EAAQC,MAAR,CAAxE;EACA;;EAED,OAAO,IAAP;AACA"},"metadata":{},"sourceType":"module"}