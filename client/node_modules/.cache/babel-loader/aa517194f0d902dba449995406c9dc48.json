{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/datacontroller\n */\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Mapper from '../conversion/mapper';\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertAttributesAndChildren, insertText } from '../conversion/downcasthelpers';\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\nimport ModelRange from '../model/range';\nimport { autoParagraphEmptyRoots } from '../model/utils/autoparagraphing';\nimport HtmlDataProcessor from '../dataprocessor/htmldataprocessor';\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using the given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nexport default class DataController {\n  /**\n   * Creates a data controller instance.\n   *\n   * @param {module:engine/model/model~Model} model Data model.\n   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n   */\n  constructor(model, stylesProcessor) {\n    /**\n     * Data model.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * Mapper used for the conversion. It has no permanent bindings, because these are created while getting data and\n     * ae cleared directly after the data are converted. However, the mapper is defined as a class property, because\n     * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n     *\n     * @readonly\n     * @member {module:engine/conversion/mapper~Mapper}\n     */\n\n    this.mapper = new Mapper();\n    /**\n     * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n     *\n     * @readonly\n     * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n     */\n\n    this.downcastDispatcher = new DowncastDispatcher({\n      mapper: this.mapper,\n      schema: model.schema\n    });\n    this.downcastDispatcher.on('insert:$text', insertText(), {\n      priority: 'lowest'\n    });\n    this.downcastDispatcher.on('insert', insertAttributesAndChildren(), {\n      priority: 'lowest'\n    });\n    /**\n     * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n     *\n     * @readonly\n     * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n     */\n\n    this.upcastDispatcher = new UpcastDispatcher({\n      schema: model.schema\n    });\n    /**\n     * The view document used by the data controller.\n     *\n     * @readonly\n     * @member {module:engine/view/document~Document}\n     */\n\n    this.viewDocument = new ViewDocument(stylesProcessor);\n    /**\n     * Styles processor used during the conversion.\n     *\n     * @readonly\n     * @member {module:engine/view/stylesmap~StylesProcessor}\n     */\n\n    this.stylesProcessor = stylesProcessor;\n    /**\n     * Data processor used specifically for HTML conversion.\n     *\n     * @readonly\n     * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #htmlProcessor\n     */\n\n    this.htmlProcessor = new HtmlDataProcessor(this.viewDocument);\n    /**\n     * Data processor used during the conversion.\n     * Same instance as {@link #htmlProcessor} by default. Can be replaced at run time to handle different format, e.g. XML or Markdown.\n     *\n     * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor\n     */\n\n    this.processor = this.htmlProcessor;\n    /**\n     * The view downcast writer just for data conversion purposes, i.e. to modify\n     * the {@link #viewDocument}.\n     *\n     * @private\n     * @readonly\n     * @member {module:engine/view/downcastwriter~DowncastWriter}\n     */\n\n    this._viewWriter = new ViewDowncastWriter(this.viewDocument); // Define default converters for text and elements.\n    //\n    // Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n    // converted to nothing. We therefore add `convertToModelFragment` as a last converter so it converts children of that\n    // element to the document fragment so `<b>foo</b>` will still be converted to `foo` even if there is no converter for `<b>`.\n\n    this.upcastDispatcher.on('text', convertText(), {\n      priority: 'lowest'\n    });\n    this.upcastDispatcher.on('element', convertToModelFragment(), {\n      priority: 'lowest'\n    });\n    this.upcastDispatcher.on('documentFragment', convertToModelFragment(), {\n      priority: 'lowest'\n    });\n    this.decorate('init');\n    this.decorate('set');\n    this.decorate('get'); // Fire the `ready` event when the initialization has completed. Such low-level listener offers the possibility\n    // to plug into the initialization pipeline without interrupting the initialization flow.\n\n    this.on('init', () => {\n      this.fire('ready');\n    }, {\n      priority: 'lowest'\n    }); // Fix empty roots after DataController is 'ready' (note that the init method could be decorated and stopped).\n    // We need to handle this event because initial data could be empty and the post-fixer would not get triggered.\n\n    this.on('ready', () => {\n      this.model.enqueueChange({\n        isUndoable: false\n      }, autoParagraphEmptyRoots);\n    }, {\n      priority: 'lowest'\n    });\n  }\n  /**\n   * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n   * formatted by the {@link #processor data processor}.\n   *\n   * @fires get\n   * @param {Object} [options] Additional configuration for the retrieved data. `DataController` provides two optional\n   * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.\n   * @param {String} [options.rootName='main'] Root name.\n   * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n   * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n   * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).\n   * @returns {String} Output data.\n   */\n\n\n  get() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      rootName = 'main',\n      trim = 'empty'\n    } = options;\n\n    if (!this._checkIfRootsExists([rootName])) {\n      /**\n       * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n       * is called with a non-existent root name. For example, if there is an editor instance with only `main` root,\n       * calling {@link #get} like:\n       *\n       *\t\tdata.get( { rootName: 'root2' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-get-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-get-non-existent-root', this);\n    }\n\n    const root = this.model.document.getRoot(rootName);\n\n    if (trim === 'empty' && !this.model.hasContent(root, {\n      ignoreWhitespaces: true\n    })) {\n      return '';\n    }\n\n    return this.stringify(root, options);\n  }\n  /**\n   * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n   * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n   * The element whose content will be stringified.\n   * @param {Object} [options] Additional configuration passed to the conversion process.\n   * @returns {String} Output data.\n   */\n\n\n  stringify(modelElementOrFragment) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Model -> view.\n    const viewDocumentFragment = this.toView(modelElementOrFragment, options); // View -> data.\n\n    return this.processor.toData(viewDocumentFragment);\n  }\n  /**\n   * Returns the content of the given {@link module:engine/model/element~Element model element} or\n   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n   * converters attached to {@link #downcastDispatcher} into a\n   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n   * Element or document fragment whose content will be converted.\n   * @param {Object} [options={}] Additional configuration that will be available through the\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.\n   * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n   */\n\n\n  toView(modelElementOrFragment) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const viewDocument = this.viewDocument;\n    const viewWriter = this._viewWriter; // Clear bindings so the call to this method returns correct results.\n\n    this.mapper.clearBindings(); // First, convert elements.\n\n    const modelRange = ModelRange._createIn(modelElementOrFragment);\n\n    const viewDocumentFragment = new ViewDocumentFragment(viewDocument);\n    this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment); // Prepare list of markers.\n    // For document fragment, simply take the markers assigned to this document fragment.\n    // For model root, all markers in that root will be taken.\n    // For model element, we need to check which markers are intersecting with this element and relatively modify the markers' ranges.\n    // Collapsed markers at element boundary, although considered as not intersecting with the element, will also be returned.\n\n    const markers = modelElementOrFragment.is('documentFragment') ? modelElementOrFragment.markers : _getMarkersRelativeToElement(modelElementOrFragment);\n    this.downcastDispatcher.convert(modelRange, markers, viewWriter, options);\n    return viewDocumentFragment;\n  }\n  /**\n   * Sets the initial input data parsed by the {@link #processor data processor} and\n   * converted by the {@link #upcastDispatcher view-to-model converters}.\n   * Initial data can be only set to a document whose {@link module:engine/model/document~Document#version} is equal 0.\n   *\n   * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n   * used by e.g. collaborative editing plugin that syncs remote data on init.\n   *\n   * When data is passed as a string, it is initialized on the default `main` root:\n   *\n   *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.\n   *\n   * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:\n   *\n   *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.\n   *\n   * @fires init\n   * @param {String|Object.<String,String>} data Input data as a string or an object containing the `rootName` - `data`\n   * pairs to initialize data on multiple roots at once.\n   * @returns {Promise} Promise that is resolved after the data is set on the editor.\n   */\n\n\n  init(data) {\n    if (this.model.document.version) {\n      /**\n       * Cannot set initial data to a non-empty {@link module:engine/model/document~Document}.\n       * Initial data should be set once, during the {@link module:core/editor/editor~Editor} initialization,\n       * when the {@link module:engine/model/document~Document#version} is equal 0.\n       *\n       * @error datacontroller-init-document-not-empty\n       */\n      throw new CKEditorError('datacontroller-init-document-not-empty', this);\n    }\n\n    let initialData = {};\n\n    if (typeof data === 'string') {\n      initialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n    } else {\n      initialData = data;\n    }\n\n    if (!this._checkIfRootsExists(Object.keys(initialData))) {\n      /**\n       * Cannot init data on a non-existent root. This error is thrown when {@link #init DataController#init() method}\n       * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n       * calling {@link #init} like:\n       *\n       * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-init-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-init-non-existent-root', this);\n    }\n\n    this.model.enqueueChange({\n      isUndoable: false\n    }, writer => {\n      for (const rootName of Object.keys(initialData)) {\n        const modelRoot = this.model.document.getRoot(rootName);\n        writer.insert(this.parse(initialData[rootName], modelRoot), modelRoot, 0);\n      }\n    });\n    return Promise.resolve();\n  }\n  /**\n   * Sets the input data parsed by the {@link #processor data processor} and\n   * converted by the {@link #upcastDispatcher view-to-model converters}.\n   * This method can be used any time to replace existing editor data with the new one without clearing the\n   * {@link module:engine/model/document~Document#history document history}.\n   *\n   * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n   * the {@link #parse} method.\n   *\n   * When data is passed as a string it is set on the default `main` root:\n   *\n   *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.\n   *\n   * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:\n   *\n   *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.\n   *\n   * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.\n   *\n   *\t\tdataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );\n   *\n   * @fires set\n   * @param {String|Object.<String,String>} data Input data as a string or an object containing the `rootName` - `data`\n   * pairs to set data on multiple roots at once.\n   * @param {Object} [options={}] Options for setting data.\n   * @param {Object} [options.batchType] The batch type that will be used to create a batch for the changes applied by this method.\n   * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be\n   * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,\n   * the undo stack will be preserved instead and not cleared when new data is applied.\n   */\n\n\n  set(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let newData = {};\n\n    if (typeof data === 'string') {\n      newData.main = data; // The default root is 'main'. To set data on a different root, an object should be passed.\n    } else {\n      newData = data;\n    }\n\n    if (!this._checkIfRootsExists(Object.keys(newData))) {\n      /**\n       * Cannot set data on a non-existent root. This error is thrown when the {@link #set DataController#set() method}\n       * is called with non-existent root name. For example, if there is an editor instance with only the default `main` root,\n       * calling {@link #set} like:\n       *\n       * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-set-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-set-non-existent-root', this);\n    }\n\n    this.model.enqueueChange(options.batchType || {}, writer => {\n      writer.setSelection(null);\n      writer.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());\n\n      for (const rootName of Object.keys(newData)) {\n        // Save to model.\n        const modelRoot = this.model.document.getRoot(rootName);\n        writer.remove(writer.createRangeIn(modelRoot));\n        writer.insert(this.parse(newData[rootName], modelRoot), modelRoot, 0);\n      }\n    });\n  }\n  /**\n   * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n   * attached to the {@link #upcastDispatcher}.\n   *\n   * @see #set\n   * @param {String} data Data to parse.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n   * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n   */\n\n\n  parse(data) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '$root';\n    // data -> view\n    const viewDocumentFragment = this.processor.toView(data); // view -> model\n\n    return this.toModel(viewDocumentFragment, context);\n  }\n  /**\n   * Returns the result of the given {@link module:engine/view/element~Element view element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n   * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n   *\n   * When marker elements were converted during the conversion process, it will be set as a document fragment's\n   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n   * The element or document fragment whose content will be converted.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n   * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n   */\n\n\n  toModel(viewElementOrFragment) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '$root';\n    return this.model.change(writer => {\n      return this.upcastDispatcher.convert(viewElementOrFragment, writer, context);\n    });\n  }\n  /**\n   * Adds the style processor normalization rules.\n   *\n   * You can implement your own rules as well as use one of the available processor rules:\n   *\n   * * background: {@link module:engine/view/styles/background~addBackgroundRules}\n   * * border: {@link module:engine/view/styles/border~addBorderRules}\n   * * margin: {@link module:engine/view/styles/margin~addMarginRules}\n   * * padding: {@link module:engine/view/styles/padding~addPaddingRules}\n   *\n   * @param {Function} callback\n   */\n\n\n  addStyleProcessorRules(callback) {\n    callback(this.stylesProcessor);\n  }\n  /**\n   * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}\n   * and a {@link #processor processor} for view elements whose content should be treated as raw data\n   * and not processed during the conversion from DOM to view elements.\n   *\n   * The raw data can be later accessed by the {@link module:engine/view/element~Element#getCustomProperty view element custom property}\n   * `\"$rawContent\"`.\n   *\n   * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching all view elements whose content should\n   * be treated as a raw data.\n   */\n\n\n  registerRawContentMatcher(pattern) {\n    // No need to register the pattern if both the `htmlProcessor` and `processor` are the same instances.\n    if (this.processor && this.processor !== this.htmlProcessor) {\n      this.processor.registerRawContentMatcher(pattern);\n    }\n\n    this.htmlProcessor.registerRawContentMatcher(pattern);\n  }\n  /**\n   * Removes all event listeners set by the DataController.\n   */\n\n\n  destroy() {\n    this.stopListening();\n  }\n  /**\n   * Checks whether all provided root names are actually existing editor roots.\n   *\n   * @private\n   * @param {Array.<String>} rootNames Root names to check.\n   * @returns {Boolean} Whether all provided root names are existing editor roots.\n   */\n\n\n  _checkIfRootsExists(rootNames) {\n    for (const rootName of rootNames) {\n      if (!this.model.document.getRootNames().includes(rootName)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Event fired once the data initialization has finished.\n   *\n   * @event ready\n   */\n\n  /**\n   * An event fired after the {@link #init `init()` method} was run. It can be {@link #listenTo listened to} in order to adjust or modify\n   * the initialization flow. However, if the `init` event is stopped or prevented, the {@link #event:ready `ready` event}\n   * should be fired manually.\n   *\n   * The `init` event is fired by the decorated {@link #init} method.\n   * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n   *\n   * @event init\n   */\n\n  /**\n   * An event fired after {@link #set set() method} has been run.\n   *\n   * The `set` event is fired by the decorated {@link #set} method.\n   * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n   *\n   * @event set\n   */\n\n  /**\n   * Event fired after the {@link #get get() method} has been run.\n   *\n   * The `get` event is fired by the decorated {@link #get} method.\n   * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n   *\n   * @event get\n   */\n\n\n}\nmix(DataController, ObservableMixin); // Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it. If the marker is collapsed\n// at element boundary, it is considered as contained inside the element and marker range is returned. Otherwise, if the marker is\n// intersecting with the element, the intersection is returned.\n\nfunction _getMarkersRelativeToElement(element) {\n  const result = [];\n  const doc = element.root.document;\n\n  if (!doc) {\n    return new Map();\n  }\n\n  const elementRange = ModelRange._createIn(element);\n\n  for (const marker of doc.model.markers) {\n    const markerRange = marker.getRange();\n    const isMarkerCollapsed = markerRange.isCollapsed;\n    const isMarkerAtElementBoundary = markerRange.start.isEqual(elementRange.start) || markerRange.end.isEqual(elementRange.end);\n\n    if (isMarkerCollapsed && isMarkerAtElementBoundary) {\n      result.push([marker.name, markerRange]);\n    } else {\n      const updatedMarkerRange = elementRange.getIntersection(markerRange);\n\n      if (updatedMarkerRange) {\n        result.push([marker.name, updatedMarkerRange]);\n      }\n    }\n  } // Sort the markers in a stable fashion to ensure that the order in which they are\n  // added to the model's marker collection does not affect how they are\n  // downcast. One particular use case that we are targeting here, is one where\n  // two markers are adjacent but not overlapping, such as an insertion/deletion\n  // suggestion pair representing the replacement of a range of text. In this\n  // case, putting the markers in DOM order causes the first marker's end to be\n  // serialized right after the second marker's start, while putting the markers\n  // in reverse DOM order causes it to be right before the second marker's\n  // start. So, we sort these in a way that ensures non-intersecting ranges are in\n  // reverse DOM order, and intersecting ranges are in something approximating\n  // reverse DOM order (since reverse DOM order doesn't have a precise meaning\n  // when working with intersecting ranges).\n\n\n  result.sort((_ref, _ref2) => {\n    let [n1, r1] = _ref;\n    let [n2, r2] = _ref2;\n\n    if (r1.end.compareWith(r2.start) !== 'after') {\n      // m1.end <= m2.start -- m1 is entirely <= m2\n      return 1;\n    } else if (r1.start.compareWith(r2.end) !== 'before') {\n      // m1.start >= m2.end -- m1 is entirely >= m2\n      return -1;\n    } else {\n      // they overlap, so use their start positions as the primary sort key and\n      // end positions as the secondary sort key\n      switch (r1.start.compareWith(r2.start)) {\n        case 'before':\n          return 1;\n\n        case 'after':\n          return -1;\n\n        default:\n          switch (r1.end.compareWith(r2.end)) {\n            case 'before':\n              return 1;\n\n            case 'after':\n              return -1;\n\n            default:\n              return n2.localeCompare(n1);\n          }\n\n      }\n    }\n  });\n  return new Map(result);\n}","map":{"version":3,"names":["mix","ObservableMixin","CKEditorError","Mapper","DowncastDispatcher","insertAttributesAndChildren","insertText","UpcastDispatcher","convertText","convertToModelFragment","ViewDocumentFragment","ViewDocument","ViewDowncastWriter","ModelRange","autoParagraphEmptyRoots","HtmlDataProcessor","DataController","constructor","model","stylesProcessor","mapper","downcastDispatcher","schema","on","priority","upcastDispatcher","viewDocument","htmlProcessor","processor","_viewWriter","decorate","fire","enqueueChange","isUndoable","get","options","rootName","trim","_checkIfRootsExists","root","document","getRoot","hasContent","ignoreWhitespaces","stringify","modelElementOrFragment","viewDocumentFragment","toView","toData","viewWriter","clearBindings","modelRange","_createIn","bindElements","markers","is","_getMarkersRelativeToElement","convert","init","data","version","initialData","main","Object","keys","writer","modelRoot","insert","parse","Promise","resolve","set","newData","batchType","setSelection","removeSelectionAttribute","selection","getAttributeKeys","remove","createRangeIn","context","toModel","viewElementOrFragment","change","addStyleProcessorRules","callback","registerRawContentMatcher","pattern","destroy","stopListening","rootNames","getRootNames","includes","element","result","doc","Map","elementRange","marker","markerRange","getRange","isMarkerCollapsed","isCollapsed","isMarkerAtElementBoundary","start","isEqual","end","push","name","updatedMarkerRange","getIntersection","sort","n1","r1","n2","r2","compareWith","localeCompare"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/datacontroller\n */\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport Mapper from '../conversion/mapper';\n\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertAttributesAndChildren, insertText } from '../conversion/downcasthelpers';\n\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\n\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\n\nimport ModelRange from '../model/range';\nimport { autoParagraphEmptyRoots } from '../model/utils/autoparagraphing';\nimport HtmlDataProcessor from '../dataprocessor/htmldataprocessor';\n\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using the given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class DataController {\n\t/**\n\t * Creates a data controller instance.\n\t *\n\t * @param {module:engine/model/model~Model} model Data model.\n\t * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n\t */\n\tconstructor( model, stylesProcessor ) {\n\t\t/**\n\t\t * Data model.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Mapper used for the conversion. It has no permanent bindings, because these are created while getting data and\n\t\t * ae cleared directly after the data are converted. However, the mapper is defined as a class property, because\n\t\t * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/mapper~Mapper}\n\t\t */\n\t\tthis.mapper = new Mapper();\n\n\t\t/**\n\t\t * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n\t\t */\n\t\tthis.downcastDispatcher = new DowncastDispatcher( {\n\t\t\tmapper: this.mapper,\n\t\t\tschema: model.schema\n\t\t} );\n\t\tthis.downcastDispatcher.on( 'insert:$text', insertText(), { priority: 'lowest' } );\n\t\tthis.downcastDispatcher.on( 'insert', insertAttributesAndChildren(), { priority: 'lowest' } );\n\n\t\t/**\n\t\t * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n\t\t */\n\t\tthis.upcastDispatcher = new UpcastDispatcher( {\n\t\t\tschema: model.schema\n\t\t} );\n\n\t\t/**\n\t\t * The view document used by the data controller.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/document~Document}\n\t\t */\n\t\tthis.viewDocument = new ViewDocument( stylesProcessor );\n\n\t\t/**\n\t\t * Styles processor used during the conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/stylesmap~StylesProcessor}\n\t\t */\n\t\tthis.stylesProcessor = stylesProcessor;\n\n\t\t/**\n\t\t * Data processor used specifically for HTML conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #htmlProcessor\n\t\t */\n\t\tthis.htmlProcessor = new HtmlDataProcessor( this.viewDocument );\n\n\t\t/**\n\t\t * Data processor used during the conversion.\n\t\t * Same instance as {@link #htmlProcessor} by default. Can be replaced at run time to handle different format, e.g. XML or Markdown.\n\t\t *\n\t\t * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor\n\t\t */\n\t\tthis.processor = this.htmlProcessor;\n\n\t\t/**\n\t\t * The view downcast writer just for data conversion purposes, i.e. to modify\n\t\t * the {@link #viewDocument}.\n\t\t *\n\t\t * @private\n\t\t * @readonly\n\t\t * @member {module:engine/view/downcastwriter~DowncastWriter}\n\t\t */\n\t\tthis._viewWriter = new ViewDowncastWriter( this.viewDocument );\n\n\t\t// Define default converters for text and elements.\n\t\t//\n\t\t// Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n\t\t// converted to nothing. We therefore add `convertToModelFragment` as a last converter so it converts children of that\n\t\t// element to the document fragment so `<b>foo</b>` will still be converted to `foo` even if there is no converter for `<b>`.\n\t\tthis.upcastDispatcher.on( 'text', convertText(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'element', convertToModelFragment(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'documentFragment', convertToModelFragment(), { priority: 'lowest' } );\n\n\t\tthis.decorate( 'init' );\n\t\tthis.decorate( 'set' );\n\t\tthis.decorate( 'get' );\n\n\t\t// Fire the `ready` event when the initialization has completed. Such low-level listener offers the possibility\n\t\t// to plug into the initialization pipeline without interrupting the initialization flow.\n\t\tthis.on( 'init', () => {\n\t\t\tthis.fire( 'ready' );\n\t\t}, { priority: 'lowest' } );\n\n\t\t// Fix empty roots after DataController is 'ready' (note that the init method could be decorated and stopped).\n\t\t// We need to handle this event because initial data could be empty and the post-fixer would not get triggered.\n\t\tthis.on( 'ready', () => {\n\t\t\tthis.model.enqueueChange( { isUndoable: false }, autoParagraphEmptyRoots );\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n\t * formatted by the {@link #processor data processor}.\n\t *\n\t * @fires get\n\t * @param {Object} [options] Additional configuration for the retrieved data. `DataController` provides two optional\n\t * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.\n\t * @param {String} [options.rootName='main'] Root name.\n\t * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n\t * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n\t * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).\n\t * @returns {String} Output data.\n\t */\n\tget( options = {} ) {\n\t\tconst { rootName = 'main', trim = 'empty' } = options;\n\n\t\tif ( !this._checkIfRootsExists( [ rootName ] ) ) {\n\t\t\t/**\n\t\t\t * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n\t\t\t * is called with a non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #get} like:\n\t\t\t *\n\t\t\t *\t\tdata.get( { rootName: 'root2' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-get-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-get-non-existent-root', this );\n\t\t}\n\n\t\tconst root = this.model.document.getRoot( rootName );\n\n\t\tif ( trim === 'empty' && !this.model.hasContent( root, { ignoreWhitespaces: true } ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.stringify( root, options );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n\t * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * The element whose content will be stringified.\n\t * @param {Object} [options] Additional configuration passed to the conversion process.\n\t * @returns {String} Output data.\n\t */\n\tstringify( modelElementOrFragment, options = {} ) {\n\t\t// Model -> view.\n\t\tconst viewDocumentFragment = this.toView( modelElementOrFragment, options );\n\n\t\t// View -> data.\n\t\treturn this.processor.toData( viewDocumentFragment );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n\t * converters attached to {@link #downcastDispatcher} into a\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @param {Object} [options={}] Additional configuration that will be available through the\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n\t */\n\ttoView( modelElementOrFragment, options = {} ) {\n\t\tconst viewDocument = this.viewDocument;\n\t\tconst viewWriter = this._viewWriter;\n\n\t\t// Clear bindings so the call to this method returns correct results.\n\t\tthis.mapper.clearBindings();\n\n\t\t// First, convert elements.\n\t\tconst modelRange = ModelRange._createIn( modelElementOrFragment );\n\t\tconst viewDocumentFragment = new ViewDocumentFragment( viewDocument );\n\n\t\tthis.mapper.bindElements( modelElementOrFragment, viewDocumentFragment );\n\n\t\t// Prepare list of markers.\n\t\t// For document fragment, simply take the markers assigned to this document fragment.\n\t\t// For model root, all markers in that root will be taken.\n\t\t// For model element, we need to check which markers are intersecting with this element and relatively modify the markers' ranges.\n\t\t// Collapsed markers at element boundary, although considered as not intersecting with the element, will also be returned.\n\t\tconst markers = modelElementOrFragment.is( 'documentFragment' ) ?\n\t\t\tmodelElementOrFragment.markers :\n\t\t\t_getMarkersRelativeToElement( modelElementOrFragment );\n\n\t\tthis.downcastDispatcher.convert( modelRange, markers, viewWriter, options );\n\n\t\treturn viewDocumentFragment;\n\t}\n\n\t/**\n\t * Sets the initial input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * Initial data can be only set to a document whose {@link module:engine/model/document~Document#version} is equal 0.\n\t *\n\t * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n\t * used by e.g. collaborative editing plugin that syncs remote data on init.\n\t *\n\t * When data is passed as a string, it is initialized on the default `main` root:\n\t *\n\t *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.\n\t *\n\t * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.\n\t *\n\t * @fires init\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing the `rootName` - `data`\n\t * pairs to initialize data on multiple roots at once.\n\t * @returns {Promise} Promise that is resolved after the data is set on the editor.\n\t */\n\tinit( data ) {\n\t\tif ( this.model.document.version ) {\n\t\t\t/**\n\t\t\t * Cannot set initial data to a non-empty {@link module:engine/model/document~Document}.\n\t\t\t * Initial data should be set once, during the {@link module:core/editor/editor~Editor} initialization,\n\t\t\t * when the {@link module:engine/model/document~Document#version} is equal 0.\n\t\t\t *\n\t\t\t * @error datacontroller-init-document-not-empty\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-document-not-empty', this );\n\t\t}\n\n\t\tlet initialData = {};\n\t\tif ( typeof data === 'string' ) {\n\t\t\tinitialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n\t\t} else {\n\t\t\tinitialData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( initialData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot init data on a non-existent root. This error is thrown when {@link #init DataController#init() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #init} like:\n\t\t\t *\n\t\t\t * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-init-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-non-existent-root', this );\n\t\t}\n\n\t\tthis.model.enqueueChange( { isUndoable: false }, writer => {\n\t\t\tfor ( const rootName of Object.keys( initialData ) ) {\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\t\t\t\twriter.insert( this.parse( initialData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Sets the input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * This method can be used any time to replace existing editor data with the new one without clearing the\n\t * {@link module:engine/model/document~Document#history document history}.\n\t *\n\t * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n\t * the {@link #parse} method.\n\t *\n\t * When data is passed as a string it is set on the default `main` root:\n\t *\n\t *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.\n\t *\n\t * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.\n\t *\n\t * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.\n\t *\n\t *\t\tdataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );\n\t *\n\t * @fires set\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing the `rootName` - `data`\n\t * pairs to set data on multiple roots at once.\n\t * @param {Object} [options={}] Options for setting data.\n\t * @param {Object} [options.batchType] The batch type that will be used to create a batch for the changes applied by this method.\n\t * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be\n\t * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,\n\t * the undo stack will be preserved instead and not cleared when new data is applied.\n\t */\n\tset( data, options = {} ) {\n\t\tlet newData = {};\n\n\t\tif ( typeof data === 'string' ) {\n\t\t\tnewData.main = data; // The default root is 'main'. To set data on a different root, an object should be passed.\n\t\t} else {\n\t\t\tnewData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( newData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot set data on a non-existent root. This error is thrown when the {@link #set DataController#set() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only the default `main` root,\n\t\t\t * calling {@link #set} like:\n\t\t\t *\n\t\t\t * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-set-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-set-non-existent-root', this );\n\t\t}\n\n\t\tthis.model.enqueueChange( options.batchType || {}, writer => {\n\t\t\twriter.setSelection( null );\n\t\t\twriter.removeSelectionAttribute( this.model.document.selection.getAttributeKeys() );\n\n\t\t\tfor ( const rootName of Object.keys( newData ) ) {\n\t\t\t\t// Save to model.\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\n\t\t\t\twriter.remove( writer.createRangeIn( modelRoot ) );\n\t\t\t\twriter.insert( this.parse( newData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n\t * attached to the {@link #upcastDispatcher}.\n\t *\n\t * @see #set\n\t * @param {String} data Data to parse.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n\t */\n\tparse( data, context = '$root' ) {\n\t\t// data -> view\n\t\tconst viewDocumentFragment = this.processor.toView( data );\n\n\t\t// view -> model\n\t\treturn this.toModel( viewDocumentFragment, context );\n\t}\n\n\t/**\n\t * Returns the result of the given {@link module:engine/view/element~Element view element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n\t * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n\t *\n\t * When marker elements were converted during the conversion process, it will be set as a document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n\t * The element or document fragment whose content will be converted.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n\t */\n\ttoModel( viewElementOrFragment, context = '$root' ) {\n\t\treturn this.model.change( writer => {\n\t\t\treturn this.upcastDispatcher.convert( viewElementOrFragment, writer, context );\n\t\t} );\n\t}\n\n\t/**\n\t * Adds the style processor normalization rules.\n\t *\n\t * You can implement your own rules as well as use one of the available processor rules:\n\t *\n\t * * background: {@link module:engine/view/styles/background~addBackgroundRules}\n\t * * border: {@link module:engine/view/styles/border~addBorderRules}\n\t * * margin: {@link module:engine/view/styles/margin~addMarginRules}\n\t * * padding: {@link module:engine/view/styles/padding~addPaddingRules}\n\t *\n\t * @param {Function} callback\n\t */\n\taddStyleProcessorRules( callback ) {\n\t\tcallback( this.stylesProcessor );\n\t}\n\n\t/**\n\t * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}\n\t * and a {@link #processor processor} for view elements whose content should be treated as raw data\n\t * and not processed during the conversion from DOM to view elements.\n\t *\n\t * The raw data can be later accessed by the {@link module:engine/view/element~Element#getCustomProperty view element custom property}\n\t * `\"$rawContent\"`.\n\t *\n\t * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching all view elements whose content should\n\t * be treated as a raw data.\n\t */\n\tregisterRawContentMatcher( pattern ) {\n\t\t// No need to register the pattern if both the `htmlProcessor` and `processor` are the same instances.\n\t\tif ( this.processor && this.processor !== this.htmlProcessor ) {\n\t\t\tthis.processor.registerRawContentMatcher( pattern );\n\t\t}\n\n\t\tthis.htmlProcessor.registerRawContentMatcher( pattern );\n\t}\n\n\t/**\n\t * Removes all event listeners set by the DataController.\n\t */\n\tdestroy() {\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Checks whether all provided root names are actually existing editor roots.\n\t *\n\t * @private\n\t * @param {Array.<String>} rootNames Root names to check.\n\t * @returns {Boolean} Whether all provided root names are existing editor roots.\n\t */\n\t_checkIfRootsExists( rootNames ) {\n\t\tfor ( const rootName of rootNames ) {\n\t\t\tif ( !this.model.document.getRootNames().includes( rootName ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Event fired once the data initialization has finished.\n\t *\n\t * @event ready\n\t */\n\n\t/**\n\t * An event fired after the {@link #init `init()` method} was run. It can be {@link #listenTo listened to} in order to adjust or modify\n\t * the initialization flow. However, if the `init` event is stopped or prevented, the {@link #event:ready `ready` event}\n\t * should be fired manually.\n\t *\n\t * The `init` event is fired by the decorated {@link #init} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n\t *\n\t * @event init\n\t */\n\n\t/**\n\t * An event fired after {@link #set set() method} has been run.\n\t *\n\t * The `set` event is fired by the decorated {@link #set} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n\t *\n\t * @event set\n\t */\n\n\t/**\n\t * Event fired after the {@link #get get() method} has been run.\n\t *\n\t * The `get` event is fired by the decorated {@link #get} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n\t *\n\t * @event get\n\t */\n}\n\nmix( DataController, ObservableMixin );\n\n// Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it. If the marker is collapsed\n// at element boundary, it is considered as contained inside the element and marker range is returned. Otherwise, if the marker is\n// intersecting with the element, the intersection is returned.\nfunction _getMarkersRelativeToElement( element ) {\n\tconst result = [];\n\tconst doc = element.root.document;\n\n\tif ( !doc ) {\n\t\treturn new Map();\n\t}\n\n\tconst elementRange = ModelRange._createIn( element );\n\n\tfor ( const marker of doc.model.markers ) {\n\t\tconst markerRange = marker.getRange();\n\n\t\tconst isMarkerCollapsed = markerRange.isCollapsed;\n\t\tconst isMarkerAtElementBoundary = markerRange.start.isEqual( elementRange.start ) || markerRange.end.isEqual( elementRange.end );\n\n\t\tif ( isMarkerCollapsed && isMarkerAtElementBoundary ) {\n\t\t\tresult.push( [ marker.name, markerRange ] );\n\t\t} else {\n\t\t\tconst updatedMarkerRange = elementRange.getIntersection( markerRange );\n\n\t\t\tif ( updatedMarkerRange ) {\n\t\t\t\tresult.push( [ marker.name, updatedMarkerRange ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Sort the markers in a stable fashion to ensure that the order in which they are\n\t// added to the model's marker collection does not affect how they are\n\t// downcast. One particular use case that we are targeting here, is one where\n\t// two markers are adjacent but not overlapping, such as an insertion/deletion\n\t// suggestion pair representing the replacement of a range of text. In this\n\t// case, putting the markers in DOM order causes the first marker's end to be\n\t// serialized right after the second marker's start, while putting the markers\n\t// in reverse DOM order causes it to be right before the second marker's\n\t// start. So, we sort these in a way that ensures non-intersecting ranges are in\n\t// reverse DOM order, and intersecting ranges are in something approximating\n\t// reverse DOM order (since reverse DOM order doesn't have a precise meaning\n\t// when working with intersecting ranges).\n\tresult.sort( ( [ n1, r1 ], [ n2, r2 ] ) => {\n\t\tif ( r1.end.compareWith( r2.start ) !== 'after' ) {\n\t\t\t// m1.end <= m2.start -- m1 is entirely <= m2\n\t\t\treturn 1;\n\t\t} else if ( r1.start.compareWith( r2.end ) !== 'before' ) {\n\t\t\t// m1.start >= m2.end -- m1 is entirely >= m2\n\t\t\treturn -1;\n\t\t} else {\n\t\t\t// they overlap, so use their start positions as the primary sort key and\n\t\t\t// end positions as the secondary sort key\n\t\t\tswitch ( r1.start.compareWith( r2.start ) ) {\n\t\t\t\tcase 'before':\n\t\t\t\t\treturn 1;\n\t\t\t\tcase 'after':\n\t\t\t\t\treturn -1;\n\t\t\t\tdefault:\n\t\t\t\t\tswitch ( r1.end.compareWith( r2.end ) ) {\n\t\t\t\t\t\tcase 'before':\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\tcase 'after':\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn n2.localeCompare( n1 );\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\treturn new Map( result );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}