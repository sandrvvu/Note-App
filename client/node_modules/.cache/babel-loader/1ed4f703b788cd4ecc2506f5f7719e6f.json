{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/config\n */\nimport { isPlainObject, isElement, cloneDeepWith } from 'lodash-es';\n/**\n * Handles a configuration dictionary.\n */\n\nexport default class Config {\n  /**\n   * Creates an instance of the {@link ~Config} class.\n   *\n   * @param {Object} [configurations] The initial configurations to be set. Usually, provided by the user.\n   * @param {Object} [defaultConfigurations] The default configurations. Usually, provided by the system.\n   */\n  constructor(configurations, defaultConfigurations) {\n    /**\n     * Store for the whole configuration.\n     *\n     * @private\n     * @member {Object}\n     */\n    this._config = {}; // Set default configuration.\n\n    if (defaultConfigurations) {\n      // Clone the configuration to make sure that the properties will not be shared\n      // between editors and make the watchdog feature work correctly.\n      this.define(cloneConfig(defaultConfigurations));\n    } // Set initial configuration.\n\n\n    if (configurations) {\n      this._setObjectToTarget(this._config, configurations);\n    }\n  }\n  /**\n   * Set configuration values.\n   *\n   * It accepts both a name/value pair or an object, which properties and values will be used to set\n   * configurations.\n   *\n   * It also accepts setting a \"deep configuration\" by using dots in the name. For example, `'resize.width'` sets\n   * the value for the `width` configuration in the `resize` subset.\n   *\n   *\t\tconfig.set( 'width', 500 );\n   *\t\tconfig.set( 'toolbar.collapsed', true );\n   *\n   *\t\t// Equivalent to:\n   *\t\tconfig.set( {\n   *\t\t\twidth: 500\n   *\t\t\ttoolbar: {\n   *\t\t\t\tcollapsed: true\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Passing an object as the value will amend the configuration, not replace it.\n   *\n   *\t\tconfig.set( 'toolbar', {\n   *\t\t\tcollapsed: true,\n   *\t\t} );\n   *\n   *\t\tconfig.set( 'toolbar', {\n   *\t\t\tcolor: 'red',\n   *\t\t} );\n   *\n   *\t\tconfig.get( 'toolbar.collapsed' ); // true\n   *\t\tconfig.get( 'toolbar.color' ); // 'red'\n   *\n   * @param {String|Object} name The configuration name or an object from which take properties as\n   * configuration entries. Configuration names are case-sensitive.\n   * @param {*} value The configuration value. Used if a name is passed.\n   */\n\n\n  set(name, value) {\n    this._setToTarget(this._config, name, value);\n  }\n  /**\n   * Does exactly the same as {@link #set} with one exception â€“ passed configuration extends\n   * existing one, but does not overwrite already defined values.\n   *\n   * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be\n   * rarely used for other needs.\n   *\n   * @param {String|Object} name The configuration name or an object from which take properties as\n   * configuration entries. Configuration names are case-sensitive.\n   * @param {*} value The configuration value. Used if a name is passed.\n   */\n\n\n  define(name, value) {\n    const isDefine = true;\n\n    this._setToTarget(this._config, name, value, isDefine);\n  }\n  /**\n   * Gets the value for a configuration entry.\n   *\n   *\t\tconfig.get( 'name' );\n   *\n   * Deep configurations can be retrieved by separating each part with a dot.\n   *\n   *\t\tconfig.get( 'toolbar.collapsed' );\n   *\n   * @param {String} name The configuration name. Configuration names are case-sensitive.\n   * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n   */\n\n\n  get(name) {\n    return this._getFromSource(this._config, name);\n  }\n  /**\n   * Iterates over all top level configuration names.\n   *\n   * @returns {Iterable.<String>}\n   */\n\n\n  *names() {\n    for (const name of Object.keys(this._config)) {\n      yield name;\n    }\n  }\n  /**\n   * Saves passed configuration to the specified target (nested object).\n   *\n   * @private\n   * @param {Object} target Nested config object.\n   * @param {String|Object} name The configuration name or an object from which take properties as\n   * configuration entries. Configuration names are case-sensitive.\n   * @param {*} value The configuration value. Used if a name is passed.\n   * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.\n   */\n\n\n  _setToTarget(target, name, value) {\n    let isDefine = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    // In case of an object, iterate through it and call `_setToTarget` again for each property.\n    if (isPlainObject(name)) {\n      this._setObjectToTarget(target, name, isDefine);\n\n      return;\n    } // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n\n\n    const parts = name.split('.'); // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\n    name = parts.pop(); // Iterate over parts to check if currently stored configuration has proper structure.\n\n    for (const part of parts) {\n      // If there is no object for specified part then create one.\n      if (!isPlainObject(target[part])) {\n        target[part] = {};\n      } // Nested object becomes a target.\n\n\n      target = target[part];\n    } // In case of value is an object.\n\n\n    if (isPlainObject(value)) {\n      // We take care of proper config structure.\n      if (!isPlainObject(target[name])) {\n        target[name] = {};\n      }\n\n      target = target[name]; // And iterate through this object calling `_setToTarget` again for each property.\n\n      this._setObjectToTarget(target, value, isDefine);\n\n      return;\n    } // Do nothing if we are defining configuration for non empty name.\n\n\n    if (isDefine && typeof target[name] != 'undefined') {\n      return;\n    }\n\n    target[name] = value;\n  }\n  /**\n   * Get specified configuration from specified source (nested object).\n   *\n   * @private\n   * @param {Object} source level of nested object.\n   * @param {String} name The configuration name. Configuration names are case-sensitive.\n   * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n   */\n\n\n  _getFromSource(source, name) {\n    // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n    const parts = name.split('.'); // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\n    name = parts.pop(); // Iterate over parts to check if currently stored configuration has proper structure.\n\n    for (const part of parts) {\n      if (!isPlainObject(source[part])) {\n        source = null;\n        break;\n      } // Nested object becomes a source.\n\n\n      source = source[part];\n    } // Always returns undefined for non existing configuration.\n\n\n    return source ? cloneConfig(source[name]) : undefined;\n  }\n  /**\n   * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.\n   *\n   * @private\n   * @param {Object} target Nested config object.\n   * @param {Object} configuration Configuration data set\n   * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.\n   */\n\n\n  _setObjectToTarget(target, configuration, isDefine) {\n    Object.keys(configuration).forEach(key => {\n      this._setToTarget(target, key, configuration[key], isDefine);\n    });\n  }\n\n} // Clones configuration object or value.\n// @param {*} source Source configuration\n// @returns {*} Cloned configuration value.\n\nfunction cloneConfig(source) {\n  return cloneDeepWith(source, leaveDOMReferences);\n} // A customized function for cloneDeepWith.\n// It will leave references to DOM Elements instead of cloning them.\n//\n// @param {*} value\n// @returns {Element|undefined}\n\n\nfunction leaveDOMReferences(value) {\n  return isElement(value) ? value : undefined;\n}","map":{"version":3,"names":["isPlainObject","isElement","cloneDeepWith","Config","constructor","configurations","defaultConfigurations","_config","define","cloneConfig","_setObjectToTarget","set","name","value","_setToTarget","isDefine","get","_getFromSource","names","Object","keys","target","parts","split","pop","part","source","undefined","configuration","forEach","key","leaveDOMReferences"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-utils/src/config.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/config\n */\n\nimport { isPlainObject, isElement, cloneDeepWith } from 'lodash-es';\n\n/**\n * Handles a configuration dictionary.\n */\nexport default class Config {\n\t/**\n\t * Creates an instance of the {@link ~Config} class.\n\t *\n\t * @param {Object} [configurations] The initial configurations to be set. Usually, provided by the user.\n\t * @param {Object} [defaultConfigurations] The default configurations. Usually, provided by the system.\n\t */\n\tconstructor( configurations, defaultConfigurations ) {\n\t\t/**\n\t\t * Store for the whole configuration.\n\t\t *\n\t\t * @private\n\t\t * @member {Object}\n\t\t */\n\t\tthis._config = {};\n\n\t\t// Set default configuration.\n\t\tif ( defaultConfigurations ) {\n\t\t\t// Clone the configuration to make sure that the properties will not be shared\n\t\t\t// between editors and make the watchdog feature work correctly.\n\t\t\tthis.define( cloneConfig( defaultConfigurations ) );\n\t\t}\n\n\t\t// Set initial configuration.\n\t\tif ( configurations ) {\n\t\t\tthis._setObjectToTarget( this._config, configurations );\n\t\t}\n\t}\n\n\t/**\n\t * Set configuration values.\n\t *\n\t * It accepts both a name/value pair or an object, which properties and values will be used to set\n\t * configurations.\n\t *\n\t * It also accepts setting a \"deep configuration\" by using dots in the name. For example, `'resize.width'` sets\n\t * the value for the `width` configuration in the `resize` subset.\n\t *\n\t *\t\tconfig.set( 'width', 500 );\n\t *\t\tconfig.set( 'toolbar.collapsed', true );\n\t *\n\t *\t\t// Equivalent to:\n\t *\t\tconfig.set( {\n\t *\t\t\twidth: 500\n\t *\t\t\ttoolbar: {\n\t *\t\t\t\tcollapsed: true\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Passing an object as the value will amend the configuration, not replace it.\n\t *\n\t *\t\tconfig.set( 'toolbar', {\n\t *\t\t\tcollapsed: true,\n\t *\t\t} );\n\t *\n\t *\t\tconfig.set( 'toolbar', {\n\t *\t\t\tcolor: 'red',\n\t *\t\t} );\n\t *\n\t *\t\tconfig.get( 'toolbar.collapsed' ); // true\n\t *\t\tconfig.get( 'toolbar.color' ); // 'red'\n\t *\n\t * @param {String|Object} name The configuration name or an object from which take properties as\n\t * configuration entries. Configuration names are case-sensitive.\n\t * @param {*} value The configuration value. Used if a name is passed.\n\t */\n\tset( name, value ) {\n\t\tthis._setToTarget( this._config, name, value );\n\t}\n\n\t/**\n\t * Does exactly the same as {@link #set} with one exception â€“ passed configuration extends\n\t * existing one, but does not overwrite already defined values.\n\t *\n\t * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be\n\t * rarely used for other needs.\n\t *\n\t * @param {String|Object} name The configuration name or an object from which take properties as\n\t * configuration entries. Configuration names are case-sensitive.\n\t * @param {*} value The configuration value. Used if a name is passed.\n\t */\n\tdefine( name, value ) {\n\t\tconst isDefine = true;\n\n\t\tthis._setToTarget( this._config, name, value, isDefine );\n\t}\n\n\t/**\n\t * Gets the value for a configuration entry.\n\t *\n\t *\t\tconfig.get( 'name' );\n\t *\n\t * Deep configurations can be retrieved by separating each part with a dot.\n\t *\n\t *\t\tconfig.get( 'toolbar.collapsed' );\n\t *\n\t * @param {String} name The configuration name. Configuration names are case-sensitive.\n\t * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n\t */\n\tget( name ) {\n\t\treturn this._getFromSource( this._config, name );\n\t}\n\n\t/**\n\t * Iterates over all top level configuration names.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\t* names() {\n\t\tfor ( const name of Object.keys( this._config ) ) {\n\t\t\tyield name;\n\t\t}\n\t}\n\n\t/**\n\t * Saves passed configuration to the specified target (nested object).\n\t *\n\t * @private\n\t * @param {Object} target Nested config object.\n\t * @param {String|Object} name The configuration name or an object from which take properties as\n\t * configuration entries. Configuration names are case-sensitive.\n\t * @param {*} value The configuration value. Used if a name is passed.\n\t * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.\n\t */\n\t_setToTarget( target, name, value, isDefine = false ) {\n\t\t// In case of an object, iterate through it and call `_setToTarget` again for each property.\n\t\tif ( isPlainObject( name ) ) {\n\t\t\tthis._setObjectToTarget( target, name, isDefine );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n\t\tconst parts = name.split( '.' );\n\n\t\t// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\t\tname = parts.pop();\n\n\t\t// Iterate over parts to check if currently stored configuration has proper structure.\n\t\tfor ( const part of parts ) {\n\t\t\t// If there is no object for specified part then create one.\n\t\t\tif ( !isPlainObject( target[ part ] ) ) {\n\t\t\t\ttarget[ part ] = {};\n\t\t\t}\n\n\t\t\t// Nested object becomes a target.\n\t\t\ttarget = target[ part ];\n\t\t}\n\n\t\t// In case of value is an object.\n\t\tif ( isPlainObject( value ) ) {\n\t\t\t// We take care of proper config structure.\n\t\t\tif ( !isPlainObject( target[ name ] ) ) {\n\t\t\t\ttarget[ name ] = {};\n\t\t\t}\n\n\t\t\ttarget = target[ name ];\n\n\t\t\t// And iterate through this object calling `_setToTarget` again for each property.\n\t\t\tthis._setObjectToTarget( target, value, isDefine );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Do nothing if we are defining configuration for non empty name.\n\t\tif ( isDefine && typeof target[ name ] != 'undefined' ) {\n\t\t\treturn;\n\t\t}\n\n\t\ttarget[ name ] = value;\n\t}\n\n\t/**\n\t * Get specified configuration from specified source (nested object).\n\t *\n\t * @private\n\t * @param {Object} source level of nested object.\n\t * @param {String} name The configuration name. Configuration names are case-sensitive.\n\t * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n\t */\n\t_getFromSource( source, name ) {\n\t\t// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n\t\tconst parts = name.split( '.' );\n\n\t\t// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\t\tname = parts.pop();\n\n\t\t// Iterate over parts to check if currently stored configuration has proper structure.\n\t\tfor ( const part of parts ) {\n\t\t\tif ( !isPlainObject( source[ part ] ) ) {\n\t\t\t\tsource = null;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Nested object becomes a source.\n\t\t\tsource = source[ part ];\n\t\t}\n\n\t\t// Always returns undefined for non existing configuration.\n\t\treturn source ? cloneConfig( source[ name ] ) : undefined;\n\t}\n\n\t/**\n\t * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.\n\t *\n\t * @private\n\t * @param {Object} target Nested config object.\n\t * @param {Object} configuration Configuration data set\n\t * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.\n\t */\n\t_setObjectToTarget( target, configuration, isDefine ) {\n\t\tObject.keys( configuration ).forEach( key => {\n\t\t\tthis._setToTarget( target, key, configuration[ key ], isDefine );\n\t\t} );\n\t}\n}\n\n// Clones configuration object or value.\n// @param {*} source Source configuration\n// @returns {*} Cloned configuration value.\nfunction cloneConfig( source ) {\n\treturn cloneDeepWith( source, leaveDOMReferences );\n}\n\n// A customized function for cloneDeepWith.\n// It will leave references to DOM Elements instead of cloning them.\n//\n// @param {*} value\n// @returns {Element|undefined}\nfunction leaveDOMReferences( value ) {\n\treturn isElement( value ) ? value : undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}