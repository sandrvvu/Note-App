{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/downcastdispatcher\n */\nimport Consumable from './modelconsumable';\nimport Range from '../model/range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * The downcast dispatcher is a central point of downcasting (conversion from the model to the view), which is a process of reacting\n * to changes in the model and firing a set of events. The callbacks listening to these events are called converters. The\n * converters' role is to convert the model changes to changes in view (for example, adding view nodes or\n * changing attributes on view elements).\n *\n * During the conversion process, downcast dispatcher fires events basing on the state of the model and prepares\n * data for these events. It is important to understand that the events are connected with the changes done on the model,\n * for example: \"a node has been inserted\" or \"an attribute has changed\". This is in contrary to upcasting (a view-to-model conversion)\n * where you convert the view state (view nodes) to a model tree.\n *\n * The events are prepared basing on a diff created by the {@link module:engine/model/differ~Differ Differ}, which buffers them\n * and then passes to the downcast dispatcher as a diff between the old model state and the new model state.\n *\n * Note that because the changes are converted, there is a need to have a mapping between the model structure and the view structure.\n * To map positions and elements during the downcast (a model-to-view conversion), use {@link module:engine/conversion/mapper~Mapper}.\n *\n * Downcast dispatcher fires the following events for model tree changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} &ndash;\n * If a range of nodes was inserted to the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove `remove`} &ndash;\n * If a range of nodes was removed from the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} &ndash;\n * If an attribute was added, changed or removed from a model node.\n *\n * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`}\n * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`},\n * the downcast dispatcher generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.\n * These are used to have control over which changes have already been consumed. It is useful when some converters\n * overwrite others or convert multiple changes (for example, it converts an insertion of an element and also converts that\n * element's attributes during the insertion).\n *\n * Additionally, downcast dispatcher fires events for {@link module:engine/model/markercollection~Marker marker} changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker `addMarker`} &ndash; If a marker was added.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker `removeMarker`} &ndash; If a marker was\n * removed.\n *\n * Note that changing a marker is done through removing the marker from the old range and adding it to the new range,\n * so both of these events are fired.\n *\n * Finally, a downcast dispatcher also handles firing events for the {@link module:engine/model/selection model selection}\n * conversion:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection `selection`}\n * &ndash; Converts the selection from the model to the view.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`}\n * &ndash; Fired for every selection attribute.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker `addMarker`}\n * &ndash; Fired for every marker that contains a selection.\n *\n * Unlike the model tree and the markers, the events for selection are not fired for changes but for a selection state.\n *\n * When providing custom listeners for a downcast dispatcher, remember to check whether a given change has not been\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.\n *\n * When providing custom listeners for a downcast dispatcher, keep in mind that you **should not** stop the event. If you stop it,\n * then the default converter at the `lowest` priority will not trigger the conversion of this node's attributes and child nodes.\n *\n * When providing custom listeners for a downcast dispatcher, remember to use the provided\n * {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} to apply changes to the view document.\n *\n * You can read more about conversion in the following guide:\n *\n * * {@glink framework/guides/deep-dive/conversion/downcast Downcast conversion}\n *\n * An example of a custom converter for the downcast dispatcher:\n *\n *\t\t// You will convert inserting a \"paragraph\" model element into the model.\n *\t\tdowncastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {\n *\t\t\t// Remember to check whether the change has not been consumed yet and consume it.\n *\t\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Translate the position in the model to a position in the view.\n *\t\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Create a <p> element that will be inserted into the view at the `viewPosition`.\n *\t\t\tconst viewElement = conversionApi.writer.createContainerElement( 'p' );\n *\n *\t\t\t// Bind the newly created view element to the model element so positions will map accordingly in the future.\n *\t\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n *\n *\t\t\t// Add the newly created view element to the view.\n *\t\t\tconversionApi.writer.insert( viewPosition, viewElement );\n *\t\t} );\n */\n\nexport default class DowncastDispatcher {\n  /**\n   * Creates a downcast dispatcher instance.\n   *\n   * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi\n   * @param {Object} conversionApi Additional properties for an interface that will be passed to events fired\n   * by the downcast dispatcher.\n   */\n  constructor(conversionApi) {\n    /**\n     * A template for an interface passed by the dispatcher to the event callbacks.\n     *\n     * @protected\n     * @member {module:engine/conversion/downcastdispatcher~DowncastConversionApi}\n     */\n    this._conversionApi = {\n      dispatcher: this,\n      ...conversionApi\n    };\n    /**\n     * A map of already fired events for a given `ModelConsumable`.\n     *\n     * @private\n     * @member {WeakMap.<module:engine/conversion/downcastdispatcher~DowncastConversionApi,Map>}\n     */\n\n    this._firedEventsMap = new WeakMap();\n  }\n  /**\n   * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}\n   * and fires conversion events based on it.\n   *\n   * @fires insert\n   * @fires remove\n   * @fires attribute\n   * @fires addMarker\n  \t * @fires removeMarker\n   * @fires reduceChanges\n   * @param {module:engine/model/differ~Differ} differ The differ object with buffered changes.\n   * @param {module:engine/model/markercollection~MarkerCollection} markers Markers related to the model fragment to convert.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n   */\n\n\n  convertChanges(differ, markers, writer) {\n    const conversionApi = this._createConversionApi(writer, differ.getRefreshedItems()); // Before the view is updated, remove markers which have changed.\n\n\n    for (const change of differ.getMarkersToRemove()) {\n      this._convertMarkerRemove(change.name, change.range, conversionApi);\n    } // Let features modify the change list (for example to allow reconversion).\n\n\n    const changes = this._reduceChanges(differ.getChanges()); // Convert changes that happened on model tree.\n\n\n    for (const entry of changes) {\n      if (entry.type === 'insert') {\n        this._convertInsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);\n      } else if (entry.type === 'reinsert') {\n        this._convertReinsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);\n      } else if (entry.type === 'remove') {\n        this._convertRemove(entry.position, entry.length, entry.name, conversionApi);\n      } else {\n        // Defaults to 'attribute' change.\n        this._convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, conversionApi);\n      }\n    }\n\n    for (const markerName of conversionApi.mapper.flushUnboundMarkerNames()) {\n      const markerRange = markers.get(markerName).getRange();\n\n      this._convertMarkerRemove(markerName, markerRange, conversionApi);\n\n      this._convertMarkerAdd(markerName, markerRange, conversionApi);\n    } // After the view is updated, convert markers which have changed.\n\n\n    for (const change of differ.getMarkersToAdd()) {\n      this._convertMarkerAdd(change.name, change.range, conversionApi);\n    } // Remove mappings for all removed view elements.\n\n\n    conversionApi.mapper.flushDeferredBindings(); // Verify if all insert consumables were consumed.\n\n    conversionApi.consumable.verifyAllConsumed('insert');\n  }\n  /**\n   * Starts a conversion of a model range and the provided markers.\n   *\n   * @fires insert\n   * @fires attribute\n   * @fires addMarker\n   * @param {module:engine/model/range~Range} range The inserted range.\n   * @param {Map<String,module:engine/model/range~Range>} markers The map of markers that should be down-casted.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n   * @param {Object} [options] Optional options object passed to `convertionApi.options`.\n   */\n\n\n  convert(range, markers, writer) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    const conversionApi = this._createConversionApi(writer, undefined, options);\n\n    this._convertInsert(range, conversionApi);\n\n    for (const [name, range] of markers) {\n      this._convertMarkerAdd(name, range, conversionApi);\n    } // Verify if all insert consumables were consumed.\n\n\n    conversionApi.consumable.verifyAllConsumed('insert');\n  }\n  /**\n   * Starts the model selection conversion.\n   *\n   * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.\n   *\n   * @fires selection\n   * @fires addMarker\n   * @fires attribute\n   * @param {module:engine/model/selection~Selection} selection The selection to convert.\n   * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with the converted model.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n   */\n\n\n  convertSelection(selection, markers, writer) {\n    const markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));\n\n    const conversionApi = this._createConversionApi(writer);\n\n    this._addConsumablesForSelection(conversionApi.consumable, selection, markersAtSelection);\n\n    this.fire('selection', {\n      selection\n    }, conversionApi);\n\n    if (!selection.isCollapsed) {\n      return;\n    }\n\n    for (const marker of markersAtSelection) {\n      const markerRange = marker.getRange();\n\n      if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, conversionApi.mapper)) {\n        continue;\n      }\n\n      const data = {\n        item: selection,\n        markerName: marker.name,\n        markerRange\n      };\n\n      if (conversionApi.consumable.test(selection, 'addMarker:' + marker.name)) {\n        this.fire('addMarker:' + marker.name, data, conversionApi);\n      }\n    }\n\n    for (const key of selection.getAttributeKeys()) {\n      const data = {\n        item: selection,\n        range: selection.getFirstRange(),\n        attributeKey: key,\n        attributeOldValue: null,\n        attributeNewValue: selection.getAttribute(key)\n      }; // Do not fire event if the attribute has been consumed.\n\n      if (conversionApi.consumable.test(selection, 'attribute:' + data.attributeKey)) {\n        this.fire('attribute:' + data.attributeKey + ':$text', data, conversionApi);\n      }\n    }\n  }\n  /**\n   * Fires insertion conversion of a range of nodes.\n   *\n   * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,\n   * {@link #event:attribute `attribute` event is fired}.\n   *\n   * @protected\n   * @fires insert\n   * @fires attribute\n   * @param {module:engine/model/range~Range} range The inserted range.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   * @param {Object} [options]\n   * @param {Boolean} [options.doNotAddConsumables=false] Whether the ModelConsumable should not get populated\n   * for items in the provided range.\n   */\n\n\n  _convertInsert(range, conversionApi) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!options.doNotAddConsumables) {\n      // Collect a list of things that can be consumed, consisting of nodes and their attributes.\n      this._addConsumablesForInsert(conversionApi.consumable, Array.from(range));\n    } // Fire a separate insert event for each node and text fragment contained in the range.\n\n\n    for (const data of Array.from(range.getWalker({\n      shallow: true\n    })).map(walkerValueToEventData)) {\n      this._testAndFire('insert', data, conversionApi);\n    }\n  }\n  /**\n   * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} position Position from which node was removed.\n   * @param {Number} length Offset size of removed node.\n   * @param {String} name Name of removed node.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n\n\n  _convertRemove(position, length, name, conversionApi) {\n    this.fire('remove:' + name, {\n      position,\n      length\n    }, conversionApi);\n  }\n  /**\n   * Starts a conversion of an attribute change on a given `range`.\n   *\n   * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.\n   *\n   * @protected\n   * @fires attribute\n   * @param {module:engine/model/range~Range} range Changed range.\n   * @param {String} key Key of the attribute that has changed.\n   * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.\n   * @param {*} newValue New attribute value or `null` if the attribute has been removed.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n\n\n  _convertAttribute(range, key, oldValue, newValue, conversionApi) {\n    // Create a list with attributes to consume.\n    this._addConsumablesForRange(conversionApi.consumable, range, `attribute:${key}`); // Create a separate attribute event for each node in the range.\n\n\n    for (const value of range) {\n      const data = {\n        item: value.item,\n        range: Range._createFromPositionAndShift(value.previousPosition, value.length),\n        attributeKey: key,\n        attributeOldValue: oldValue,\n        attributeNewValue: newValue\n      };\n\n      this._testAndFire(`attribute:${key}`, data, conversionApi);\n    }\n  }\n  /**\n   * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)\n   * of a range of elements (only elements on the range depth, without children).\n   *\n   * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.\n   * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.\n   *\n   * @protected\n   * @fires insert\n   * @fires attribute\n   * @param {module:engine/model/range~Range} range The range to reinsert.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n\n\n  _convertReinsert(range, conversionApi) {\n    // Convert the elements - without converting children.\n    const walkerValues = Array.from(range.getWalker({\n      shallow: true\n    })); // Collect a list of things that can be consumed, consisting of nodes and their attributes.\n\n    this._addConsumablesForInsert(conversionApi.consumable, walkerValues); // Fire a separate insert event for each node and text fragment contained shallowly in the range.\n\n\n    for (const data of walkerValues.map(walkerValueToEventData)) {\n      this._testAndFire('insert', { ...data,\n        reconversion: true\n      }, conversionApi);\n    }\n  }\n  /**\n   * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item\n   * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.\n   *\n   * @protected\n   * @fires addMarker\n   * @param {String} markerName Marker name.\n   * @param {module:engine/model/range~Range} markerRange The marker range.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n\n\n  _convertMarkerAdd(markerName, markerRange, conversionApi) {\n    // Do not convert if range is in graveyard.\n    if (markerRange.root.rootName == '$graveyard') {\n      return;\n    } // In markers' case, event name == consumable name.\n\n\n    const eventName = 'addMarker:' + markerName; //\n    // First, fire an event for the whole marker.\n    //\n\n    conversionApi.consumable.add(markerRange, eventName);\n    this.fire(eventName, {\n      markerName,\n      markerRange\n    }, conversionApi); //\n    // Do not fire events for each item inside the range if the range got consumed.\n    // Also consume the whole marker consumable if it wasn't consumed.\n    //\n\n    if (!conversionApi.consumable.consume(markerRange, eventName)) {\n      return;\n    } //\n    // Then, fire an event for each item inside the marker range.\n    //\n\n\n    this._addConsumablesForRange(conversionApi.consumable, markerRange, eventName);\n\n    for (const item of markerRange.getItems()) {\n      // Do not fire event for already consumed items.\n      if (!conversionApi.consumable.test(item, eventName)) {\n        continue;\n      }\n\n      const data = {\n        item,\n        range: Range._createOn(item),\n        markerName,\n        markerRange\n      };\n      this.fire(eventName, data, conversionApi);\n    }\n  }\n  /**\n   * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.\n   *\n   * @protected\n   * @fires removeMarker\n   * @param {String} markerName Marker name.\n   * @param {module:engine/model/range~Range} markerRange The marker range.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n\n\n  _convertMarkerRemove(markerName, markerRange, conversionApi) {\n    // Do not convert if range is in graveyard.\n    if (markerRange.root.rootName == '$graveyard') {\n      return;\n    }\n\n    this.fire('removeMarker:' + markerName, {\n      markerName,\n      markerRange\n    }, conversionApi);\n  }\n  /**\n   * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.\n   *\n   * Features can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with `reinsert` entries to trigger\n   * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n   * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.\n   *\n   * @private\n   * @fires reduceChanges\n   * @param {Iterable.<module:engine/model/differ~DiffItem>} changes\n   * @returns {Iterable.<module:engine/model/differ~DiffItem>}\n   */\n\n\n  _reduceChanges(changes) {\n    const data = {\n      changes\n    };\n    this.fire('reduceChanges', data);\n    return data.changes;\n  }\n  /**\n   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,\n   * assuming that the range has just been inserted to the model.\n   *\n   * @private\n   * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n   * @param {Iterable.<module:engine/model/treewalker~TreeWalkerValue>} walkerValues The walker values for the inserted range.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n   */\n\n\n  _addConsumablesForInsert(consumable, walkerValues) {\n    for (const value of walkerValues) {\n      const item = value.item; // Add consumable if it wasn't there yet.\n\n      if (consumable.test(item, 'insert') === null) {\n        consumable.add(item, 'insert');\n\n        for (const key of item.getAttributeKeys()) {\n          consumable.add(item, 'attribute:' + key);\n        }\n      }\n    }\n\n    return consumable;\n  }\n  /**\n   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.\n   *\n   * @private\n   * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n   * @param {module:engine/model/range~Range} range The affected range.\n   * @param {String} type Consumable type.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n   */\n\n\n  _addConsumablesForRange(consumable, range, type) {\n    for (const item of range.getItems()) {\n      consumable.add(item, type);\n    }\n\n    return consumable;\n  }\n  /**\n   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.\n   *\n   * @private\n   * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n   * @param {module:engine/model/selection~Selection} selection The selection to create the consumable from.\n   * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers that contain the selection.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n   */\n\n\n  _addConsumablesForSelection(consumable, selection, markers) {\n    consumable.add(selection, 'selection');\n\n    for (const marker of markers) {\n      consumable.add(selection, 'addMarker:' + marker.name);\n    }\n\n    for (const key of selection.getAttributeKeys()) {\n      consumable.add(selection, 'attribute:' + key);\n    }\n\n    return consumable;\n  }\n  /**\n   * Tests whether given event wasn't already fired and if so, fires it.\n   *\n   * @private\n   * @fires insert\n   * @fires attribute\n   * @param {String} type Event type.\n   * @param {Object} data Event data.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n\n\n  _testAndFire(type, data, conversionApi) {\n    const eventName = getEventName(type, data);\n    const itemKey = data.item.is('$textProxy') ? conversionApi.consumable._getSymbolForTextProxy(data.item) : data.item;\n\n    const eventsFiredForConversion = this._firedEventsMap.get(conversionApi);\n\n    const eventsFiredForItem = eventsFiredForConversion.get(itemKey);\n\n    if (!eventsFiredForItem) {\n      eventsFiredForConversion.set(itemKey, new Set([eventName]));\n    } else if (!eventsFiredForItem.has(eventName)) {\n      eventsFiredForItem.add(eventName);\n    } else {\n      return;\n    }\n\n    this.fire(eventName, data, conversionApi);\n  }\n  /**\n   * Fires not already fired events for setting attributes on just inserted item.\n   *\n   * @private\n   * @param {module:engine/model/item~Item} item The model item to convert attributes for.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n   */\n\n\n  _testAndFireAddAttributes(item, conversionApi) {\n    const data = {\n      item,\n      range: Range._createOn(item)\n    };\n\n    for (const key of data.item.getAttributeKeys()) {\n      data.attributeKey = key;\n      data.attributeOldValue = null;\n      data.attributeNewValue = data.item.getAttribute(key);\n\n      this._testAndFire(`attribute:${key}`, data, conversionApi);\n    }\n  }\n  /**\n   * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given\n   * {@link module:engine/view/downcastwriter~DowncastWriter `DowncastWriter`} and options object.\n   *\n   * @private\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n   * @param {Set.<module:engine/model/element~Element>} [refreshedItems] A set of model elements that should not reuse their\n   * previous view representations.\n   * @param {Object} [options] Optional options passed to `convertionApi.options`.\n   * @return {module:engine/conversion/downcastdispatcher~DowncastConversionApi} The conversion API object.\n   */\n\n\n  _createConversionApi(writer) {\n    let refreshedItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const conversionApi = { ...this._conversionApi,\n      consumable: new Consumable(),\n      writer,\n      options,\n      convertItem: item => this._convertInsert(Range._createOn(item), conversionApi),\n      convertChildren: element => this._convertInsert(Range._createIn(element), conversionApi, {\n        doNotAddConsumables: true\n      }),\n      convertAttributes: item => this._testAndFireAddAttributes(item, conversionApi),\n      canReuseView: viewElement => !refreshedItems.has(conversionApi.mapper.toModelElement(viewElement))\n    };\n\n    this._firedEventsMap.set(conversionApi, new Map());\n\n    return conversionApi;\n  }\n  /**\n   * Fired to enable reducing (transforming) changes buffered in the {@link module:engine/model/differ~Differ `Differ`} before\n   * {@link #convertChanges `convertChanges()`} will fire any conversion events.\n   *\n   * For instance, a feature can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with a `reinsert` entry\n   * to trigger reconversion of an element when e.g. its attribute has changes.\n   * The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n   * `DowncastHelpers.elementToStructure()`} helper is using this event to trigger reconversion of an element when the element,\n   * its attributes or direct children changed.\n   *\n   * @param {Object} data\n   * @param {Iterable.<module:engine/model/differ~DiffItem>} data.changes A buffered changes to get reduced.\n   * @event reduceChanges\n   */\n\n  /**\n   * Fired for inserted nodes.\n   *\n   * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `insert:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been inserted,\n   * or {@link module:engine/model/element~Element#name name} of inserted element.\n   *\n   * This way, the listeners can either listen to a general `insert` event or specific event (for example `insert:paragraph`).\n   *\n   * @event insert\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/item~Item} data.item The inserted item.\n   * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in the `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired for removed nodes.\n   *\n   * `remove` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `remove:name`. `name` is either `'$text'`, when a {@link module:engine/model/text~Text a text node} has been removed,\n   * or the {@link module:engine/model/element~Element#name name} of removed element.\n   *\n   * This way, listeners can either listen to a general `remove` event or specific event (for example `remove:paragraph`).\n   *\n   * @event remove\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/position~Position} data.position Position from which the node has been removed.\n   * @param {Number} data.length Offset size of the removed node.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired in the following cases:\n   *\n   * * when an attribute has been added, changed, or removed from a node,\n   * * when a node with an attribute is inserted,\n   * * when a collapsed model selection attribute is converted.\n   *\n   * `attribute` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `attribute:attributeKey:name`. `attributeKey` is the key of added/changed/removed attribute.\n   * `name` is either `'$text'` if change was on {@link module:engine/model/text~Text a text node},\n   * or the {@link module:engine/model/element~Element#name name} of element which attribute has changed.\n   *\n   * This way listeners can either listen to a general `attribute:bold` event or specific event (for example `attribute:src:imageBlock`).\n   *\n   * @event attribute\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n   * or converted selection.\n   * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n   * @param {String} data.attributeKey Attribute key.\n   * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n   * @param {*} data.attributeNewValue New attribute value.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired for {@link module:engine/model/selection~Selection selection} changes.\n   *\n   * @event selection\n   * @param {module:engine/model/selection~Selection} selection Selection that is converted.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired when a new marker is added to the model. Also fired when a collapsed model selection that is inside a marker is converted.\n   *\n   * `addMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `addMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n   * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `addMarker:foo` or `addMarker:foo:abc` and\n   * `addMarker:foo:bar` events.\n   *\n   * If the marker range is not collapsed:\n   *\n   * * the event is fired for each item in the marker range one by one,\n   * * `conversionApi.consumable` includes each item of the marker range and the consumable value is same as the event name.\n   *\n   * If the marker range is collapsed:\n   *\n   * * there is only one event,\n   * * `conversionApi.consumable` includes marker range with the event name.\n   *\n   * If the selection inside a marker is converted:\n   *\n   * * there is only one event,\n   * * `conversionApi.consumable` includes the selection instance with the event name.\n   *\n   * @event addMarker\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/item~Item|module:engine/model/selection~Selection} data.item Item inside the new marker or\n   * the selection that is being converted.\n   * @param {module:engine/model/range~Range} [data.range] Range spanning over converted item. Available only in marker conversion, if\n   * the marker range was not collapsed.\n   * @param {module:engine/model/range~Range} data.markerRange Marker range.\n   * @param {String} data.markerName Marker name.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired when a marker is removed from the model.\n   *\n   * `removeMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `removeMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n   * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `removeMarker:foo` or `removeMarker:foo:abc` and\n   * `removeMarker:foo:bar` events.\n   *\n   * @event removeMarker\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/range~Range} data.markerRange Marker range.\n   * @param {String} data.markerName Marker name.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n\n}\nmix(DowncastDispatcher, EmitterMixin); // Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not\n// converted if they happen inside an element with custom conversion method.\n//\n// @param {module:engine/model/position~Position} modelPosition\n// @param {module:engine/model/markercollection~Marker} marker\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\n\nfunction shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {\n  const range = marker.getRange();\n  const ancestors = Array.from(modelPosition.getAncestors());\n  ancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.\n\n  ancestors.reverse();\n  const hasCustomHandling = ancestors.some(element => {\n    if (range.containsItem(element)) {\n      const viewElement = mapper.toViewElement(element);\n      return !!viewElement.getCustomProperty('addHighlight');\n    }\n  });\n  return !hasCustomHandling;\n}\n\nfunction getEventName(type, data) {\n  const name = data.item.name || '$text';\n  return `${type}:${name}`;\n}\n\nfunction walkerValueToEventData(value) {\n  const item = value.item;\n\n  const itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);\n\n  return {\n    item,\n    range: itemRange\n  };\n}\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher dispatcher}\n * fires its events.\n *\n * @interface module:engine/conversion/downcastdispatcher~DowncastConversionApi\n */\n\n/**\n * The {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} instance.\n *\n * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #dispatcher\n */\n\n/**\n * Stores the information about what parts of a processed model item are still waiting to be handled. After a piece of a model item was\n * converted, an appropriate consumable value should be {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/modelconsumable~ModelConsumable} #consumable\n */\n\n/**\n * The {@link module:engine/conversion/mapper~Mapper} instance.\n *\n * @member {module:engine/conversion/mapper~Mapper} #mapper\n */\n\n/**\n * The {@link module:engine/model/schema~Schema} instance set for the model that is downcast.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/view/downcastwriter~DowncastWriter} instance used to manipulate the data during conversion.\n *\n * @member {module:engine/view/downcastwriter~DowncastWriter} #writer\n */\n\n/**\n * Triggers conversion of a specified item.\n * This conversion is triggered within (as a separate process of) the parent conversion.\n *\n * @method #convertItem\n * @param {module:engine/model/item~Item} item The model item to trigger nested insert conversion on.\n */\n\n/**\n * Triggers conversion of children of a specified element.\n *\n * @method #convertChildren\n * @param {module:engine/model/element~Element} element The model element to trigger children insert conversion on.\n */\n\n/**\n * Triggers conversion of attributes of a specified item.\n *\n * @method #convertAttributes\n * @param {module:engine/model/item~Item} item The model item to trigger attribute conversion on.\n */\n\n/**\n * An object with an additional configuration which can be used during the conversion process. Available only for data downcast conversion.\n *\n * @member {Object} #options\n */","map":{"version":3,"names":["Consumable","Range","EmitterMixin","mix","DowncastDispatcher","constructor","conversionApi","_conversionApi","dispatcher","_firedEventsMap","WeakMap","convertChanges","differ","markers","writer","_createConversionApi","getRefreshedItems","change","getMarkersToRemove","_convertMarkerRemove","name","range","changes","_reduceChanges","getChanges","entry","type","_convertInsert","_createFromPositionAndShift","position","length","_convertReinsert","_convertRemove","_convertAttribute","attributeKey","attributeOldValue","attributeNewValue","markerName","mapper","flushUnboundMarkerNames","markerRange","get","getRange","_convertMarkerAdd","getMarkersToAdd","flushDeferredBindings","consumable","verifyAllConsumed","convert","options","undefined","convertSelection","selection","markersAtSelection","Array","from","getMarkersAtPosition","getFirstPosition","_addConsumablesForSelection","fire","isCollapsed","marker","shouldMarkerChangeBeConverted","data","item","test","key","getAttributeKeys","getFirstRange","getAttribute","doNotAddConsumables","_addConsumablesForInsert","getWalker","shallow","map","walkerValueToEventData","_testAndFire","oldValue","newValue","_addConsumablesForRange","value","previousPosition","walkerValues","reconversion","root","rootName","eventName","add","consume","getItems","_createOn","getEventName","itemKey","is","_getSymbolForTextProxy","eventsFiredForConversion","eventsFiredForItem","set","Set","has","_testAndFireAddAttributes","refreshedItems","convertItem","convertChildren","element","_createIn","convertAttributes","canReuseView","viewElement","toModelElement","Map","modelPosition","ancestors","getAncestors","shift","reverse","hasCustomHandling","some","containsItem","toViewElement","getCustomProperty","itemRange"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcastdispatcher.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/downcastdispatcher\n */\n\nimport Consumable from './modelconsumable';\nimport Range from '../model/range';\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * The downcast dispatcher is a central point of downcasting (conversion from the model to the view), which is a process of reacting\n * to changes in the model and firing a set of events. The callbacks listening to these events are called converters. The\n * converters' role is to convert the model changes to changes in view (for example, adding view nodes or\n * changing attributes on view elements).\n *\n * During the conversion process, downcast dispatcher fires events basing on the state of the model and prepares\n * data for these events. It is important to understand that the events are connected with the changes done on the model,\n * for example: \"a node has been inserted\" or \"an attribute has changed\". This is in contrary to upcasting (a view-to-model conversion)\n * where you convert the view state (view nodes) to a model tree.\n *\n * The events are prepared basing on a diff created by the {@link module:engine/model/differ~Differ Differ}, which buffers them\n * and then passes to the downcast dispatcher as a diff between the old model state and the new model state.\n *\n * Note that because the changes are converted, there is a need to have a mapping between the model structure and the view structure.\n * To map positions and elements during the downcast (a model-to-view conversion), use {@link module:engine/conversion/mapper~Mapper}.\n *\n * Downcast dispatcher fires the following events for model tree changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} &ndash;\n * If a range of nodes was inserted to the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove `remove`} &ndash;\n * If a range of nodes was removed from the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} &ndash;\n * If an attribute was added, changed or removed from a model node.\n *\n * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`}\n * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`},\n * the downcast dispatcher generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.\n * These are used to have control over which changes have already been consumed. It is useful when some converters\n * overwrite others or convert multiple changes (for example, it converts an insertion of an element and also converts that\n * element's attributes during the insertion).\n *\n * Additionally, downcast dispatcher fires events for {@link module:engine/model/markercollection~Marker marker} changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker `addMarker`} &ndash; If a marker was added.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker `removeMarker`} &ndash; If a marker was\n * removed.\n *\n * Note that changing a marker is done through removing the marker from the old range and adding it to the new range,\n * so both of these events are fired.\n *\n * Finally, a downcast dispatcher also handles firing events for the {@link module:engine/model/selection model selection}\n * conversion:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection `selection`}\n * &ndash; Converts the selection from the model to the view.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`}\n * &ndash; Fired for every selection attribute.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker `addMarker`}\n * &ndash; Fired for every marker that contains a selection.\n *\n * Unlike the model tree and the markers, the events for selection are not fired for changes but for a selection state.\n *\n * When providing custom listeners for a downcast dispatcher, remember to check whether a given change has not been\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.\n *\n * When providing custom listeners for a downcast dispatcher, keep in mind that you **should not** stop the event. If you stop it,\n * then the default converter at the `lowest` priority will not trigger the conversion of this node's attributes and child nodes.\n *\n * When providing custom listeners for a downcast dispatcher, remember to use the provided\n * {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} to apply changes to the view document.\n *\n * You can read more about conversion in the following guide:\n *\n * * {@glink framework/guides/deep-dive/conversion/downcast Downcast conversion}\n *\n * An example of a custom converter for the downcast dispatcher:\n *\n *\t\t// You will convert inserting a \"paragraph\" model element into the model.\n *\t\tdowncastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {\n *\t\t\t// Remember to check whether the change has not been consumed yet and consume it.\n *\t\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Translate the position in the model to a position in the view.\n *\t\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Create a <p> element that will be inserted into the view at the `viewPosition`.\n *\t\t\tconst viewElement = conversionApi.writer.createContainerElement( 'p' );\n *\n *\t\t\t// Bind the newly created view element to the model element so positions will map accordingly in the future.\n *\t\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n *\n *\t\t\t// Add the newly created view element to the view.\n *\t\t\tconversionApi.writer.insert( viewPosition, viewElement );\n *\t\t} );\n */\nexport default class DowncastDispatcher {\n\t/**\n\t * Creates a downcast dispatcher instance.\n\t *\n\t * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi\n\t * @param {Object} conversionApi Additional properties for an interface that will be passed to events fired\n\t * by the downcast dispatcher.\n\t */\n\tconstructor( conversionApi ) {\n\t\t/**\n\t\t * A template for an interface passed by the dispatcher to the event callbacks.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:engine/conversion/downcastdispatcher~DowncastConversionApi}\n\t\t */\n\t\tthis._conversionApi = { dispatcher: this, ...conversionApi };\n\n\t\t/**\n\t\t * A map of already fired events for a given `ModelConsumable`.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap.<module:engine/conversion/downcastdispatcher~DowncastConversionApi,Map>}\n\t\t */\n\t\tthis._firedEventsMap = new WeakMap();\n\t}\n\n\t/**\n\t * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}\n\t * and fires conversion events based on it.\n\t *\n\t * @fires insert\n\t * @fires remove\n\t * @fires attribute\n\t * @fires addMarker\n \t * @fires removeMarker\n\t * @fires reduceChanges\n\t * @param {module:engine/model/differ~Differ} differ The differ object with buffered changes.\n\t * @param {module:engine/model/markercollection~MarkerCollection} markers Markers related to the model fragment to convert.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n\t */\n\tconvertChanges( differ, markers, writer ) {\n\t\tconst conversionApi = this._createConversionApi( writer, differ.getRefreshedItems() );\n\n\t\t// Before the view is updated, remove markers which have changed.\n\t\tfor ( const change of differ.getMarkersToRemove() ) {\n\t\t\tthis._convertMarkerRemove( change.name, change.range, conversionApi );\n\t\t}\n\n\t\t// Let features modify the change list (for example to allow reconversion).\n\t\tconst changes = this._reduceChanges( differ.getChanges() );\n\n\t\t// Convert changes that happened on model tree.\n\t\tfor ( const entry of changes ) {\n\t\t\tif ( entry.type === 'insert' ) {\n\t\t\t\tthis._convertInsert( Range._createFromPositionAndShift( entry.position, entry.length ), conversionApi );\n\t\t\t} else if ( entry.type === 'reinsert' ) {\n\t\t\t\tthis._convertReinsert( Range._createFromPositionAndShift( entry.position, entry.length ), conversionApi );\n\t\t\t} else if ( entry.type === 'remove' ) {\n\t\t\t\tthis._convertRemove( entry.position, entry.length, entry.name, conversionApi );\n\t\t\t} else {\n\t\t\t\t// Defaults to 'attribute' change.\n\t\t\t\tthis._convertAttribute( entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, conversionApi );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const markerName of conversionApi.mapper.flushUnboundMarkerNames() ) {\n\t\t\tconst markerRange = markers.get( markerName ).getRange();\n\n\t\t\tthis._convertMarkerRemove( markerName, markerRange, conversionApi );\n\t\t\tthis._convertMarkerAdd( markerName, markerRange, conversionApi );\n\t\t}\n\n\t\t// After the view is updated, convert markers which have changed.\n\t\tfor ( const change of differ.getMarkersToAdd() ) {\n\t\t\tthis._convertMarkerAdd( change.name, change.range, conversionApi );\n\t\t}\n\n\t\t// Remove mappings for all removed view elements.\n\t\tconversionApi.mapper.flushDeferredBindings();\n\n\t\t// Verify if all insert consumables were consumed.\n\t\tconversionApi.consumable.verifyAllConsumed( 'insert' );\n\t}\n\n\t/**\n\t * Starts a conversion of a model range and the provided markers.\n\t *\n\t * @fires insert\n\t * @fires attribute\n\t * @fires addMarker\n\t * @param {module:engine/model/range~Range} range The inserted range.\n\t * @param {Map<String,module:engine/model/range~Range>} markers The map of markers that should be down-casted.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n\t * @param {Object} [options] Optional options object passed to `convertionApi.options`.\n\t */\n\tconvert( range, markers, writer, options = {} ) {\n\t\tconst conversionApi = this._createConversionApi( writer, undefined, options );\n\n\t\tthis._convertInsert( range, conversionApi );\n\n\t\tfor ( const [ name, range ] of markers ) {\n\t\t\tthis._convertMarkerAdd( name, range, conversionApi );\n\t\t}\n\n\t\t// Verify if all insert consumables were consumed.\n\t\tconversionApi.consumable.verifyAllConsumed( 'insert' );\n\t}\n\n\t/**\n\t * Starts the model selection conversion.\n\t *\n\t * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.\n\t *\n\t * @fires selection\n\t * @fires addMarker\n\t * @fires attribute\n\t * @param {module:engine/model/selection~Selection} selection The selection to convert.\n\t * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with the converted model.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n\t */\n\tconvertSelection( selection, markers, writer ) {\n\t\tconst markersAtSelection = Array.from( markers.getMarkersAtPosition( selection.getFirstPosition() ) );\n\n\t\tconst conversionApi = this._createConversionApi( writer );\n\n\t\tthis._addConsumablesForSelection( conversionApi.consumable, selection, markersAtSelection );\n\n\t\tthis.fire( 'selection', { selection }, conversionApi );\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const marker of markersAtSelection ) {\n\t\t\tconst markerRange = marker.getRange();\n\n\t\t\tif ( !shouldMarkerChangeBeConverted( selection.getFirstPosition(), marker, conversionApi.mapper ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = {\n\t\t\t\titem: selection,\n\t\t\t\tmarkerName: marker.name,\n\t\t\t\tmarkerRange\n\t\t\t};\n\n\t\t\tif ( conversionApi.consumable.test( selection, 'addMarker:' + marker.name ) ) {\n\t\t\t\tthis.fire( 'addMarker:' + marker.name, data, conversionApi );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of selection.getAttributeKeys() ) {\n\t\t\tconst data = {\n\t\t\t\titem: selection,\n\t\t\t\trange: selection.getFirstRange(),\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: null,\n\t\t\t\tattributeNewValue: selection.getAttribute( key )\n\t\t\t};\n\n\t\t\t// Do not fire event if the attribute has been consumed.\n\t\t\tif ( conversionApi.consumable.test( selection, 'attribute:' + data.attributeKey ) ) {\n\t\t\t\tthis.fire( 'attribute:' + data.attributeKey + ':$text', data, conversionApi );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Fires insertion conversion of a range of nodes.\n\t *\n\t * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,\n\t * {@link #event:attribute `attribute` event is fired}.\n\t *\n\t * @protected\n\t * @fires insert\n\t * @fires attribute\n\t * @param {module:engine/model/range~Range} range The inserted range.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.doNotAddConsumables=false] Whether the ModelConsumable should not get populated\n\t * for items in the provided range.\n\t */\n\t_convertInsert( range, conversionApi, options = {} ) {\n\t\tif ( !options.doNotAddConsumables ) {\n\t\t\t// Collect a list of things that can be consumed, consisting of nodes and their attributes.\n\t\t\tthis._addConsumablesForInsert( conversionApi.consumable, Array.from( range ) );\n\t\t}\n\n\t\t// Fire a separate insert event for each node and text fragment contained in the range.\n\t\tfor ( const data of Array.from( range.getWalker( { shallow: true } ) ).map( walkerValueToEventData ) ) {\n\t\t\tthis._testAndFire( 'insert', data, conversionApi );\n\t\t}\n\t}\n\n\t/**\n\t * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} position Position from which node was removed.\n\t * @param {Number} length Offset size of removed node.\n\t * @param {String} name Name of removed node.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n\t */\n\t_convertRemove( position, length, name, conversionApi ) {\n\t\tthis.fire( 'remove:' + name, { position, length }, conversionApi );\n\t}\n\n\t/**\n\t * Starts a conversion of an attribute change on a given `range`.\n\t *\n\t * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.\n\t *\n\t * @protected\n\t * @fires attribute\n\t * @param {module:engine/model/range~Range} range Changed range.\n\t * @param {String} key Key of the attribute that has changed.\n\t * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.\n\t * @param {*} newValue New attribute value or `null` if the attribute has been removed.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n\t */\n\t_convertAttribute( range, key, oldValue, newValue, conversionApi ) {\n\t\t// Create a list with attributes to consume.\n\t\tthis._addConsumablesForRange( conversionApi.consumable, range, `attribute:${ key }` );\n\n\t\t// Create a separate attribute event for each node in the range.\n\t\tfor ( const value of range ) {\n\t\t\tconst data = {\n\t\t\t\titem: value.item,\n\t\t\t\trange: Range._createFromPositionAndShift( value.previousPosition, value.length ),\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: oldValue,\n\t\t\t\tattributeNewValue: newValue\n\t\t\t};\n\n\t\t\tthis._testAndFire( `attribute:${ key }`, data, conversionApi );\n\t\t}\n\t}\n\n\t/**\n\t * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)\n\t * of a range of elements (only elements on the range depth, without children).\n\t *\n\t * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.\n\t * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.\n\t *\n\t * @protected\n\t * @fires insert\n\t * @fires attribute\n\t * @param {module:engine/model/range~Range} range The range to reinsert.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n\t */\n\t_convertReinsert( range, conversionApi ) {\n\t\t// Convert the elements - without converting children.\n\t\tconst walkerValues = Array.from( range.getWalker( { shallow: true } ) );\n\n\t\t// Collect a list of things that can be consumed, consisting of nodes and their attributes.\n\t\tthis._addConsumablesForInsert( conversionApi.consumable, walkerValues );\n\n\t\t// Fire a separate insert event for each node and text fragment contained shallowly in the range.\n\t\tfor ( const data of walkerValues.map( walkerValueToEventData ) ) {\n\t\t\tthis._testAndFire( 'insert', { ...data, reconversion: true }, conversionApi );\n\t\t}\n\t}\n\n\t/**\n\t * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item\n\t * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.\n\t *\n\t * @protected\n\t * @fires addMarker\n\t * @param {String} markerName Marker name.\n\t * @param {module:engine/model/range~Range} markerRange The marker range.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n\t */\n\t_convertMarkerAdd( markerName, markerRange, conversionApi ) {\n\t\t// Do not convert if range is in graveyard.\n\t\tif ( markerRange.root.rootName == '$graveyard' ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// In markers' case, event name == consumable name.\n\t\tconst eventName = 'addMarker:' + markerName;\n\n\t\t//\n\t\t// First, fire an event for the whole marker.\n\t\t//\n\t\tconversionApi.consumable.add( markerRange, eventName );\n\n\t\tthis.fire( eventName, { markerName, markerRange }, conversionApi );\n\n\t\t//\n\t\t// Do not fire events for each item inside the range if the range got consumed.\n\t\t// Also consume the whole marker consumable if it wasn't consumed.\n\t\t//\n\t\tif ( !conversionApi.consumable.consume( markerRange, eventName ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t//\n\t\t// Then, fire an event for each item inside the marker range.\n\t\t//\n\t\tthis._addConsumablesForRange( conversionApi.consumable, markerRange, eventName );\n\n\t\tfor ( const item of markerRange.getItems() ) {\n\t\t\t// Do not fire event for already consumed items.\n\t\t\tif ( !conversionApi.consumable.test( item, eventName ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = { item, range: Range._createOn( item ), markerName, markerRange };\n\n\t\t\tthis.fire( eventName, data, conversionApi );\n\t\t}\n\t}\n\n\t/**\n\t * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.\n\t *\n\t * @protected\n\t * @fires removeMarker\n\t * @param {String} markerName Marker name.\n\t * @param {module:engine/model/range~Range} markerRange The marker range.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n\t */\n\t_convertMarkerRemove( markerName, markerRange, conversionApi ) {\n\t\t// Do not convert if range is in graveyard.\n\t\tif ( markerRange.root.rootName == '$graveyard' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fire( 'removeMarker:' + markerName, { markerName, markerRange }, conversionApi );\n\t}\n\n\t/**\n\t * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.\n\t *\n\t * Features can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with `reinsert` entries to trigger\n\t * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n\t * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.\n\t *\n\t * @private\n\t * @fires reduceChanges\n\t * @param {Iterable.<module:engine/model/differ~DiffItem>} changes\n\t * @returns {Iterable.<module:engine/model/differ~DiffItem>}\n\t */\n\t_reduceChanges( changes ) {\n\t\tconst data = { changes };\n\n\t\tthis.fire( 'reduceChanges', data );\n\n\t\treturn data.changes;\n\t}\n\n\t/**\n\t * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,\n\t * assuming that the range has just been inserted to the model.\n\t *\n\t * @private\n\t * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n\t * @param {Iterable.<module:engine/model/treewalker~TreeWalkerValue>} walkerValues The walker values for the inserted range.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n\t */\n\t_addConsumablesForInsert( consumable, walkerValues ) {\n\t\tfor ( const value of walkerValues ) {\n\t\t\tconst item = value.item;\n\n\t\t\t// Add consumable if it wasn't there yet.\n\t\t\tif ( consumable.test( item, 'insert' ) === null ) {\n\t\t\t\tconsumable.add( item, 'insert' );\n\n\t\t\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\t\t\tconsumable.add( item, 'attribute:' + key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.\n\t *\n\t * @private\n\t * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n\t * @param {module:engine/model/range~Range} range The affected range.\n\t * @param {String} type Consumable type.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n\t */\n\t_addConsumablesForRange( consumable, range, type ) {\n\t\tfor ( const item of range.getItems() ) {\n\t\t\tconsumable.add( item, type );\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.\n\t *\n\t * @private\n\t * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n\t * @param {module:engine/model/selection~Selection} selection The selection to create the consumable from.\n\t * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers that contain the selection.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n\t */\n\t_addConsumablesForSelection( consumable, selection, markers ) {\n\t\tconsumable.add( selection, 'selection' );\n\n\t\tfor ( const marker of markers ) {\n\t\t\tconsumable.add( selection, 'addMarker:' + marker.name );\n\t\t}\n\n\t\tfor ( const key of selection.getAttributeKeys() ) {\n\t\t\tconsumable.add( selection, 'attribute:' + key );\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Tests whether given event wasn't already fired and if so, fires it.\n\t *\n\t * @private\n\t * @fires insert\n\t * @fires attribute\n\t * @param {String} type Event type.\n\t * @param {Object} data Event data.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n\t */\n\t_testAndFire( type, data, conversionApi ) {\n\t\tconst eventName = getEventName( type, data );\n\t\tconst itemKey = data.item.is( '$textProxy' ) ? conversionApi.consumable._getSymbolForTextProxy( data.item ) : data.item;\n\n\t\tconst eventsFiredForConversion = this._firedEventsMap.get( conversionApi );\n\t\tconst eventsFiredForItem = eventsFiredForConversion.get( itemKey );\n\n\t\tif ( !eventsFiredForItem ) {\n\t\t\teventsFiredForConversion.set( itemKey, new Set( [ eventName ] ) );\n\t\t} else if ( !eventsFiredForItem.has( eventName ) ) {\n\t\t\teventsFiredForItem.add( eventName );\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fire( eventName, data, conversionApi );\n\t}\n\n\t/**\n\t * Fires not already fired events for setting attributes on just inserted item.\n\t *\n\t * @private\n\t * @param {module:engine/model/item~Item} item The model item to convert attributes for.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n\t */\n\t_testAndFireAddAttributes( item, conversionApi ) {\n\t\tconst data = {\n\t\t\titem,\n\t\t\trange: Range._createOn( item )\n\t\t};\n\n\t\tfor ( const key of data.item.getAttributeKeys() ) {\n\t\t\tdata.attributeKey = key;\n\t\t\tdata.attributeOldValue = null;\n\t\t\tdata.attributeNewValue = data.item.getAttribute( key );\n\n\t\t\tthis._testAndFire( `attribute:${ key }`, data, conversionApi );\n\t\t}\n\t}\n\n\t/**\n\t * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given\n\t * {@link module:engine/view/downcastwriter~DowncastWriter `DowncastWriter`} and options object.\n\t *\n\t * @private\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n\t * @param {Set.<module:engine/model/element~Element>} [refreshedItems] A set of model elements that should not reuse their\n\t * previous view representations.\n\t * @param {Object} [options] Optional options passed to `convertionApi.options`.\n\t * @return {module:engine/conversion/downcastdispatcher~DowncastConversionApi} The conversion API object.\n\t */\n\t_createConversionApi( writer, refreshedItems = new Set(), options = {} ) {\n\t\tconst conversionApi = {\n\t\t\t...this._conversionApi,\n\t\t\tconsumable: new Consumable(),\n\t\t\twriter,\n\t\t\toptions,\n\t\t\tconvertItem: item => this._convertInsert( Range._createOn( item ), conversionApi ),\n\t\t\tconvertChildren: element => this._convertInsert( Range._createIn( element ), conversionApi, { doNotAddConsumables: true } ),\n\t\t\tconvertAttributes: item => this._testAndFireAddAttributes( item, conversionApi ),\n\t\t\tcanReuseView: viewElement => !refreshedItems.has( conversionApi.mapper.toModelElement( viewElement ) )\n\t\t};\n\n\t\tthis._firedEventsMap.set( conversionApi, new Map() );\n\n\t\treturn conversionApi;\n\t}\n\n\t/**\n\t * Fired to enable reducing (transforming) changes buffered in the {@link module:engine/model/differ~Differ `Differ`} before\n\t * {@link #convertChanges `convertChanges()`} will fire any conversion events.\n\t *\n\t * For instance, a feature can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with a `reinsert` entry\n\t * to trigger reconversion of an element when e.g. its attribute has changes.\n\t * The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n\t * `DowncastHelpers.elementToStructure()`} helper is using this event to trigger reconversion of an element when the element,\n\t * its attributes or direct children changed.\n\t *\n\t * @param {Object} data\n\t * @param {Iterable.<module:engine/model/differ~DiffItem>} data.changes A buffered changes to get reduced.\n\t * @event reduceChanges\n\t */\n\n\t/**\n\t * Fired for inserted nodes.\n\t *\n\t * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `insert:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been inserted,\n\t * or {@link module:engine/model/element~Element#name name} of inserted element.\n\t *\n\t * This way, the listeners can either listen to a general `insert` event or specific event (for example `insert:paragraph`).\n\t *\n\t * @event insert\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item} data.item The inserted item.\n\t * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in the `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired for removed nodes.\n\t *\n\t * `remove` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `remove:name`. `name` is either `'$text'`, when a {@link module:engine/model/text~Text a text node} has been removed,\n\t * or the {@link module:engine/model/element~Element#name name} of removed element.\n\t *\n\t * This way, listeners can either listen to a general `remove` event or specific event (for example `remove:paragraph`).\n\t *\n\t * @event remove\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/position~Position} data.position Position from which the node has been removed.\n\t * @param {Number} data.length Offset size of the removed node.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired in the following cases:\n\t *\n\t * * when an attribute has been added, changed, or removed from a node,\n\t * * when a node with an attribute is inserted,\n\t * * when a collapsed model selection attribute is converted.\n\t *\n\t * `attribute` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `attribute:attributeKey:name`. `attributeKey` is the key of added/changed/removed attribute.\n\t * `name` is either `'$text'` if change was on {@link module:engine/model/text~Text a text node},\n\t * or the {@link module:engine/model/element~Element#name name} of element which attribute has changed.\n\t *\n\t * This way listeners can either listen to a general `attribute:bold` event or specific event (for example `attribute:src:imageBlock`).\n\t *\n\t * @event attribute\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n\t * or converted selection.\n\t * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n\t * @param {String} data.attributeKey Attribute key.\n\t * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n\t * @param {*} data.attributeNewValue New attribute value.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired for {@link module:engine/model/selection~Selection selection} changes.\n\t *\n\t * @event selection\n\t * @param {module:engine/model/selection~Selection} selection Selection that is converted.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired when a new marker is added to the model. Also fired when a collapsed model selection that is inside a marker is converted.\n\t *\n\t * `addMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `addMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n\t * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `addMarker:foo` or `addMarker:foo:abc` and\n\t * `addMarker:foo:bar` events.\n\t *\n\t * If the marker range is not collapsed:\n\t *\n\t * * the event is fired for each item in the marker range one by one,\n\t * * `conversionApi.consumable` includes each item of the marker range and the consumable value is same as the event name.\n\t *\n\t * If the marker range is collapsed:\n\t *\n\t * * there is only one event,\n\t * * `conversionApi.consumable` includes marker range with the event name.\n\t *\n\t * If the selection inside a marker is converted:\n\t *\n\t * * there is only one event,\n\t * * `conversionApi.consumable` includes the selection instance with the event name.\n\t *\n\t * @event addMarker\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection} data.item Item inside the new marker or\n\t * the selection that is being converted.\n\t * @param {module:engine/model/range~Range} [data.range] Range spanning over converted item. Available only in marker conversion, if\n\t * the marker range was not collapsed.\n\t * @param {module:engine/model/range~Range} data.markerRange Marker range.\n\t * @param {String} data.markerName Marker name.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired when a marker is removed from the model.\n\t *\n\t * `removeMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `removeMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n\t * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `removeMarker:foo` or `removeMarker:foo:abc` and\n\t * `removeMarker:foo:bar` events.\n\t *\n\t * @event removeMarker\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/range~Range} data.markerRange Marker range.\n\t * @param {String} data.markerName Marker name.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n}\n\nmix( DowncastDispatcher, EmitterMixin );\n\n// Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not\n// converted if they happen inside an element with custom conversion method.\n//\n// @param {module:engine/model/position~Position} modelPosition\n// @param {module:engine/model/markercollection~Marker} marker\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\nfunction shouldMarkerChangeBeConverted( modelPosition, marker, mapper ) {\n\tconst range = marker.getRange();\n\tconst ancestors = Array.from( modelPosition.getAncestors() );\n\tancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.\n\tancestors.reverse();\n\n\tconst hasCustomHandling = ancestors.some( element => {\n\t\tif ( range.containsItem( element ) ) {\n\t\t\tconst viewElement = mapper.toViewElement( element );\n\n\t\t\treturn !!viewElement.getCustomProperty( 'addHighlight' );\n\t\t}\n\t} );\n\n\treturn !hasCustomHandling;\n}\n\nfunction getEventName( type, data ) {\n\tconst name = data.item.name || '$text';\n\n\treturn `${ type }:${ name }`;\n}\n\nfunction walkerValueToEventData( value ) {\n\tconst item = value.item;\n\tconst itemRange = Range._createFromPositionAndShift( value.previousPosition, value.length );\n\n\treturn {\n\t\titem,\n\t\trange: itemRange\n\t};\n}\n\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher dispatcher}\n * fires its events.\n *\n * @interface module:engine/conversion/downcastdispatcher~DowncastConversionApi\n */\n\n/**\n * The {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} instance.\n *\n * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #dispatcher\n */\n\n/**\n * Stores the information about what parts of a processed model item are still waiting to be handled. After a piece of a model item was\n * converted, an appropriate consumable value should be {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/modelconsumable~ModelConsumable} #consumable\n */\n\n/**\n * The {@link module:engine/conversion/mapper~Mapper} instance.\n *\n * @member {module:engine/conversion/mapper~Mapper} #mapper\n */\n\n/**\n * The {@link module:engine/model/schema~Schema} instance set for the model that is downcast.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/view/downcastwriter~DowncastWriter} instance used to manipulate the data during conversion.\n *\n * @member {module:engine/view/downcastwriter~DowncastWriter} #writer\n */\n\n/**\n * Triggers conversion of a specified item.\n * This conversion is triggered within (as a separate process of) the parent conversion.\n *\n * @method #convertItem\n * @param {module:engine/model/item~Item} item The model item to trigger nested insert conversion on.\n */\n\n/**\n * Triggers conversion of children of a specified element.\n *\n * @method #convertChildren\n * @param {module:engine/model/element~Element} element The model element to trigger children insert conversion on.\n */\n\n/**\n * Triggers conversion of attributes of a specified item.\n *\n * @method #convertAttributes\n * @param {module:engine/model/item~Item} item The model item to trigger attribute conversion on.\n */\n\n/**\n * An object with an additional configuration which can be used during the conversion process. Available only for data downcast conversion.\n *\n * @member {Object} #options\n */\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,UAAP,MAAuB,mBAAvB;AACA,OAAOC,KAAP,MAAkB,gBAAlB;AAEA,OAAOC,YAAP,MAAyB,4CAAzB;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,kBAAN,CAAyB;EACvC;AACD;AACA;AACA;AACA;AACA;AACA;EACCC,WAAW,CAAEC,aAAF,EAAkB;IAC5B;AACF;AACA;AACA;AACA;AACA;IACE,KAAKC,cAAL,GAAsB;MAAEC,UAAU,EAAE,IAAd;MAAoB,GAAGF;IAAvB,CAAtB;IAEA;AACF;AACA;AACA;AACA;AACA;;IACE,KAAKG,eAAL,GAAuB,IAAIC,OAAJ,EAAvB;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCC,cAAc,CAAEC,MAAF,EAAUC,OAAV,EAAmBC,MAAnB,EAA4B;IACzC,MAAMR,aAAa,GAAG,KAAKS,oBAAL,CAA2BD,MAA3B,EAAmCF,MAAM,CAACI,iBAAP,EAAnC,CAAtB,CADyC,CAGzC;;;IACA,KAAM,MAAMC,MAAZ,IAAsBL,MAAM,CAACM,kBAAP,EAAtB,EAAoD;MACnD,KAAKC,oBAAL,CAA2BF,MAAM,CAACG,IAAlC,EAAwCH,MAAM,CAACI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EAAzC;;IAEA,OAAOxG,aAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAtnBwC;AAynBxCH,GAAG,CAAEC,kBAAF,EAAsBF,YAAtB,CAAH,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAS4D,6BAAT,CAAwCiD,aAAxC,EAAuDlD,MAAvD,EAA+DvB,MAA/D,EAAwE;EACvE,MAAMjB,KAAK,GAAGwC,MAAM,CAACnB,QAAP,EAAd;EACA,MAAMsE,SAAS,GAAG1D,KAAK,CAACC,IAAN,CAAYwD,aAAa,CAACE,YAAd,EAAZ,CAAlB;EACAD,SAAS,CAACE,KAAV,GAHuE,CAGpD;;EACnBF,SAAS,CAACG,OAAV;EAEA,MAAMC,iBAAiB,GAAGJ,SAAS,CAACK,IAAV,CAAgBb,OAAO,IAAI;IACpD,IAAKnF,KAAK,CAACiG,YAAN,CAAoBd,OAApB,CAAL,EAAqC;MACpC,MAAMI,WAAW,GAAGtE,MAAM,CAACiF,aAAP,CAAsBf,OAAtB,CAApB;MAEA,OAAO,CAAC,CAACI,WAAW,CAACY,iBAAZ,CAA+B,cAA/B,CAAT;IACA;EACD,CANyB,CAA1B;EAQA,OAAO,CAACJ,iBAAR;AACA;;AAED,SAASzB,YAAT,CAAuBjE,IAAvB,EAA6BqC,IAA7B,EAAoC;EACnC,MAAM3C,IAAI,GAAG2C,IAAI,CAACC,IAAL,CAAU5C,IAAV,IAAkB,OAA/B;EAEA,OAAQ,GAAGM,IAAM,IAAIN,IAAM,EAA3B;AACA;;AAED,SAASuD,sBAAT,CAAiCK,KAAjC,EAAyC;EACxC,MAAMhB,IAAI,GAAGgB,KAAK,CAAChB,IAAnB;;EACA,MAAMyD,SAAS,GAAGxH,KAAK,CAAC2B,2BAAN,CAAmCoD,KAAK,CAACC,gBAAzC,EAA2DD,KAAK,CAAClD,MAAjE,CAAlB;;EAEA,OAAO;IACNkC,IADM;IAEN3C,KAAK,EAAEoG;EAFD,CAAP;AAIA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}