{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/emittermixin\n */\nimport EventInfo from './eventinfo';\nimport uid from './uid';\nimport priorities from './priorities';\nimport insertToPriorityArray from './inserttopriorityarray'; // To check if component is loaded more than once.\n\nimport './version';\nimport CKEditorError from './ckeditorerror';\n\nconst _listeningTo = Symbol('listeningTo');\n\nconst _emitterId = Symbol('emitterId');\n/**\n * Mixin that injects the {@link ~Emitter events API} into its host.\n *\n * Read more about the concept of emitters in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide.\n * * {@glink framework/guides/deep-dive/event-system Event system} deep dive guide.\n *\n * @mixin EmitterMixin\n * @implements module:utils/emittermixin~Emitter\n */\n\n\nconst EmitterMixin = {\n  /**\n   * @inheritDoc\n   */\n  on(event, callback) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.listenTo(this, event, callback, options);\n  },\n\n  /**\n   * @inheritDoc\n   */\n  once(event, callback, options) {\n    let wasFired = false;\n\n    const onceCallback = function (event) {\n      // Ensure the callback is called only once even if the callback itself leads to re-firing the event\n      // (which would call the callback again).\n      if (!wasFired) {\n        wasFired = true; // Go off() at the first call.\n\n        event.off(); // Go with the original callback.\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        callback.call(this, event, ...args);\n      }\n    }; // Make a similar on() call, simply replacing the callback.\n\n\n    this.listenTo(this, event, onceCallback, options);\n  },\n\n  /**\n   * @inheritDoc\n   */\n  off(event, callback) {\n    this.stopListening(this, event, callback);\n  },\n\n  /**\n   * @inheritDoc\n   */\n  listenTo(emitter, event, callback) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let emitterInfo, eventCallbacks; // _listeningTo contains a list of emitters that this object is listening to.\n    // This list has the following format:\n    //\n    // _listeningTo: {\n    //     emitterId: {\n    //         emitter: emitter,\n    //         callbacks: {\n    //             event1: [ callback1, callback2, ... ]\n    //             ....\n    //         }\n    //     },\n    //     ...\n    // }\n\n    if (!this[_listeningTo]) {\n      this[_listeningTo] = {};\n    }\n\n    const emitters = this[_listeningTo];\n\n    if (!_getEmitterId(emitter)) {\n      _setEmitterId(emitter);\n    }\n\n    const emitterId = _getEmitterId(emitter);\n\n    if (!(emitterInfo = emitters[emitterId])) {\n      emitterInfo = emitters[emitterId] = {\n        emitter,\n        callbacks: {}\n      };\n    }\n\n    if (!(eventCallbacks = emitterInfo.callbacks[event])) {\n      eventCallbacks = emitterInfo.callbacks[event] = [];\n    }\n\n    eventCallbacks.push(callback); // Finally register the callback to the event.\n\n    addEventListener(this, emitter, event, callback, options);\n  },\n\n  /**\n   * @inheritDoc\n   */\n  stopListening(emitter, event, callback) {\n    const emitters = this[_listeningTo];\n\n    let emitterId = emitter && _getEmitterId(emitter);\n\n    const emitterInfo = emitters && emitterId && emitters[emitterId];\n    const eventCallbacks = emitterInfo && event && emitterInfo.callbacks[event]; // Stop if nothing has been listened.\n\n    if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {\n      return;\n    } // All params provided. off() that single callback.\n\n\n    if (callback) {\n      removeEventListener(this, emitter, event, callback); // We must remove callbacks as well in order to prevent memory leaks.\n      // See https://github.com/ckeditor/ckeditor5/pull/8480\n\n      const index = eventCallbacks.indexOf(callback);\n\n      if (index !== -1) {\n        if (eventCallbacks.length === 1) {\n          delete emitterInfo.callbacks[event];\n        } else {\n          removeEventListener(this, emitter, event, callback);\n        }\n      }\n    } // Only `emitter` and `event` provided. off() all callbacks for that event.\n    else if (eventCallbacks) {\n      while (callback = eventCallbacks.pop()) {\n        removeEventListener(this, emitter, event, callback);\n      }\n\n      delete emitterInfo.callbacks[event];\n    } // Only `emitter` provided. off() all events for that emitter.\n    else if (emitterInfo) {\n      for (event in emitterInfo.callbacks) {\n        this.stopListening(emitter, event);\n      }\n\n      delete emitters[emitterId];\n    } // No params provided. off() all emitters.\n    else {\n      for (emitterId in emitters) {\n        this.stopListening(emitters[emitterId].emitter);\n      }\n\n      delete this[_listeningTo];\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  fire(eventOrInfo) {\n    try {\n      const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);\n      const event = eventInfo.name;\n      let callbacks = getCallbacksForEvent(this, event); // Record that the event passed this emitter on its path.\n\n      eventInfo.path.push(this); // Handle event listener callbacks first.\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      if (callbacks) {\n        // Arguments passed to each callback.\n        const callbackArgs = [eventInfo, ...args]; // Copying callbacks array is the easiest and most secure way of preventing infinite loops, when event callbacks\n        // are added while processing other callbacks. Previous solution involved adding counters (unique ids) but\n        // failed if callbacks were added to the queue before currently processed callback.\n        // If this proves to be too inefficient, another method is to change `.on()` so callbacks are stored if same\n        // event is currently processed. Then, `.fire()` at the end, would have to add all stored events.\n\n        callbacks = Array.from(callbacks);\n\n        for (let i = 0; i < callbacks.length; i++) {\n          callbacks[i].callback.apply(this, callbackArgs); // Remove the callback from future requests if off() has been called.\n\n          if (eventInfo.off.called) {\n            // Remove the called mark for the next calls.\n            delete eventInfo.off.called;\n\n            this._removeEventListener(event, callbacks[i].callback);\n          } // Do not execute next callbacks if stop() was called.\n\n\n          if (eventInfo.stop.called) {\n            break;\n          }\n        }\n      } // Delegate event to other emitters if needed.\n\n\n      if (this._delegations) {\n        const destinations = this._delegations.get(event);\n\n        const passAllDestinations = this._delegations.get('*');\n\n        if (destinations) {\n          fireDelegatedEvents(destinations, eventInfo, args);\n        }\n\n        if (passAllDestinations) {\n          fireDelegatedEvents(passAllDestinations, eventInfo, args);\n        }\n      }\n\n      return eventInfo.return;\n    } catch (err) {\n      // @if CK_DEBUG // throw err;\n\n      /* istanbul ignore next */\n      CKEditorError.rethrowUnexpectedError(err, this);\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  delegate() {\n    for (var _len3 = arguments.length, events = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      events[_key3] = arguments[_key3];\n    }\n\n    return {\n      to: (emitter, nameOrFunction) => {\n        if (!this._delegations) {\n          this._delegations = new Map();\n        } // Originally there was a for..of loop which unfortunately caused an error in Babel that didn't allow\n        // build an application. See: https://github.com/ckeditor/ckeditor5-react/issues/40.\n\n\n        events.forEach(eventName => {\n          const destinations = this._delegations.get(eventName);\n\n          if (!destinations) {\n            this._delegations.set(eventName, new Map([[emitter, nameOrFunction]]));\n          } else {\n            destinations.set(emitter, nameOrFunction);\n          }\n        });\n      }\n    };\n  },\n\n  /**\n   * @inheritDoc\n   */\n  stopDelegating(event, emitter) {\n    if (!this._delegations) {\n      return;\n    }\n\n    if (!event) {\n      this._delegations.clear();\n    } else if (!emitter) {\n      this._delegations.delete(event);\n    } else {\n      const destinations = this._delegations.get(event);\n\n      if (destinations) {\n        destinations.delete(emitter);\n      }\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  _addEventListener(event, callback, options) {\n    createEventNamespace(this, event);\n    const lists = getCallbacksListsForNamespace(this, event);\n    const priority = priorities.get(options.priority);\n    const callbackDefinition = {\n      callback,\n      priority\n    }; // Add the callback to all callbacks list.\n\n    for (const callbacks of lists) {\n      // Add the callback to the list in the right priority position.\n      insertToPriorityArray(callbacks, callbackDefinition);\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  _removeEventListener(event, callback) {\n    const lists = getCallbacksListsForNamespace(this, event);\n\n    for (const callbacks of lists) {\n      for (let i = 0; i < callbacks.length; i++) {\n        if (callbacks[i].callback == callback) {\n          // Remove the callback from the list (fixing the next index).\n          callbacks.splice(i, 1);\n          i--;\n        }\n      }\n    }\n  }\n\n};\nexport default EmitterMixin;\n/**\n * Emitter/listener interface.\n *\n * Can be easily implemented by a class by mixing the {@link module:utils/emittermixin~EmitterMixin} mixin.\n *\n * Read more about the usage of this interface in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide.\n * * {@glink framework/guides/deep-dive/event-system Event system} deep dive guide.\n *\n * @interface Emitter\n */\n\n/**\n * Registers a callback function to be executed when an event is fired.\n *\n * Shorthand for {@link #listenTo `this.listenTo( this, event, callback, options )`} (it makes the emitter\n * listen on itself).\n *\n * @method #on\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Registers a callback function to be executed on the next time the event is fired only. This is similar to\n * calling {@link #on} followed by {@link #off} in the callback.\n *\n * @method #once\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Stops executing the callback on the given event.\n * Shorthand for {@link #stopListening `this.stopListening( this, event, callback )`}.\n *\n * @method #off\n * @param {String} event The name of the event.\n * @param {Function} callback The function to stop being called.\n */\n\n/**\n * Registers a callback function to be executed when an event is fired in a specific (emitter) object.\n *\n * Events can be grouped in namespaces using `:`.\n * When namespaced event is fired, it additionally fires all callbacks for that namespace.\n *\n *\t\t// myEmitter.on( ... ) is a shorthand for myEmitter.listenTo( myEmitter, ... ).\n *\t\tmyEmitter.on( 'myGroup', genericCallback );\n *\t\tmyEmitter.on( 'myGroup:myEvent', specificCallback );\n *\n *\t\t// genericCallback is fired.\n *\t\tmyEmitter.fire( 'myGroup' );\n *\t\t// both genericCallback and specificCallback are fired.\n *\t\tmyEmitter.fire( 'myGroup:myEvent' );\n *\t\t// genericCallback is fired even though there are no callbacks for \"foo\".\n *\t\tmyEmitter.fire( 'myGroup:foo' );\n *\n * An event callback can {@link module:utils/eventinfo~EventInfo#stop stop the event} and\n * set the {@link module:utils/eventinfo~EventInfo#return return value} of the {@link #fire} method.\n *\n * @method #listenTo\n * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Stops listening for events. It can be used at different levels:\n *\n * * To stop listening to a specific callback.\n * * To stop listening to a specific event.\n * * To stop listening to all events fired by a specific object.\n * * To stop listening to all events fired by all objects.\n *\n * @method #stopListening\n * @param {module:utils/emittermixin~Emitter} [emitter] The object to stop listening to. If omitted, stops it for all objects.\n * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it\n * for all events from `emitter`.\n * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given\n * `event`.\n */\n\n/**\n * Fires an event, executing all callbacks registered for it.\n *\n * The first parameter passed to callbacks is an {@link module:utils/eventinfo~EventInfo} object,\n * followed by the optional `args` provided in the `fire()` method call.\n *\n * @method #fire\n * @param {String|module:utils/eventinfo~EventInfo} eventOrInfo The name of the event or `EventInfo` object if event is delegated.\n * @param {...*} [args] Additional arguments to be passed to the callbacks.\n * @returns {*} By default the method returns `undefined`. However, the return value can be changed by listeners\n * through modification of the {@link module:utils/eventinfo~EventInfo#return `evt.return`}'s property (the event info\n * is the first param of every callback).\n */\n\n/**\n * Delegates selected events to another {@link module:utils/emittermixin~Emitter}. For instance:\n *\n *\t\temitterA.delegate( 'eventX' ).to( emitterB );\n *\t\temitterA.delegate( 'eventX', 'eventY' ).to( emitterC );\n *\n * then `eventX` is delegated (fired by) `emitterB` and `emitterC` along with `data`:\n *\n *\t\temitterA.fire( 'eventX', data );\n *\n * and `eventY` is delegated (fired by) `emitterC` along with `data`:\n *\n *\t\temitterA.fire( 'eventY', data );\n *\n * @method #delegate\n * @param {...String} events Event names that will be delegated to another emitter.\n * @returns {module:utils/emittermixin~EmitterMixinDelegateChain}\n */\n\n/**\n * Stops delegating events. It can be used at different levels:\n *\n * * To stop delegating all events.\n * * To stop delegating a specific event to all emitters.\n * * To stop delegating a specific event to a specific emitter.\n *\n * @method #stopDelegating\n * @param {String} [event] The name of the event to stop delegating. If omitted, stops it all delegations.\n * @param {module:utils/emittermixin~Emitter} [emitter] (requires `event`) The object to stop delegating a particular event to.\n * If omitted, stops delegation of `event` to all emitters.\n */\n\n/**\n * Adds callback to emitter for given event.\n *\n * @protected\n * @method #_addEventListener\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Removes callback from emitter for given event.\n *\n * @protected\n * @method #_removeEventListener\n * @param {String} event The name of the event.\n * @param {Function} callback The function to stop being called.\n */\n\n/**\n * Checks if `listeningEmitter` listens to an emitter with given `listenedToEmitterId` and if so, returns that emitter.\n * If not, returns `null`.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} listeningEmitter An emitter that listens.\n * @param {String} listenedToEmitterId Unique emitter id of emitter listened to.\n * @returns {module:utils/emittermixin~Emitter|null}\n */\n\nexport function _getEmitterListenedTo(listeningEmitter, listenedToEmitterId) {\n  if (listeningEmitter[_listeningTo] && listeningEmitter[_listeningTo][listenedToEmitterId]) {\n    return listeningEmitter[_listeningTo][listenedToEmitterId].emitter;\n  }\n\n  return null;\n}\n/**\n * Sets emitter's unique id.\n *\n * **Note:** `_emitterId` can be set only once.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter for which id will be set.\n * @param {String} [id] Unique id to set. If not passed, random unique id will be set.\n */\n\nexport function _setEmitterId(emitter, id) {\n  if (!emitter[_emitterId]) {\n    emitter[_emitterId] = id || uid();\n  }\n}\n/**\n * Returns emitter's unique id.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter which id will be returned.\n */\n\nexport function _getEmitterId(emitter) {\n  return emitter[_emitterId];\n} // Gets the internal `_events` property of the given object.\n// `_events` property store all lists with callbacks for registered event names.\n// If there were no events registered on the object, empty `_events` object is created.\n\nfunction getEvents(source) {\n  if (!source._events) {\n    Object.defineProperty(source, '_events', {\n      value: {}\n    });\n  }\n\n  return source._events;\n} // Creates event node for generic-specific events relation architecture.\n\n\nfunction makeEventNode() {\n  return {\n    callbacks: [],\n    childEvents: []\n  };\n} // Creates an architecture for generic-specific events relation.\n// If needed, creates all events for given eventName, i.e. if the first registered event\n// is foo:bar:abc, it will create foo:bar:abc, foo:bar and foo event and tie them together.\n// It also copies callbacks from more generic events to more specific events when\n// specific events are created.\n\n\nfunction createEventNamespace(source, eventName) {\n  const events = getEvents(source); // First, check if the event we want to add to the structure already exists.\n\n  if (events[eventName]) {\n    // If it exists, we don't have to do anything.\n    return;\n  } // In other case, we have to create the structure for the event.\n  // Note, that we might need to create intermediate events too.\n  // I.e. if foo:bar:abc is being registered and we only have foo in the structure,\n  // we need to also register foo:bar.\n  // Currently processed event name.\n\n\n  let name = eventName; // Name of the event that is a child event for currently processed event.\n\n  let childEventName = null; // Array containing all newly created specific events.\n\n  const newEventNodes = []; // While loop can't check for ':' index because we have to handle generic events too.\n  // In each loop, we truncate event name, going from the most specific name to the generic one.\n  // I.e. foo:bar:abc -> foo:bar -> foo.\n\n  while (name !== '') {\n    if (events[name]) {\n      // If the currently processed event name is already registered, we can be sure\n      // that it already has all the structure created, so we can break the loop here\n      // as no more events need to be registered.\n      break;\n    } // If this event is not yet registered, create a new object for it.\n\n\n    events[name] = makeEventNode(); // Add it to the array with newly created events.\n\n    newEventNodes.push(events[name]); // Add previously processed event name as a child of this event.\n\n    if (childEventName) {\n      events[name].childEvents.push(childEventName);\n    }\n\n    childEventName = name; // If `.lastIndexOf()` returns -1, `.substr()` will return '' which will break the loop.\n\n    name = name.substr(0, name.lastIndexOf(':'));\n  }\n\n  if (name !== '') {\n    // If name is not empty, we found an already registered event that was a parent of the\n    // event we wanted to register.\n    // Copy that event's callbacks to newly registered events.\n    for (const node of newEventNodes) {\n      node.callbacks = events[name].callbacks.slice();\n    } // Add last newly created event to the already registered event.\n\n\n    events[name].childEvents.push(childEventName);\n  }\n} // Gets an array containing callbacks list for a given event and it's more specific events.\n// I.e. if given event is foo:bar and there is also foo:bar:abc event registered, this will\n// return callback list of foo:bar and foo:bar:abc (but not foo).\n\n\nfunction getCallbacksListsForNamespace(source, eventName) {\n  const eventNode = getEvents(source)[eventName];\n\n  if (!eventNode) {\n    return [];\n  }\n\n  let callbacksLists = [eventNode.callbacks];\n\n  for (let i = 0; i < eventNode.childEvents.length; i++) {\n    const childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i]);\n    callbacksLists = callbacksLists.concat(childCallbacksLists);\n  }\n\n  return callbacksLists;\n} // Get the list of callbacks for a given event, but only if there any callbacks have been registered.\n// If there are no callbacks registered for given event, it checks if this is a specific event and looks\n// for callbacks for it's more generic version.\n\n\nfunction getCallbacksForEvent(source, eventName) {\n  let event;\n\n  if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {\n    // There are no callbacks registered for specified eventName.\n    // But this could be a specific-type event that is in a namespace.\n    if (eventName.indexOf(':') > -1) {\n      // If the eventName is specific, try to find callback lists for more generic event.\n      return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(':')));\n    } else {\n      // If this is a top-level generic event, return null;\n      return null;\n    }\n  }\n\n  return event.callbacks;\n} // Fires delegated events for given map of destinations.\n//\n// @private\n// * @param {Map.<utils.Emitter>} destinations A map containing\n// `[ {@link module:utils/emittermixin~Emitter}, \"event name\" ]` pair destinations.\n// * @param {utils.EventInfo} eventInfo The original event info object.\n// * @param {Array.<*>} fireArgs Arguments the original event was fired with.\n\n\nfunction fireDelegatedEvents(destinations, eventInfo, fireArgs) {\n  for (let [emitter, name] of destinations) {\n    if (!name) {\n      name = eventInfo.name;\n    } else if (typeof name == 'function') {\n      name = name(eventInfo.name);\n    }\n\n    const delegatedInfo = new EventInfo(eventInfo.source, name);\n    delegatedInfo.path = [...eventInfo.path];\n    emitter.fire(delegatedInfo, ...fireArgs);\n  }\n} // Helper for registering event callback on the emitter.\n\n\nfunction addEventListener(listener, emitter, event, callback, options) {\n  if (emitter._addEventListener) {\n    emitter._addEventListener(event, callback, options);\n  } else {\n    // Allow listening on objects that do not implement Emitter interface.\n    // This is needed in some tests that are using mocks instead of the real objects with EmitterMixin mixed.\n    listener._addEventListener.call(emitter, event, callback, options);\n  }\n} // Helper for removing event callback from the emitter.\n\n\nfunction removeEventListener(listener, emitter, event, callback) {\n  if (emitter._removeEventListener) {\n    emitter._removeEventListener(event, callback);\n  } else {\n    // Allow listening on objects that do not implement Emitter interface.\n    // This is needed in some tests that are using mocks instead of the real objects with EmitterMixin mixed.\n    listener._removeEventListener.call(emitter, event, callback);\n  }\n}\n/**\n * The return value of {@link ~EmitterMixin#delegate}.\n *\n * @interface module:utils/emittermixin~EmitterMixinDelegateChain\n */\n\n/**\n * Selects destination for {@link module:utils/emittermixin~EmitterMixin#delegate} events.\n *\n * @method #to\n * @param {module:utils/emittermixin~Emitter} emitter An `EmitterMixin` instance which is the destination for delegated events.\n * @param {String|Function} [nameOrFunction] A custom event name or function which converts the original name string.\n */","map":{"version":3,"names":["EventInfo","uid","priorities","insertToPriorityArray","CKEditorError","_listeningTo","Symbol","_emitterId","EmitterMixin","on","event","callback","options","listenTo","once","wasFired","onceCallback","off","args","call","stopListening","emitter","emitterInfo","eventCallbacks","emitters","_getEmitterId","_setEmitterId","emitterId","callbacks","push","addEventListener","removeEventListener","index","indexOf","length","pop","fire","eventOrInfo","eventInfo","name","getCallbacksForEvent","path","callbackArgs","Array","from","i","apply","called","_removeEventListener","stop","_delegations","destinations","get","passAllDestinations","fireDelegatedEvents","return","err","rethrowUnexpectedError","delegate","events","to","nameOrFunction","Map","forEach","eventName","set","stopDelegating","clear","delete","_addEventListener","createEventNamespace","lists","getCallbacksListsForNamespace","priority","callbackDefinition","splice","_getEmitterListenedTo","listeningEmitter","listenedToEmitterId","id","getEvents","source","_events","Object","defineProperty","value","makeEventNode","childEvents","childEventName","newEventNodes","substr","lastIndexOf","node","slice","eventNode","callbacksLists","childCallbacksLists","concat","fireArgs","delegatedInfo","listener"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-utils/src/emittermixin.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/emittermixin\n */\n\nimport EventInfo from './eventinfo';\nimport uid from './uid';\nimport priorities from './priorities';\nimport insertToPriorityArray from './inserttopriorityarray';\n\n// To check if component is loaded more than once.\nimport './version';\nimport CKEditorError from './ckeditorerror';\n\nconst _listeningTo = Symbol( 'listeningTo' );\nconst _emitterId = Symbol( 'emitterId' );\n\n/**\n * Mixin that injects the {@link ~Emitter events API} into its host.\n *\n * Read more about the concept of emitters in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide.\n * * {@glink framework/guides/deep-dive/event-system Event system} deep dive guide.\n *\n * @mixin EmitterMixin\n * @implements module:utils/emittermixin~Emitter\n */\nconst EmitterMixin = {\n\t/**\n\t * @inheritDoc\n\t */\n\ton( event, callback, options = {} ) {\n\t\tthis.listenTo( this, event, callback, options );\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tonce( event, callback, options ) {\n\t\tlet wasFired = false;\n\n\t\tconst onceCallback = function( event, ...args ) {\n\t\t\t// Ensure the callback is called only once even if the callback itself leads to re-firing the event\n\t\t\t// (which would call the callback again).\n\t\t\tif ( !wasFired ) {\n\t\t\t\twasFired = true;\n\n\t\t\t\t// Go off() at the first call.\n\t\t\t\tevent.off();\n\n\t\t\t\t// Go with the original callback.\n\t\t\t\tcallback.call( this, event, ...args );\n\t\t\t}\n\t\t};\n\n\t\t// Make a similar on() call, simply replacing the callback.\n\t\tthis.listenTo( this, event, onceCallback, options );\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\toff( event, callback ) {\n\t\tthis.stopListening( this, event, callback );\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tlistenTo( emitter, event, callback, options = {} ) {\n\t\tlet emitterInfo, eventCallbacks;\n\n\t\t// _listeningTo contains a list of emitters that this object is listening to.\n\t\t// This list has the following format:\n\t\t//\n\t\t// _listeningTo: {\n\t\t//     emitterId: {\n\t\t//         emitter: emitter,\n\t\t//         callbacks: {\n\t\t//             event1: [ callback1, callback2, ... ]\n\t\t//             ....\n\t\t//         }\n\t\t//     },\n\t\t//     ...\n\t\t// }\n\n\t\tif ( !this[ _listeningTo ] ) {\n\t\t\tthis[ _listeningTo ] = {};\n\t\t}\n\n\t\tconst emitters = this[ _listeningTo ];\n\n\t\tif ( !_getEmitterId( emitter ) ) {\n\t\t\t_setEmitterId( emitter );\n\t\t}\n\n\t\tconst emitterId = _getEmitterId( emitter );\n\n\t\tif ( !( emitterInfo = emitters[ emitterId ] ) ) {\n\t\t\temitterInfo = emitters[ emitterId ] = {\n\t\t\t\temitter,\n\t\t\t\tcallbacks: {}\n\t\t\t};\n\t\t}\n\n\t\tif ( !( eventCallbacks = emitterInfo.callbacks[ event ] ) ) {\n\t\t\teventCallbacks = emitterInfo.callbacks[ event ] = [];\n\t\t}\n\n\t\teventCallbacks.push( callback );\n\n\t\t// Finally register the callback to the event.\n\t\taddEventListener( this, emitter, event, callback, options );\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstopListening( emitter, event, callback ) {\n\t\tconst emitters = this[ _listeningTo ];\n\t\tlet emitterId = emitter && _getEmitterId( emitter );\n\t\tconst emitterInfo = emitters && emitterId && emitters[ emitterId ];\n\t\tconst eventCallbacks = emitterInfo && event && emitterInfo.callbacks[ event ];\n\n\t\t// Stop if nothing has been listened.\n\t\tif ( !emitters || ( emitter && !emitterInfo ) || ( event && !eventCallbacks ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// All params provided. off() that single callback.\n\t\tif ( callback ) {\n\t\t\tremoveEventListener( this, emitter, event, callback );\n\n\t\t\t// We must remove callbacks as well in order to prevent memory leaks.\n\t\t\t// See https://github.com/ckeditor/ckeditor5/pull/8480\n\t\t\tconst index = eventCallbacks.indexOf( callback );\n\n\t\t\tif ( index !== -1 ) {\n\t\t\t\tif ( eventCallbacks.length === 1 ) {\n\t\t\t\t\tdelete emitterInfo.callbacks[ event ];\n\t\t\t\t} else {\n\t\t\t\t\tremoveEventListener( this, emitter, event, callback );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Only `emitter` and `event` provided. off() all callbacks for that event.\n\t\telse if ( eventCallbacks ) {\n\t\t\twhile ( ( callback = eventCallbacks.pop() ) ) {\n\t\t\t\tremoveEventListener( this, emitter, event, callback );\n\t\t\t}\n\n\t\t\tdelete emitterInfo.callbacks[ event ];\n\t\t}\n\t\t// Only `emitter` provided. off() all events for that emitter.\n\t\telse if ( emitterInfo ) {\n\t\t\tfor ( event in emitterInfo.callbacks ) {\n\t\t\t\tthis.stopListening( emitter, event );\n\t\t\t}\n\t\t\tdelete emitters[ emitterId ];\n\t\t}\n\t\t// No params provided. off() all emitters.\n\t\telse {\n\t\t\tfor ( emitterId in emitters ) {\n\t\t\t\tthis.stopListening( emitters[ emitterId ].emitter );\n\t\t\t}\n\t\t\tdelete this[ _listeningTo ];\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tfire( eventOrInfo, ...args ) {\n\t\ttry {\n\t\t\tconst eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo( this, eventOrInfo );\n\t\t\tconst event = eventInfo.name;\n\t\t\tlet callbacks = getCallbacksForEvent( this, event );\n\n\t\t\t// Record that the event passed this emitter on its path.\n\t\t\teventInfo.path.push( this );\n\n\t\t\t// Handle event listener callbacks first.\n\t\t\tif ( callbacks ) {\n\t\t\t\t// Arguments passed to each callback.\n\t\t\t\tconst callbackArgs = [ eventInfo, ...args ];\n\n\t\t\t\t// Copying callbacks array is the easiest and most secure way of preventing infinite loops, when event callbacks\n\t\t\t\t// are added while processing other callbacks. Previous solution involved adding counters (unique ids) but\n\t\t\t\t// failed if callbacks were added to the queue before currently processed callback.\n\t\t\t\t// If this proves to be too inefficient, another method is to change `.on()` so callbacks are stored if same\n\t\t\t\t// event is currently processed. Then, `.fire()` at the end, would have to add all stored events.\n\t\t\t\tcallbacks = Array.from( callbacks );\n\n\t\t\t\tfor ( let i = 0; i < callbacks.length; i++ ) {\n\t\t\t\t\tcallbacks[ i ].callback.apply( this, callbackArgs );\n\n\t\t\t\t\t// Remove the callback from future requests if off() has been called.\n\t\t\t\t\tif ( eventInfo.off.called ) {\n\t\t\t\t\t\t// Remove the called mark for the next calls.\n\t\t\t\t\t\tdelete eventInfo.off.called;\n\n\t\t\t\t\t\tthis._removeEventListener( event, callbacks[ i ].callback );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Do not execute next callbacks if stop() was called.\n\t\t\t\t\tif ( eventInfo.stop.called ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Delegate event to other emitters if needed.\n\t\t\tif ( this._delegations ) {\n\t\t\t\tconst destinations = this._delegations.get( event );\n\t\t\t\tconst passAllDestinations = this._delegations.get( '*' );\n\n\t\t\t\tif ( destinations ) {\n\t\t\t\t\tfireDelegatedEvents( destinations, eventInfo, args );\n\t\t\t\t}\n\n\t\t\t\tif ( passAllDestinations ) {\n\t\t\t\t\tfireDelegatedEvents( passAllDestinations, eventInfo, args );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn eventInfo.return;\n\t\t} catch ( err ) {\n\t\t\t// @if CK_DEBUG // throw err;\n\t\t\t/* istanbul ignore next */\n\t\t\tCKEditorError.rethrowUnexpectedError( err, this );\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdelegate( ...events ) {\n\t\treturn {\n\t\t\tto: ( emitter, nameOrFunction ) => {\n\t\t\t\tif ( !this._delegations ) {\n\t\t\t\t\tthis._delegations = new Map();\n\t\t\t\t}\n\n\t\t\t\t// Originally there was a for..of loop which unfortunately caused an error in Babel that didn't allow\n\t\t\t\t// build an application. See: https://github.com/ckeditor/ckeditor5-react/issues/40.\n\t\t\t\tevents.forEach( eventName => {\n\t\t\t\t\tconst destinations = this._delegations.get( eventName );\n\n\t\t\t\t\tif ( !destinations ) {\n\t\t\t\t\t\tthis._delegations.set( eventName, new Map( [ [ emitter, nameOrFunction ] ] ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestinations.set( emitter, nameOrFunction );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstopDelegating( event, emitter ) {\n\t\tif ( !this._delegations ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !event ) {\n\t\t\tthis._delegations.clear();\n\t\t} else if ( !emitter ) {\n\t\t\tthis._delegations.delete( event );\n\t\t} else {\n\t\t\tconst destinations = this._delegations.get( event );\n\n\t\t\tif ( destinations ) {\n\t\t\t\tdestinations.delete( emitter );\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_addEventListener( event, callback, options ) {\n\t\tcreateEventNamespace( this, event );\n\n\t\tconst lists = getCallbacksListsForNamespace( this, event );\n\t\tconst priority = priorities.get( options.priority );\n\n\t\tconst callbackDefinition = {\n\t\t\tcallback,\n\t\t\tpriority\n\t\t};\n\n\t\t// Add the callback to all callbacks list.\n\t\tfor ( const callbacks of lists ) {\n\t\t\t// Add the callback to the list in the right priority position.\n\t\t\tinsertToPriorityArray( callbacks, callbackDefinition );\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_removeEventListener( event, callback ) {\n\t\tconst lists = getCallbacksListsForNamespace( this, event );\n\n\t\tfor ( const callbacks of lists ) {\n\t\t\tfor ( let i = 0; i < callbacks.length; i++ ) {\n\t\t\t\tif ( callbacks[ i ].callback == callback ) {\n\t\t\t\t\t// Remove the callback from the list (fixing the next index).\n\t\t\t\t\tcallbacks.splice( i, 1 );\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nexport default EmitterMixin;\n\n/**\n * Emitter/listener interface.\n *\n * Can be easily implemented by a class by mixing the {@link module:utils/emittermixin~EmitterMixin} mixin.\n *\n * Read more about the usage of this interface in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide.\n * * {@glink framework/guides/deep-dive/event-system Event system} deep dive guide.\n *\n * @interface Emitter\n */\n\n/**\n * Registers a callback function to be executed when an event is fired.\n *\n * Shorthand for {@link #listenTo `this.listenTo( this, event, callback, options )`} (it makes the emitter\n * listen on itself).\n *\n * @method #on\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Registers a callback function to be executed on the next time the event is fired only. This is similar to\n * calling {@link #on} followed by {@link #off} in the callback.\n *\n * @method #once\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Stops executing the callback on the given event.\n * Shorthand for {@link #stopListening `this.stopListening( this, event, callback )`}.\n *\n * @method #off\n * @param {String} event The name of the event.\n * @param {Function} callback The function to stop being called.\n */\n\n/**\n * Registers a callback function to be executed when an event is fired in a specific (emitter) object.\n *\n * Events can be grouped in namespaces using `:`.\n * When namespaced event is fired, it additionally fires all callbacks for that namespace.\n *\n *\t\t// myEmitter.on( ... ) is a shorthand for myEmitter.listenTo( myEmitter, ... ).\n *\t\tmyEmitter.on( 'myGroup', genericCallback );\n *\t\tmyEmitter.on( 'myGroup:myEvent', specificCallback );\n *\n *\t\t// genericCallback is fired.\n *\t\tmyEmitter.fire( 'myGroup' );\n *\t\t// both genericCallback and specificCallback are fired.\n *\t\tmyEmitter.fire( 'myGroup:myEvent' );\n *\t\t// genericCallback is fired even though there are no callbacks for \"foo\".\n *\t\tmyEmitter.fire( 'myGroup:foo' );\n *\n * An event callback can {@link module:utils/eventinfo~EventInfo#stop stop the event} and\n * set the {@link module:utils/eventinfo~EventInfo#return return value} of the {@link #fire} method.\n *\n * @method #listenTo\n * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Stops listening for events. It can be used at different levels:\n *\n * * To stop listening to a specific callback.\n * * To stop listening to a specific event.\n * * To stop listening to all events fired by a specific object.\n * * To stop listening to all events fired by all objects.\n *\n * @method #stopListening\n * @param {module:utils/emittermixin~Emitter} [emitter] The object to stop listening to. If omitted, stops it for all objects.\n * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it\n * for all events from `emitter`.\n * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given\n * `event`.\n */\n\n/**\n * Fires an event, executing all callbacks registered for it.\n *\n * The first parameter passed to callbacks is an {@link module:utils/eventinfo~EventInfo} object,\n * followed by the optional `args` provided in the `fire()` method call.\n *\n * @method #fire\n * @param {String|module:utils/eventinfo~EventInfo} eventOrInfo The name of the event or `EventInfo` object if event is delegated.\n * @param {...*} [args] Additional arguments to be passed to the callbacks.\n * @returns {*} By default the method returns `undefined`. However, the return value can be changed by listeners\n * through modification of the {@link module:utils/eventinfo~EventInfo#return `evt.return`}'s property (the event info\n * is the first param of every callback).\n */\n\n/**\n * Delegates selected events to another {@link module:utils/emittermixin~Emitter}. For instance:\n *\n *\t\temitterA.delegate( 'eventX' ).to( emitterB );\n *\t\temitterA.delegate( 'eventX', 'eventY' ).to( emitterC );\n *\n * then `eventX` is delegated (fired by) `emitterB` and `emitterC` along with `data`:\n *\n *\t\temitterA.fire( 'eventX', data );\n *\n * and `eventY` is delegated (fired by) `emitterC` along with `data`:\n *\n *\t\temitterA.fire( 'eventY', data );\n *\n * @method #delegate\n * @param {...String} events Event names that will be delegated to another emitter.\n * @returns {module:utils/emittermixin~EmitterMixinDelegateChain}\n */\n\n/**\n * Stops delegating events. It can be used at different levels:\n *\n * * To stop delegating all events.\n * * To stop delegating a specific event to all emitters.\n * * To stop delegating a specific event to a specific emitter.\n *\n * @method #stopDelegating\n * @param {String} [event] The name of the event to stop delegating. If omitted, stops it all delegations.\n * @param {module:utils/emittermixin~Emitter} [emitter] (requires `event`) The object to stop delegating a particular event to.\n * If omitted, stops delegation of `event` to all emitters.\n */\n\n/**\n * Adds callback to emitter for given event.\n *\n * @protected\n * @method #_addEventListener\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Removes callback from emitter for given event.\n *\n * @protected\n * @method #_removeEventListener\n * @param {String} event The name of the event.\n * @param {Function} callback The function to stop being called.\n */\n\n/**\n * Checks if `listeningEmitter` listens to an emitter with given `listenedToEmitterId` and if so, returns that emitter.\n * If not, returns `null`.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} listeningEmitter An emitter that listens.\n * @param {String} listenedToEmitterId Unique emitter id of emitter listened to.\n * @returns {module:utils/emittermixin~Emitter|null}\n */\nexport function _getEmitterListenedTo( listeningEmitter, listenedToEmitterId ) {\n\tif ( listeningEmitter[ _listeningTo ] && listeningEmitter[ _listeningTo ][ listenedToEmitterId ] ) {\n\t\treturn listeningEmitter[ _listeningTo ][ listenedToEmitterId ].emitter;\n\t}\n\n\treturn null;\n}\n\n/**\n * Sets emitter's unique id.\n *\n * **Note:** `_emitterId` can be set only once.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter for which id will be set.\n * @param {String} [id] Unique id to set. If not passed, random unique id will be set.\n */\nexport function _setEmitterId( emitter, id ) {\n\tif ( !emitter[ _emitterId ] ) {\n\t\temitter[ _emitterId ] = id || uid();\n\t}\n}\n\n/**\n * Returns emitter's unique id.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter which id will be returned.\n */\nexport function _getEmitterId( emitter ) {\n\treturn emitter[ _emitterId ];\n}\n\n// Gets the internal `_events` property of the given object.\n// `_events` property store all lists with callbacks for registered event names.\n// If there were no events registered on the object, empty `_events` object is created.\nfunction getEvents( source ) {\n\tif ( !source._events ) {\n\t\tObject.defineProperty( source, '_events', {\n\t\t\tvalue: {}\n\t\t} );\n\t}\n\n\treturn source._events;\n}\n\n// Creates event node for generic-specific events relation architecture.\nfunction makeEventNode() {\n\treturn {\n\t\tcallbacks: [],\n\t\tchildEvents: []\n\t};\n}\n\n// Creates an architecture for generic-specific events relation.\n// If needed, creates all events for given eventName, i.e. if the first registered event\n// is foo:bar:abc, it will create foo:bar:abc, foo:bar and foo event and tie them together.\n// It also copies callbacks from more generic events to more specific events when\n// specific events are created.\nfunction createEventNamespace( source, eventName ) {\n\tconst events = getEvents( source );\n\n\t// First, check if the event we want to add to the structure already exists.\n\tif ( events[ eventName ] ) {\n\t\t// If it exists, we don't have to do anything.\n\t\treturn;\n\t}\n\n\t// In other case, we have to create the structure for the event.\n\t// Note, that we might need to create intermediate events too.\n\t// I.e. if foo:bar:abc is being registered and we only have foo in the structure,\n\t// we need to also register foo:bar.\n\n\t// Currently processed event name.\n\tlet name = eventName;\n\t// Name of the event that is a child event for currently processed event.\n\tlet childEventName = null;\n\n\t// Array containing all newly created specific events.\n\tconst newEventNodes = [];\n\n\t// While loop can't check for ':' index because we have to handle generic events too.\n\t// In each loop, we truncate event name, going from the most specific name to the generic one.\n\t// I.e. foo:bar:abc -> foo:bar -> foo.\n\twhile ( name !== '' ) {\n\t\tif ( events[ name ] ) {\n\t\t\t// If the currently processed event name is already registered, we can be sure\n\t\t\t// that it already has all the structure created, so we can break the loop here\n\t\t\t// as no more events need to be registered.\n\t\t\tbreak;\n\t\t}\n\n\t\t// If this event is not yet registered, create a new object for it.\n\t\tevents[ name ] = makeEventNode();\n\t\t// Add it to the array with newly created events.\n\t\tnewEventNodes.push( events[ name ] );\n\n\t\t// Add previously processed event name as a child of this event.\n\t\tif ( childEventName ) {\n\t\t\tevents[ name ].childEvents.push( childEventName );\n\t\t}\n\n\t\tchildEventName = name;\n\t\t// If `.lastIndexOf()` returns -1, `.substr()` will return '' which will break the loop.\n\t\tname = name.substr( 0, name.lastIndexOf( ':' ) );\n\t}\n\n\tif ( name !== '' ) {\n\t\t// If name is not empty, we found an already registered event that was a parent of the\n\t\t// event we wanted to register.\n\n\t\t// Copy that event's callbacks to newly registered events.\n\t\tfor ( const node of newEventNodes ) {\n\t\t\tnode.callbacks = events[ name ].callbacks.slice();\n\t\t}\n\n\t\t// Add last newly created event to the already registered event.\n\t\tevents[ name ].childEvents.push( childEventName );\n\t}\n}\n\n// Gets an array containing callbacks list for a given event and it's more specific events.\n// I.e. if given event is foo:bar and there is also foo:bar:abc event registered, this will\n// return callback list of foo:bar and foo:bar:abc (but not foo).\nfunction getCallbacksListsForNamespace( source, eventName ) {\n\tconst eventNode = getEvents( source )[ eventName ];\n\n\tif ( !eventNode ) {\n\t\treturn [];\n\t}\n\n\tlet callbacksLists = [ eventNode.callbacks ];\n\n\tfor ( let i = 0; i < eventNode.childEvents.length; i++ ) {\n\t\tconst childCallbacksLists = getCallbacksListsForNamespace( source, eventNode.childEvents[ i ] );\n\n\t\tcallbacksLists = callbacksLists.concat( childCallbacksLists );\n\t}\n\n\treturn callbacksLists;\n}\n\n// Get the list of callbacks for a given event, but only if there any callbacks have been registered.\n// If there are no callbacks registered for given event, it checks if this is a specific event and looks\n// for callbacks for it's more generic version.\nfunction getCallbacksForEvent( source, eventName ) {\n\tlet event;\n\n\tif ( !source._events || !( event = source._events[ eventName ] ) || !event.callbacks.length ) {\n\t\t// There are no callbacks registered for specified eventName.\n\t\t// But this could be a specific-type event that is in a namespace.\n\t\tif ( eventName.indexOf( ':' ) > -1 ) {\n\t\t\t// If the eventName is specific, try to find callback lists for more generic event.\n\t\t\treturn getCallbacksForEvent( source, eventName.substr( 0, eventName.lastIndexOf( ':' ) ) );\n\t\t} else {\n\t\t\t// If this is a top-level generic event, return null;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn event.callbacks;\n}\n\n// Fires delegated events for given map of destinations.\n//\n// @private\n// * @param {Map.<utils.Emitter>} destinations A map containing\n// `[ {@link module:utils/emittermixin~Emitter}, \"event name\" ]` pair destinations.\n// * @param {utils.EventInfo} eventInfo The original event info object.\n// * @param {Array.<*>} fireArgs Arguments the original event was fired with.\nfunction fireDelegatedEvents( destinations, eventInfo, fireArgs ) {\n\tfor ( let [ emitter, name ] of destinations ) {\n\t\tif ( !name ) {\n\t\t\tname = eventInfo.name;\n\t\t} else if ( typeof name == 'function' ) {\n\t\t\tname = name( eventInfo.name );\n\t\t}\n\n\t\tconst delegatedInfo = new EventInfo( eventInfo.source, name );\n\n\t\tdelegatedInfo.path = [ ...eventInfo.path ];\n\n\t\temitter.fire( delegatedInfo, ...fireArgs );\n\t}\n}\n\n// Helper for registering event callback on the emitter.\nfunction addEventListener( listener, emitter, event, callback, options ) {\n\tif ( emitter._addEventListener ) {\n\t\temitter._addEventListener( event, callback, options );\n\t} else {\n\t\t// Allow listening on objects that do not implement Emitter interface.\n\t\t// This is needed in some tests that are using mocks instead of the real objects with EmitterMixin mixed.\n\t\tlistener._addEventListener.call( emitter, event, callback, options );\n\t}\n}\n\n// Helper for removing event callback from the emitter.\nfunction removeEventListener( listener, emitter, event, callback ) {\n\tif ( emitter._removeEventListener ) {\n\t\temitter._removeEventListener( event, callback );\n\t} else {\n\t\t// Allow listening on objects that do not implement Emitter interface.\n\t\t// This is needed in some tests that are using mocks instead of the real objects with EmitterMixin mixed.\n\t\tlistener._removeEventListener.call( emitter, event, callback );\n\t}\n}\n\n/**\n * The return value of {@link ~EmitterMixin#delegate}.\n *\n * @interface module:utils/emittermixin~EmitterMixinDelegateChain\n */\n\n/**\n * Selects destination for {@link module:utils/emittermixin~EmitterMixin#delegate} events.\n *\n * @method #to\n * @param {module:utils/emittermixin~Emitter} emitter An `EmitterMixin` instance which is the destination for delegated events.\n * @param {String|Function} [nameOrFunction] A custom event name or function which converts the original name string.\n */\n"],"mappings":"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AAGvE,UAAU,CAACkD,GAAX,CAAgBxC,OAAO,CAAC6D,QAAxB,CAAjB;IAEA,MAAMC,kBAAkB,GAAG;MAC1B/D,QAD0B;MAE1B8D;IAF0B,CAA3B,CAN6C,CAW7C;;IACA,KAAM,MAAM7C,SAAZ,IAAyB2C,KAAzB,EAAiC;MAChC;MACApE,qBAAqB,CAAEyB,SAAF,EAAa8C,kBAAb,CAArB;IACA;EACD,CA/QmB;;EAiRpB;AACD;AACA;EACC1B,oBAAoB,CAAEtC,KAAF,EAASC,QAAT,EAAoB;IACvC,MAAM4D,KAAK,GAAGC,6BAA6B,CAAE,IAAF,EAAQ9D,KAAR,CAA3C;;IAEA,KAAM,MAAMkB,SAAZ,IAAyB2C,KAAzB,EAAiC;MAChC,KAAM,IAAI1B,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGjB,SAAS,CAACM,MAA/B,EAAuCW,CAAC,EAAxC,EAA6C;QAC5C,IAAKjB,SAAS,CAAEiB,CAAF,CAAT,CAAelC,QAAf,IAA2BA,QAAhC,EAA2C;UAC1C;UACAiB,SAAS,CAAC+C,MAAV,CAAkB9B,CAAlB,EAAqB,CAArB;UACAA,CAAC;QACD;MACD;IACD;EACD;;AAhSmB,CAArB;AAmSA,eAAerC,YAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA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"},"metadata":{},"sourceType":"module"}