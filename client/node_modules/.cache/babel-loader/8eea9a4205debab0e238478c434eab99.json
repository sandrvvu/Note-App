{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\nimport LivePosition from '../liveposition';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x</paragraph>[]` with the option enabled (`doNotAutoparagraph == true`).\n *\n * If you use this option you need to make sure to handle invalid selections yourself or leave\n * them to the selection post-fixer (may not always work).\n *\n * **Note:** If there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n */\n\nexport default function deleteContent(model, selection) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (selection.isCollapsed) {\n    return;\n  }\n\n  const selRange = selection.getFirstRange(); // If the selection is already removed, don't do anything.\n\n  if (selRange.root.rootName == '$graveyard') {\n    return;\n  }\n\n  const schema = model.schema;\n  model.change(writer => {\n    // 1. Replace the entire content with paragraph.\n    // See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n    if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {\n      replaceEntireContentWithParagraph(writer, selection, schema);\n      return;\n    } // Collect attributes to copy in case of autoparagraphing.\n\n\n    const attributesForAutoparagraph = {};\n\n    if (!options.doNotAutoparagraph) {\n      const selectedElement = selection.getSelectedElement();\n\n      if (selectedElement) {\n        Object.assign(attributesForAutoparagraph, schema.getAttributesWithProperty(selectedElement, 'copyOnReplace', true));\n      }\n    } // Get the live positions for the range adjusted to span only blocks selected from the user perspective.\n\n\n    const [startPosition, endPosition] = getLivePositionsForSelectedBlocks(selRange); // 2. Remove the content if there is any.\n\n    if (!startPosition.isTouching(endPosition)) {\n      writer.remove(writer.createRange(startPosition, endPosition));\n    } // 3. Merge elements in the right branch to the elements in the left branch.\n    // The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n    //\n    // <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n    //\n    // However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n    // as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n    // want to override that behavior anyway.\n\n\n    if (!options.leaveUnmerged) {\n      mergeBranches(writer, startPosition, endPosition); // TMP this will be replaced with a postfixer.\n      // We need to check and strip disallowed attributes in all nested nodes because after merge\n      // some attributes could end up in a path where are disallowed.\n      //\n      // e.g. bold is disallowed for <H1>\n      // <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\n      schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);\n    }\n\n    collapseSelectionAt(writer, selection, startPosition); // 4. Add a paragraph to set selection in it.\n    // Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n    // If autoparagraphing is off, we assume that you know what you do so we leave the selection wherever it was.\n\n    if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {\n      insertParagraph(writer, startPosition, selection, attributesForAutoparagraph);\n    }\n\n    startPosition.detach();\n    endPosition.detach();\n  });\n} // Returns the live positions for the range adjusted to span only blocks selected from the user perspective. Example:\n//\n//     <heading1>[foo</heading1>\n//     <paragraph>bar</paragraph>\n//     <heading1>]abc</heading1>  <-- this block is not considered as selected\n//\n// This is the same behavior as in Selection#getSelectedBlocks() \"special case\".\n\nfunction getLivePositionsForSelectedBlocks(range) {\n  const model = range.root.document.model;\n  const startPosition = range.start;\n  let endPosition = range.end; // If the end of selection is at the start position of last block in the selection, then\n  // shrink it to not include that trailing block. Note that this should happen only for not empty selection.\n\n  if (model.hasContent(range, {\n    ignoreMarkers: true\n  })) {\n    const endBlock = getParentBlock(endPosition);\n\n    if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {\n      // Create forward selection as a probe to find a valid position after excluding last block from the range.\n      const selection = model.createSelection(range); // Modify the forward selection in backward direction to shrink it and remove first position of following block from it.\n      // This is how modifySelection works and here we are making use of it.\n\n      model.modifySelection(selection, {\n        direction: 'backward'\n      });\n      const newEndPosition = selection.getLastPosition(); // For such a model and selection:\n      //     <paragraph>A[</paragraph><imageBlock></imageBlock><paragraph>]B</paragraph>\n      //\n      // After modifySelection(), we would end up with this:\n      //     <paragraph>A[</paragraph>]<imageBlock></imageBlock><paragraph>B</paragraph>\n      //\n      // So we need to check if there is no content in the skipped range (because we want to include the <imageBlock>).\n\n      const skippedRange = model.createRange(newEndPosition, endPosition);\n\n      if (!model.hasContent(skippedRange, {\n        ignoreMarkers: true\n      })) {\n        endPosition = newEndPosition;\n      }\n    }\n  }\n\n  return [LivePosition.fromPosition(startPosition, 'toPrevious'), LivePosition.fromPosition(endPosition, 'toNext')];\n} // Finds the lowest element in position's ancestors which is a block.\n// Returns null if a limit element is encountered before reaching a block element.\n\n\nfunction getParentBlock(position) {\n  const element = position.parent;\n  const schema = element.root.document.model.schema;\n  const ancestors = element.getAncestors({\n    parentFirst: true,\n    includeSelf: true\n  });\n\n  for (const element of ancestors) {\n    if (schema.isLimit(element)) {\n      return null;\n    }\n\n    if (schema.isBlock(element)) {\n      return element;\n    }\n  }\n} // This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\n\n\nfunction mergeBranches(writer, startPosition, endPosition) {\n  const model = writer.model; // Verify if there is a need and possibility to merge.\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // If the start element on the common ancestor level is empty, and the end element on the same level is not empty\n  // then merge those to the right element so that it's properties are preserved (name, attributes).\n  // Because of OT merging is used instead of removing elements.\n  //\n  // Merge left:\n  //     <heading1>foo[</heading1>    ->  <heading1>foo[]bar</heading1>\n  //     <paragraph>]bar</paragraph>  ->               --^\n  //\n  // Merge right:\n  //     <heading1>[</heading1>       ->\n  //     <paragraph>]bar</paragraph>  ->  <paragraph>[]bar</paragraph>\n  //\n  // Merge left:\n  //     <blockQuote>                     ->  <blockQuote>\n  //         <heading1>foo[</heading1>    ->      <heading1>foo[]bar</heading1>\n  //         <paragraph>]bar</paragraph>  ->                   --^\n  //     </blockQuote>                    ->  </blockQuote>\n  //\n  // Merge right:\n  //     <blockQuote>                     ->  <blockQuote>\n  //         <heading1>[</heading1>       ->\n  //         <paragraph>]bar</paragraph>  ->      <paragraph>[]bar</paragraph>\n  //     </blockQuote>                    ->  </blockQuote>\n  // Merging should not go deeper than common ancestor.\n\n\n  const [startAncestor, endAncestor] = getAncestorsJustBelowCommonAncestor(startPosition, endPosition); // Branches can't be merged if one of the positions is directly inside a common ancestor.\n  //\n  // Example:\n  //     <blockQuote>\n  //         <paragraph>[foo</paragraph>]\n  //         <table> ... </table>\n  //     <blockQuote>\n  //\n\n  if (!startAncestor || !endAncestor) {\n    return;\n  }\n\n  if (!model.hasContent(startAncestor, {\n    ignoreMarkers: true\n  }) && model.hasContent(endAncestor, {\n    ignoreMarkers: true\n  })) {\n    mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);\n  } else {\n    mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);\n  }\n} // Merging blocks to the left (properties of the left block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->  <heading1>foo[bar</heading1>]\n//     <paragraph>]bar</paragraph>  ->              --^\n//\n// Nested example:\n//     <blockQuote>                     ->  <blockQuote>\n//         <heading1>foo[</heading1>    ->      <heading1>foo[bar</heading1>\n//     </blockQuote>                    ->  </blockQuote>]    ^\n//     <blockBlock>                     ->                    |\n//         <paragraph>]bar</paragraph>  ->                 ---\n//     </blockBlock>                    ->\n//\n\n\nfunction mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent; // Merging reached the common ancestor element, stop here.\n\n  if (startElement == commonAncestor || endElement == commonAncestor) {\n    return;\n  } // Remember next positions to merge in next recursive step (also used as modification points pointers).\n\n\n  startPosition = writer.createPositionAfter(startElement);\n  endPosition = writer.createPositionBefore(endElement); // Move endElement just after startElement if they aren't siblings.\n\n  if (!endPosition.isEqual(startPosition)) {\n    //\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>foo[</heading1>    ->      <heading1>foo</heading1>[<paragraph>bar</paragraph>\n    //     </blockQuote>                    ->  </blockQuote>                ^\n    //     <blockBlock>                     ->  <blockBlock>                 |\n    //         <paragraph>]bar</paragraph>  ->      ]                     ---\n    //     </blockBlock>                    ->  </blockBlock>\n    //\n    writer.insert(endElement, startPosition);\n  } // Merge two siblings (nodes on sides of startPosition):\n  //\n  //     <blockQuote>                                             ->  <blockQuote>\n  //         <heading1>foo</heading1>[<paragraph>bar</paragraph>  ->      <heading1>foo[bar</heading1>\n  //     </blockQuote>                                            ->  </blockQuote>\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         ]                                                    ->      ]\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n  // Or in simple case (without moving elements in above if):\n  //     <heading1>foo</heading1>[<paragraph>bar</paragraph>]  ->  <heading1>foo[bar</heading1>]\n  //\n\n\n  writer.merge(startPosition); // Remove empty end ancestors:\n  //\n  //     <blockQuote>                      ->  <blockQuote>\n  //         <heading1>foo[bar</heading1>  ->      <heading1>foo[bar</heading1>\n  //     </blockQuote>                     ->  </blockQuote>\n  //     <blockBlock>                      ->\n  //         ]                             ->  ]\n  //     </blockBlock>                     ->\n  //\n\n  while (endPosition.parent.isEmpty) {\n    const parentToRemove = endPosition.parent;\n    endPosition = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  } // Verify if there is a need and possibility to merge next level.\n\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\n\n  mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);\n} // Merging blocks to the right (properties of the right block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->            --v\n//     <paragraph>]bar</paragraph>  ->  [<paragraph>foo]bar</paragraph>\n//\n// Nested example:\n//     <blockQuote>                     ->\n//         <heading1>foo[</heading1>    ->              ---\n//     </blockQuote>                    ->                 |\n//     <blockBlock>                     ->  [<blockBlock>  v\n//         <paragraph>]bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n//     </blockBlock>                    ->  </blockBlock>\n//\n\n\nfunction mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent; // Merging reached the common ancestor element, stop here.\n\n  if (startElement == commonAncestor || endElement == commonAncestor) {\n    return;\n  } // Remember next positions to merge in next recursive step (also used as modification points pointers).\n\n\n  startPosition = writer.createPositionAfter(startElement);\n  endPosition = writer.createPositionBefore(endElement); // Move startElement just before endElement if they aren't siblings.\n\n  if (!endPosition.isEqual(startPosition)) {\n    //\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>foo[</heading1>    ->      [                   ---\n    //     </blockQuote>                    ->  </blockQuote>              |\n    //     <blockBlock>                     ->  <blockBlock>               v\n    //         <paragraph>]bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n    //     </blockBlock>                    ->  </blockBlock>\n    //\n    writer.insert(startElement, endPosition);\n  } // Remove empty end ancestors:\n  //\n  //     <blockQuote>                                             ->\n  //         [                                                    ->  [\n  //     </blockQuote>                                            ->\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n\n\n  while (startPosition.parent.isEmpty) {\n    const parentToRemove = startPosition.parent;\n    startPosition = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  } // Update endPosition after inserting and removing elements.\n\n\n  endPosition = writer.createPositionBefore(endElement); // Merge right two siblings (nodes on sides of endPosition):\n  //                                                              ->\n  //     [                                                        ->  [\n  //                                                              ->\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n  // Or in simple case (without moving elements in above if):\n  //     [<heading1>foo</heading1>]<paragraph>bar</paragraph>  ->  [<heading1>foo]bar</heading1>\n  //\n\n  mergeRight(writer, endPosition); // Verify if there is a need and possibility to merge next level.\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\n\n  mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);\n} // There is no right merge operation so we need to simulate it.\n\n\nfunction mergeRight(writer, position) {\n  const startElement = position.nodeBefore;\n  const endElement = position.nodeAfter;\n\n  if (startElement.name != endElement.name) {\n    writer.rename(startElement, endElement.name);\n  }\n\n  writer.clearAttributes(startElement);\n  writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);\n  writer.merge(position);\n} // Verifies if merging is needed and possible. It's not needed if both positions are in the same element\n// and it's not possible if some element is a limit or the range crosses a limit element.\n\n\nfunction checkShouldMerge(schema, startPosition, endPosition) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent; // If both positions ended up in the same parent, then there's nothing more to merge:\n  // <$root><p>x[</p><p>]y</p></$root> => <$root><p>xy</p>[]</$root>\n\n  if (startElement == endElement) {\n    return false;\n  } // If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n\n\n  if (schema.isLimit(startElement) || schema.isLimit(endElement)) {\n    return false;\n  } // Check if operations we'll need to do won't need to cross object or limit boundaries.\n  // E.g., we can't merge endElement into startElement in this case:\n  // <limit><startElement>x[</startElement></limit><endElement>]</endElement>\n\n\n  return isCrossingLimitElement(startPosition, endPosition, schema);\n} // Returns the elements that are the ancestors of the provided positions that are direct children of the common ancestor.\n\n\nfunction getAncestorsJustBelowCommonAncestor(positionA, positionB) {\n  const ancestorsA = positionA.getAncestors();\n  const ancestorsB = positionB.getAncestors();\n  let i = 0;\n\n  while (ancestorsA[i] && ancestorsA[i] == ancestorsB[i]) {\n    i++;\n  }\n\n  return [ancestorsA[i], ancestorsB[i]];\n}\n\nfunction shouldAutoparagraph(schema, position) {\n  const isTextAllowed = schema.checkChild(position, '$text');\n  const isParagraphAllowed = schema.checkChild(position, 'paragraph');\n  return !isTextAllowed && isParagraphAllowed;\n} // Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\n\n\nfunction isCrossingLimitElement(leftPos, rightPos, schema) {\n  const rangeToCheck = new Range(leftPos, rightPos);\n\n  for (const value of rangeToCheck.getWalker()) {\n    if (schema.isLimit(value.item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction insertParagraph(writer, position, selection) {\n  let attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const paragraph = writer.createElement('paragraph');\n  writer.model.schema.setAllowedAttributes(paragraph, attributes, writer);\n  writer.insert(paragraph, position);\n  collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph, 0));\n}\n\nfunction replaceEntireContentWithParagraph(writer, selection) {\n  const limitElement = writer.model.schema.getLimitElement(selection);\n  writer.remove(writer.createRangeIn(limitElement));\n  insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);\n} // We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\n\n\nfunction shouldEntireContentBeReplacedWithParagraph(schema, selection) {\n  const limitElement = schema.getLimitElement(selection);\n\n  if (!selection.containsEntireContent(limitElement)) {\n    return false;\n  }\n\n  const range = selection.getFirstRange();\n\n  if (range.start.parent == range.end.parent) {\n    return false;\n  }\n\n  return schema.checkChild(limitElement, 'paragraph');\n} // Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\n\n\nfunction collapseSelectionAt(writer, selection, positionOrRange) {\n  if (selection instanceof DocumentSelection) {\n    writer.setSelection(positionOrRange);\n  } else {\n    selection.setTo(positionOrRange);\n  }\n}","map":{"version":3,"names":["LivePosition","Range","DocumentSelection","deleteContent","model","selection","options","isCollapsed","selRange","getFirstRange","root","rootName","schema","change","writer","doNotResetEntireContent","shouldEntireContentBeReplacedWithParagraph","replaceEntireContentWithParagraph","attributesForAutoparagraph","doNotAutoparagraph","selectedElement","getSelectedElement","Object","assign","getAttributesWithProperty","startPosition","endPosition","getLivePositionsForSelectedBlocks","isTouching","remove","createRange","leaveUnmerged","mergeBranches","removeDisallowedAttributes","parent","getChildren","collapseSelectionAt","shouldAutoparagraph","insertParagraph","detach","range","document","start","end","hasContent","ignoreMarkers","endBlock","getParentBlock","createPositionAt","createSelection","modifySelection","direction","newEndPosition","getLastPosition","skippedRange","fromPosition","position","element","ancestors","getAncestors","parentFirst","includeSelf","isLimit","isBlock","checkShouldMerge","startAncestor","endAncestor","getAncestorsJustBelowCommonAncestor","mergeBranchesRight","mergeBranchesLeft","commonAncestor","startElement","endElement","createPositionAfter","createPositionBefore","isEqual","insert","merge","isEmpty","parentToRemove","mergeRight","nodeBefore","nodeAfter","name","rename","clearAttributes","setAttributes","fromEntries","getAttributes","isCrossingLimitElement","positionA","positionB","ancestorsA","ancestorsB","i","isTextAllowed","checkChild","isParagraphAllowed","leftPos","rightPos","rangeToCheck","value","getWalker","item","attributes","paragraph","createElement","setAllowedAttributes","limitElement","getLimitElement","createRangeIn","containsEntireContent","positionOrRange","setSelection","setTo"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\n\nimport LivePosition from '../liveposition';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\n\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x</paragraph>[]` with the option enabled (`doNotAutoparagraph == true`).\n *\n * If you use this option you need to make sure to handle invalid selections yourself or leave\n * them to the selection post-fixer (may not always work).\n *\n * **Note:** If there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n */\nexport default function deleteContent( model, selection, options = {} ) {\n\tif ( selection.isCollapsed ) {\n\t\treturn;\n\t}\n\n\tconst selRange = selection.getFirstRange();\n\n\t// If the selection is already removed, don't do anything.\n\tif ( selRange.root.rootName == '$graveyard' ) {\n\t\treturn;\n\t}\n\n\tconst schema = model.schema;\n\n\tmodel.change( writer => {\n\t\t// 1. Replace the entire content with paragraph.\n\t\t// See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n\t\tif ( !options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph( schema, selection ) ) {\n\t\t\treplaceEntireContentWithParagraph( writer, selection, schema );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Collect attributes to copy in case of autoparagraphing.\n\t\tconst attributesForAutoparagraph = {};\n\n\t\tif ( !options.doNotAutoparagraph ) {\n\t\t\tconst selectedElement = selection.getSelectedElement();\n\n\t\t\tif ( selectedElement ) {\n\t\t\t\tObject.assign( attributesForAutoparagraph, schema.getAttributesWithProperty( selectedElement, 'copyOnReplace', true ) );\n\t\t\t}\n\t\t}\n\n\t\t// Get the live positions for the range adjusted to span only blocks selected from the user perspective.\n\t\tconst [ startPosition, endPosition ] = getLivePositionsForSelectedBlocks( selRange );\n\n\t\t// 2. Remove the content if there is any.\n\t\tif ( !startPosition.isTouching( endPosition ) ) {\n\t\t\twriter.remove( writer.createRange( startPosition, endPosition ) );\n\t\t}\n\n\t\t// 3. Merge elements in the right branch to the elements in the left branch.\n\t\t// The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n\t\t//\n\t\t// <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n\t\t//\n\t\t// However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n\t\t// as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n\t\t// want to override that behavior anyway.\n\t\tif ( !options.leaveUnmerged ) {\n\t\t\tmergeBranches( writer, startPosition, endPosition );\n\n\t\t\t// TMP this will be replaced with a postfixer.\n\t\t\t// We need to check and strip disallowed attributes in all nested nodes because after merge\n\t\t\t// some attributes could end up in a path where are disallowed.\n\t\t\t//\n\t\t\t// e.g. bold is disallowed for <H1>\n\t\t\t// <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\t\t\tschema.removeDisallowedAttributes( startPosition.parent.getChildren(), writer );\n\t\t}\n\n\t\tcollapseSelectionAt( writer, selection, startPosition );\n\n\t\t// 4. Add a paragraph to set selection in it.\n\t\t// Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n\t\t// If autoparagraphing is off, we assume that you know what you do so we leave the selection wherever it was.\n\t\tif ( !options.doNotAutoparagraph && shouldAutoparagraph( schema, startPosition ) ) {\n\t\t\tinsertParagraph( writer, startPosition, selection, attributesForAutoparagraph );\n\t\t}\n\n\t\tstartPosition.detach();\n\t\tendPosition.detach();\n\t} );\n}\n\n// Returns the live positions for the range adjusted to span only blocks selected from the user perspective. Example:\n//\n//     <heading1>[foo</heading1>\n//     <paragraph>bar</paragraph>\n//     <heading1>]abc</heading1>  <-- this block is not considered as selected\n//\n// This is the same behavior as in Selection#getSelectedBlocks() \"special case\".\nfunction getLivePositionsForSelectedBlocks( range ) {\n\tconst model = range.root.document.model;\n\n\tconst startPosition = range.start;\n\tlet endPosition = range.end;\n\n\t// If the end of selection is at the start position of last block in the selection, then\n\t// shrink it to not include that trailing block. Note that this should happen only for not empty selection.\n\tif ( model.hasContent( range, { ignoreMarkers: true } ) ) {\n\t\tconst endBlock = getParentBlock( endPosition );\n\n\t\tif ( endBlock && endPosition.isTouching( model.createPositionAt( endBlock, 0 ) ) ) {\n\t\t\t// Create forward selection as a probe to find a valid position after excluding last block from the range.\n\t\t\tconst selection = model.createSelection( range );\n\n\t\t\t// Modify the forward selection in backward direction to shrink it and remove first position of following block from it.\n\t\t\t// This is how modifySelection works and here we are making use of it.\n\t\t\tmodel.modifySelection( selection, { direction: 'backward' } );\n\n\t\t\tconst newEndPosition = selection.getLastPosition();\n\n\t\t\t// For such a model and selection:\n\t\t\t//     <paragraph>A[</paragraph><imageBlock></imageBlock><paragraph>]B</paragraph>\n\t\t\t//\n\t\t\t// After modifySelection(), we would end up with this:\n\t\t\t//     <paragraph>A[</paragraph>]<imageBlock></imageBlock><paragraph>B</paragraph>\n\t\t\t//\n\t\t\t// So we need to check if there is no content in the skipped range (because we want to include the <imageBlock>).\n\t\t\tconst skippedRange = model.createRange( newEndPosition, endPosition );\n\n\t\t\tif ( !model.hasContent( skippedRange, { ignoreMarkers: true } ) ) {\n\t\t\t\tendPosition = newEndPosition;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [\n\t\tLivePosition.fromPosition( startPosition, 'toPrevious' ),\n\t\tLivePosition.fromPosition( endPosition, 'toNext' )\n\t];\n}\n\n// Finds the lowest element in position's ancestors which is a block.\n// Returns null if a limit element is encountered before reaching a block element.\nfunction getParentBlock( position ) {\n\tconst element = position.parent;\n\tconst schema = element.root.document.model.schema;\n\tconst ancestors = element.getAncestors( { parentFirst: true, includeSelf: true } );\n\n\tfor ( const element of ancestors ) {\n\t\tif ( schema.isLimit( element ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( schema.isBlock( element ) ) {\n\t\t\treturn element;\n\t\t}\n\t}\n}\n\n// This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\nfunction mergeBranches( writer, startPosition, endPosition ) {\n\tconst model = writer.model;\n\n\t// Verify if there is a need and possibility to merge.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// If the start element on the common ancestor level is empty, and the end element on the same level is not empty\n\t// then merge those to the right element so that it's properties are preserved (name, attributes).\n\t// Because of OT merging is used instead of removing elements.\n\t//\n\t// Merge left:\n\t//     <heading1>foo[</heading1>    ->  <heading1>foo[]bar</heading1>\n\t//     <paragraph>]bar</paragraph>  ->               --^\n\t//\n\t// Merge right:\n\t//     <heading1>[</heading1>       ->\n\t//     <paragraph>]bar</paragraph>  ->  <paragraph>[]bar</paragraph>\n\t//\n\t// Merge left:\n\t//     <blockQuote>                     ->  <blockQuote>\n\t//         <heading1>foo[</heading1>    ->      <heading1>foo[]bar</heading1>\n\t//         <paragraph>]bar</paragraph>  ->                   --^\n\t//     </blockQuote>                    ->  </blockQuote>\n\t//\n\t// Merge right:\n\t//     <blockQuote>                     ->  <blockQuote>\n\t//         <heading1>[</heading1>       ->\n\t//         <paragraph>]bar</paragraph>  ->      <paragraph>[]bar</paragraph>\n\t//     </blockQuote>                    ->  </blockQuote>\n\n\t// Merging should not go deeper than common ancestor.\n\tconst [ startAncestor, endAncestor ] = getAncestorsJustBelowCommonAncestor( startPosition, endPosition );\n\n\t// Branches can't be merged if one of the positions is directly inside a common ancestor.\n\t//\n\t// Example:\n\t//     <blockQuote>\n\t//         <paragraph>[foo</paragraph>]\n\t//         <table> ... </table>\n\t//     <blockQuote>\n\t//\n\tif ( !startAncestor || !endAncestor ) {\n\t\treturn;\n\t}\n\n\tif ( !model.hasContent( startAncestor, { ignoreMarkers: true } ) && model.hasContent( endAncestor, { ignoreMarkers: true } ) ) {\n\t\tmergeBranchesRight( writer, startPosition, endPosition, startAncestor.parent );\n\t} else {\n\t\tmergeBranchesLeft( writer, startPosition, endPosition, startAncestor.parent );\n\t}\n}\n\n// Merging blocks to the left (properties of the left block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->  <heading1>foo[bar</heading1>]\n//     <paragraph>]bar</paragraph>  ->              --^\n//\n// Nested example:\n//     <blockQuote>                     ->  <blockQuote>\n//         <heading1>foo[</heading1>    ->      <heading1>foo[bar</heading1>\n//     </blockQuote>                    ->  </blockQuote>]    ^\n//     <blockBlock>                     ->                    |\n//         <paragraph>]bar</paragraph>  ->                 ---\n//     </blockBlock>                    ->\n//\nfunction mergeBranchesLeft( writer, startPosition, endPosition, commonAncestor ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// Merging reached the common ancestor element, stop here.\n\tif ( startElement == commonAncestor || endElement == commonAncestor ) {\n\t\treturn;\n\t}\n\n\t// Remember next positions to merge in next recursive step (also used as modification points pointers).\n\tstartPosition = writer.createPositionAfter( startElement );\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Move endElement just after startElement if they aren't siblings.\n\tif ( !endPosition.isEqual( startPosition ) ) {\n\t\t//\n\t\t//     <blockQuote>                     ->  <blockQuote>\n\t\t//         <heading1>foo[</heading1>    ->      <heading1>foo</heading1>[<paragraph>bar</paragraph>\n\t\t//     </blockQuote>                    ->  </blockQuote>                ^\n\t\t//     <blockBlock>                     ->  <blockBlock>                 |\n\t\t//         <paragraph>]bar</paragraph>  ->      ]                     ---\n\t\t//     </blockBlock>                    ->  </blockBlock>\n\t\t//\n\t\twriter.insert( endElement, startPosition );\n\t}\n\n\t// Merge two siblings (nodes on sides of startPosition):\n\t//\n\t//     <blockQuote>                                             ->  <blockQuote>\n\t//         <heading1>foo</heading1>[<paragraph>bar</paragraph>  ->      <heading1>foo[bar</heading1>\n\t//     </blockQuote>                                            ->  </blockQuote>\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         ]                                                    ->      ]\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\t// Or in simple case (without moving elements in above if):\n\t//     <heading1>foo</heading1>[<paragraph>bar</paragraph>]  ->  <heading1>foo[bar</heading1>]\n\t//\n\twriter.merge( startPosition );\n\n\t// Remove empty end ancestors:\n\t//\n\t//     <blockQuote>                      ->  <blockQuote>\n\t//         <heading1>foo[bar</heading1>  ->      <heading1>foo[bar</heading1>\n\t//     </blockQuote>                     ->  </blockQuote>\n\t//     <blockBlock>                      ->\n\t//         ]                             ->  ]\n\t//     </blockBlock>                     ->\n\t//\n\twhile ( endPosition.parent.isEmpty ) {\n\t\tconst parentToRemove = endPosition.parent;\n\n\t\tendPosition = writer.createPositionBefore( parentToRemove );\n\n\t\twriter.remove( parentToRemove );\n\t}\n\n\t// Verify if there is a need and possibility to merge next level.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\tmergeBranchesLeft( writer, startPosition, endPosition, commonAncestor );\n}\n\n// Merging blocks to the right (properties of the right block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->            --v\n//     <paragraph>]bar</paragraph>  ->  [<paragraph>foo]bar</paragraph>\n//\n// Nested example:\n//     <blockQuote>                     ->\n//         <heading1>foo[</heading1>    ->              ---\n//     </blockQuote>                    ->                 |\n//     <blockBlock>                     ->  [<blockBlock>  v\n//         <paragraph>]bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n//     </blockBlock>                    ->  </blockBlock>\n//\nfunction mergeBranchesRight( writer, startPosition, endPosition, commonAncestor ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// Merging reached the common ancestor element, stop here.\n\tif ( startElement == commonAncestor || endElement == commonAncestor ) {\n\t\treturn;\n\t}\n\n\t// Remember next positions to merge in next recursive step (also used as modification points pointers).\n\tstartPosition = writer.createPositionAfter( startElement );\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Move startElement just before endElement if they aren't siblings.\n\tif ( !endPosition.isEqual( startPosition ) ) {\n\t\t//\n\t\t//     <blockQuote>                     ->  <blockQuote>\n\t\t//         <heading1>foo[</heading1>    ->      [                   ---\n\t\t//     </blockQuote>                    ->  </blockQuote>              |\n\t\t//     <blockBlock>                     ->  <blockBlock>               v\n\t\t//         <paragraph>]bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n\t\t//     </blockBlock>                    ->  </blockBlock>\n\t\t//\n\t\twriter.insert( startElement, endPosition );\n\t}\n\n\t// Remove empty end ancestors:\n\t//\n\t//     <blockQuote>                                             ->\n\t//         [                                                    ->  [\n\t//     </blockQuote>                                            ->\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\twhile ( startPosition.parent.isEmpty ) {\n\t\tconst parentToRemove = startPosition.parent;\n\n\t\tstartPosition = writer.createPositionBefore( parentToRemove );\n\n\t\twriter.remove( parentToRemove );\n\t}\n\n\t// Update endPosition after inserting and removing elements.\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Merge right two siblings (nodes on sides of endPosition):\n\t//                                                              ->\n\t//     [                                                        ->  [\n\t//                                                              ->\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\t// Or in simple case (without moving elements in above if):\n\t//     [<heading1>foo</heading1>]<paragraph>bar</paragraph>  ->  [<heading1>foo]bar</heading1>\n\t//\n\tmergeRight( writer, endPosition );\n\n\t// Verify if there is a need and possibility to merge next level.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\tmergeBranchesRight( writer, startPosition, endPosition, commonAncestor );\n}\n\n// There is no right merge operation so we need to simulate it.\nfunction mergeRight( writer, position ) {\n\tconst startElement = position.nodeBefore;\n\tconst endElement = position.nodeAfter;\n\n\tif ( startElement.name != endElement.name ) {\n\t\twriter.rename( startElement, endElement.name );\n\t}\n\n\twriter.clearAttributes( startElement );\n\twriter.setAttributes( Object.fromEntries( endElement.getAttributes() ), startElement );\n\n\twriter.merge( position );\n}\n\n// Verifies if merging is needed and possible. It's not needed if both positions are in the same element\n// and it's not possible if some element is a limit or the range crosses a limit element.\nfunction checkShouldMerge( schema, startPosition, endPosition ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// If both positions ended up in the same parent, then there's nothing more to merge:\n\t// <$root><p>x[</p><p>]y</p></$root> => <$root><p>xy</p>[]</$root>\n\tif ( startElement == endElement ) {\n\t\treturn false;\n\t}\n\n\t// If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n\tif ( schema.isLimit( startElement ) || schema.isLimit( endElement ) ) {\n\t\treturn false;\n\t}\n\n\t// Check if operations we'll need to do won't need to cross object or limit boundaries.\n\t// E.g., we can't merge endElement into startElement in this case:\n\t// <limit><startElement>x[</startElement></limit><endElement>]</endElement>\n\treturn isCrossingLimitElement( startPosition, endPosition, schema );\n}\n\n// Returns the elements that are the ancestors of the provided positions that are direct children of the common ancestor.\nfunction getAncestorsJustBelowCommonAncestor( positionA, positionB ) {\n\tconst ancestorsA = positionA.getAncestors();\n\tconst ancestorsB = positionB.getAncestors();\n\n\tlet i = 0;\n\n\twhile ( ancestorsA[ i ] && ancestorsA[ i ] == ancestorsB[ i ] ) {\n\t\ti++;\n\t}\n\n\treturn [ ancestorsA[ i ], ancestorsB[ i ] ];\n}\n\nfunction shouldAutoparagraph( schema, position ) {\n\tconst isTextAllowed = schema.checkChild( position, '$text' );\n\tconst isParagraphAllowed = schema.checkChild( position, 'paragraph' );\n\n\treturn !isTextAllowed && isParagraphAllowed;\n}\n\n// Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\nfunction isCrossingLimitElement( leftPos, rightPos, schema ) {\n\tconst rangeToCheck = new Range( leftPos, rightPos );\n\n\tfor ( const value of rangeToCheck.getWalker() ) {\n\t\tif ( schema.isLimit( value.item ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction insertParagraph( writer, position, selection, attributes = {} ) {\n\tconst paragraph = writer.createElement( 'paragraph' );\n\n\twriter.model.schema.setAllowedAttributes( paragraph, attributes, writer );\n\n\twriter.insert( paragraph, position );\n\n\tcollapseSelectionAt( writer, selection, writer.createPositionAt( paragraph, 0 ) );\n}\n\nfunction replaceEntireContentWithParagraph( writer, selection ) {\n\tconst limitElement = writer.model.schema.getLimitElement( selection );\n\n\twriter.remove( writer.createRangeIn( limitElement ) );\n\tinsertParagraph( writer, writer.createPositionAt( limitElement, 0 ), selection );\n}\n\n// We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\nfunction shouldEntireContentBeReplacedWithParagraph( schema, selection ) {\n\tconst limitElement = schema.getLimitElement( selection );\n\n\tif ( !selection.containsEntireContent( limitElement ) ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getFirstRange();\n\n\tif ( range.start.parent == range.end.parent ) {\n\t\treturn false;\n\t}\n\n\treturn schema.checkChild( limitElement, 'paragraph' );\n}\n\n// Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\nfunction collapseSelectionAt( writer, selection, positionOrRange ) {\n\tif ( selection instanceof DocumentSelection ) {\n\t\twriter.setSelection( positionOrRange );\n\t} else {\n\t\tselection.setTo( positionOrRange );\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}