{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/modifyselection\n */\nimport Position from '../position';\nimport TreeWalker from '../treewalker';\nimport Range from '../range';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol, isInsideEmojiSequence } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport DocumentSelection from '../documentselection';\nconst wordBoundaryCharacters = ' ,.?!:;\"-()';\n/**\n * Modifies the selection. Currently, the supported modifications are:\n *\n * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n * Possible values for `unit` are:\n *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n *  why `'character'` value is most natural and common method of modifying selection.\n *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n *  extension will include whole \"surrogate pair\".\n *  * `'word'` - moves selection by a whole word.\n *\n * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n *\n * **Note:** Use {@link module:engine/model/model~Model#modifySelection} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#modifySelection}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection to modify.\n * @param {Object} [options]\n * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n * @param {Boolean} [options.treatEmojiAsSingleUnit=false] Whether multi-characer emoji sequences should be handled as single unit.\n */\n\nexport default function modifySelection(model, selection) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const schema = model.schema;\n  const isForward = options.direction != 'backward';\n  const unit = options.unit ? options.unit : 'character';\n  const treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;\n  const focus = selection.focus;\n  const walker = new TreeWalker({\n    boundaries: getSearchRange(focus, isForward),\n    singleCharacters: true,\n    direction: isForward ? 'forward' : 'backward'\n  });\n  const data = {\n    walker,\n    schema,\n    isForward,\n    unit,\n    treatEmojiAsSingleUnit\n  };\n  let next;\n\n  while (next = walker.next()) {\n    if (next.done) {\n      return;\n    }\n\n    const position = tryExtendingTo(data, next.value);\n\n    if (position) {\n      if (selection instanceof DocumentSelection) {\n        model.change(writer => {\n          writer.setSelectionFocus(position);\n        });\n      } else {\n        selection.setFocus(position);\n      }\n\n      return;\n    }\n  }\n} // Checks whether the selection can be extended to the the walker's next value (next position).\n// @param {{ walker, unit, isForward, schema, treatEmojiAsSingleUnit }} data\n// @param {module:engine/view/treewalker~TreeWalkerValue} value\n\nfunction tryExtendingTo(data, value) {\n  const {\n    isForward,\n    walker,\n    unit,\n    schema,\n    treatEmojiAsSingleUnit\n  } = data;\n  const {\n    type,\n    item,\n    nextPosition\n  } = value; // If found text, we can certainly put the focus in it. Let's just find a correct position\n  // based on the unit.\n\n  if (type == 'text') {\n    if (data.unit === 'word') {\n      return getCorrectWordBreakPosition(walker, isForward);\n    }\n\n    return getCorrectPosition(walker, unit, treatEmojiAsSingleUnit);\n  } // Entering an element.\n\n\n  if (type == (isForward ? 'elementStart' : 'elementEnd')) {\n    // If it's a selectable, we can select it now.\n    if (schema.isSelectable(item)) {\n      return Position._createAt(item, isForward ? 'after' : 'before');\n    } // If text allowed on this position, extend to this place.\n\n\n    if (schema.checkChild(nextPosition, '$text')) {\n      return nextPosition;\n    }\n  } // Leaving an element.\n  else {\n    // If leaving a limit element, stop.\n    if (schema.isLimit(item)) {\n      // NOTE: Fast-forward the walker until the end.\n      walker.skip(() => true);\n      return;\n    } // If text allowed on this position, extend to this place.\n\n\n    if (schema.checkChild(nextPosition, '$text')) {\n      return nextPosition;\n    }\n  }\n} // Finds a correct position by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {String} unit The unit by which selection should be modified.\n// @param {Boolean} treatEmojiAsSingleUnit\n\n\nfunction getCorrectPosition(walker, unit, treatEmojiAsSingleUnit) {\n  const textNode = walker.position.textNode;\n\n  if (textNode) {\n    const data = textNode.data;\n    let offset = walker.position.offset - textNode.startOffset;\n\n    while (isInsideSurrogatePair(data, offset) || unit == 'character' && isInsideCombinedSymbol(data, offset) || treatEmojiAsSingleUnit && isInsideEmojiSequence(data, offset)) {\n      walker.next();\n      offset = walker.position.offset - textNode.startOffset;\n    }\n  }\n\n  return walker.position;\n} // Finds a correct position of a word break by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction getCorrectWordBreakPosition(walker, isForward) {\n  let textNode = walker.position.textNode;\n\n  if (textNode) {\n    let offset = walker.position.offset - textNode.startOffset;\n\n    while (!isAtWordBoundary(textNode.data, offset, isForward) && !isAtNodeBoundary(textNode, offset, isForward)) {\n      walker.next(); // Check of adjacent text nodes with different attributes (like BOLD).\n      // Example          : 'foofoo []bar<$text bold=\"true\">bar</$text> bazbaz'\n      // should expand to : 'foofoo [bar<$text bold=\"true\">bar</$text>] bazbaz'.\n\n      const nextNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore; // Scan only text nodes. Ignore inline elements (like `<softBreak>`).\n\n      if (nextNode && nextNode.is('$text')) {\n        // Check boundary char of an adjacent text node.\n        const boundaryChar = nextNode.data.charAt(isForward ? 0 : nextNode.data.length - 1); // Go to the next node if the character at the boundary of that node belongs to the same word.\n\n        if (!wordBoundaryCharacters.includes(boundaryChar)) {\n          // If adjacent text node belongs to the same word go to it & reset values.\n          walker.next();\n          textNode = walker.position.textNode;\n        }\n      }\n\n      offset = walker.position.offset - textNode.startOffset;\n    }\n  }\n\n  return walker.position;\n}\n\nfunction getSearchRange(start, isForward) {\n  const root = start.root;\n\n  const searchEnd = Position._createAt(root, isForward ? 'end' : 0);\n\n  if (isForward) {\n    return new Range(start, searchEnd);\n  } else {\n    return new Range(searchEnd, start);\n  }\n} // Checks if selection is on word boundary.\n//\n// @param {String} data The text node value to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction isAtWordBoundary(data, offset, isForward) {\n  // The offset to check depends on direction.\n  const offsetToCheck = offset + (isForward ? 0 : -1);\n  return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));\n} // Checks if selection is on node boundary.\n//\n// @param {module:engine/model/text~Text} textNode The text node to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction isAtNodeBoundary(textNode, offset, isForward) {\n  return offset === (isForward ? textNode.endOffset : 0);\n}","map":{"version":3,"names":["Position","TreeWalker","Range","isInsideSurrogatePair","isInsideCombinedSymbol","isInsideEmojiSequence","DocumentSelection","wordBoundaryCharacters","modifySelection","model","selection","options","schema","isForward","direction","unit","treatEmojiAsSingleUnit","focus","walker","boundaries","getSearchRange","singleCharacters","data","next","done","position","tryExtendingTo","value","change","writer","setSelectionFocus","setFocus","type","item","nextPosition","getCorrectWordBreakPosition","getCorrectPosition","isSelectable","_createAt","checkChild","isLimit","skip","textNode","offset","startOffset","isAtWordBoundary","isAtNodeBoundary","nextNode","nodeAfter","nodeBefore","is","boundaryChar","charAt","length","includes","start","root","searchEnd","offsetToCheck","endOffset"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/modifyselection.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/modifyselection\n */\n\nimport Position from '../position';\nimport TreeWalker from '../treewalker';\nimport Range from '../range';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol, isInsideEmojiSequence } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport DocumentSelection from '../documentselection';\n\nconst wordBoundaryCharacters = ' ,.?!:;\"-()';\n\n/**\n * Modifies the selection. Currently, the supported modifications are:\n *\n * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n * Possible values for `unit` are:\n *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n *  why `'character'` value is most natural and common method of modifying selection.\n *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n *  extension will include whole \"surrogate pair\".\n *  * `'word'` - moves selection by a whole word.\n *\n * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n *\n * **Note:** Use {@link module:engine/model/model~Model#modifySelection} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#modifySelection}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection to modify.\n * @param {Object} [options]\n * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n * @param {Boolean} [options.treatEmojiAsSingleUnit=false] Whether multi-characer emoji sequences should be handled as single unit.\n */\nexport default function modifySelection( model, selection, options = {} ) {\n\tconst schema = model.schema;\n\tconst isForward = options.direction != 'backward';\n\tconst unit = options.unit ? options.unit : 'character';\n\tconst treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;\n\n\tconst focus = selection.focus;\n\n\tconst walker = new TreeWalker( {\n\t\tboundaries: getSearchRange( focus, isForward ),\n\t\tsingleCharacters: true,\n\t\tdirection: isForward ? 'forward' : 'backward'\n\t} );\n\n\tconst data = { walker, schema, isForward, unit, treatEmojiAsSingleUnit };\n\n\tlet next;\n\n\twhile ( ( next = walker.next() ) ) {\n\t\tif ( next.done ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst position = tryExtendingTo( data, next.value );\n\n\t\tif ( position ) {\n\t\t\tif ( selection instanceof DocumentSelection ) {\n\t\t\t\tmodel.change( writer => {\n\t\t\t\t\twriter.setSelectionFocus( position );\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tselection.setFocus( position );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n// Checks whether the selection can be extended to the the walker's next value (next position).\n// @param {{ walker, unit, isForward, schema, treatEmojiAsSingleUnit }} data\n// @param {module:engine/view/treewalker~TreeWalkerValue} value\nfunction tryExtendingTo( data, value ) {\n\tconst { isForward, walker, unit, schema, treatEmojiAsSingleUnit } = data;\n\tconst { type, item, nextPosition } = value;\n\n\t// If found text, we can certainly put the focus in it. Let's just find a correct position\n\t// based on the unit.\n\tif ( type == 'text' ) {\n\t\tif ( data.unit === 'word' ) {\n\t\t\treturn getCorrectWordBreakPosition( walker, isForward );\n\t\t}\n\n\t\treturn getCorrectPosition( walker, unit, treatEmojiAsSingleUnit );\n\t}\n\n\t// Entering an element.\n\tif ( type == ( isForward ? 'elementStart' : 'elementEnd' ) ) {\n\t\t// If it's a selectable, we can select it now.\n\t\tif ( schema.isSelectable( item ) ) {\n\t\t\treturn Position._createAt( item, isForward ? 'after' : 'before' );\n\t\t}\n\n\t\t// If text allowed on this position, extend to this place.\n\t\tif ( schema.checkChild( nextPosition, '$text' ) ) {\n\t\t\treturn nextPosition;\n\t\t}\n\t}\n\t// Leaving an element.\n\telse {\n\t\t// If leaving a limit element, stop.\n\t\tif ( schema.isLimit( item ) ) {\n\t\t\t// NOTE: Fast-forward the walker until the end.\n\t\t\twalker.skip( () => true );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// If text allowed on this position, extend to this place.\n\t\tif ( schema.checkChild( nextPosition, '$text' ) ) {\n\t\t\treturn nextPosition;\n\t\t}\n\t}\n}\n\n// Finds a correct position by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {String} unit The unit by which selection should be modified.\n// @param {Boolean} treatEmojiAsSingleUnit\nfunction getCorrectPosition( walker, unit, treatEmojiAsSingleUnit ) {\n\tconst textNode = walker.position.textNode;\n\n\tif ( textNode ) {\n\t\tconst data = textNode.data;\n\t\tlet offset = walker.position.offset - textNode.startOffset;\n\n\t\twhile (\n\t\t\tisInsideSurrogatePair( data, offset ) ||\n\t\t\t( unit == 'character' && isInsideCombinedSymbol( data, offset ) ) ||\n\t\t\t( treatEmojiAsSingleUnit && isInsideEmojiSequence( data, offset ) )\n\t\t) {\n\t\t\twalker.next();\n\n\t\t\toffset = walker.position.offset - textNode.startOffset;\n\t\t}\n\t}\n\n\treturn walker.position;\n}\n\n// Finds a correct position of a word break by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction getCorrectWordBreakPosition( walker, isForward ) {\n\tlet textNode = walker.position.textNode;\n\n\tif ( textNode ) {\n\t\tlet offset = walker.position.offset - textNode.startOffset;\n\n\t\twhile ( !isAtWordBoundary( textNode.data, offset, isForward ) && !isAtNodeBoundary( textNode, offset, isForward ) ) {\n\t\t\twalker.next();\n\n\t\t\t// Check of adjacent text nodes with different attributes (like BOLD).\n\t\t\t// Example          : 'foofoo []bar<$text bold=\"true\">bar</$text> bazbaz'\n\t\t\t// should expand to : 'foofoo [bar<$text bold=\"true\">bar</$text>] bazbaz'.\n\t\t\tconst nextNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;\n\n\t\t\t// Scan only text nodes. Ignore inline elements (like `<softBreak>`).\n\t\t\tif ( nextNode && nextNode.is( '$text' ) ) {\n\t\t\t\t// Check boundary char of an adjacent text node.\n\t\t\t\tconst boundaryChar = nextNode.data.charAt( isForward ? 0 : nextNode.data.length - 1 );\n\n\t\t\t\t// Go to the next node if the character at the boundary of that node belongs to the same word.\n\t\t\t\tif ( !wordBoundaryCharacters.includes( boundaryChar ) ) {\n\t\t\t\t\t// If adjacent text node belongs to the same word go to it & reset values.\n\t\t\t\t\twalker.next();\n\n\t\t\t\t\ttextNode = walker.position.textNode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toffset = walker.position.offset - textNode.startOffset;\n\t\t}\n\t}\n\n\treturn walker.position;\n}\n\nfunction getSearchRange( start, isForward ) {\n\tconst root = start.root;\n\tconst searchEnd = Position._createAt( root, isForward ? 'end' : 0 );\n\n\tif ( isForward ) {\n\t\treturn new Range( start, searchEnd );\n\t} else {\n\t\treturn new Range( searchEnd, start );\n\t}\n}\n\n// Checks if selection is on word boundary.\n//\n// @param {String} data The text node value to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction isAtWordBoundary( data, offset, isForward ) {\n\t// The offset to check depends on direction.\n\tconst offsetToCheck = offset + ( isForward ? 0 : -1 );\n\n\treturn wordBoundaryCharacters.includes( data.charAt( offsetToCheck ) );\n}\n\n// Checks if selection is on node boundary.\n//\n// @param {module:engine/model/text~Text} textNode The text node to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction isAtNodeBoundary( textNode, offset, isForward ) {\n\treturn offset === ( isForward ? textNode.endOffset : 0 );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}