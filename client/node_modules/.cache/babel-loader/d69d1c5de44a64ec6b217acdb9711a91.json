{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/focuscycler\n */\nimport isVisible from '@ckeditor/ckeditor5-utils/src/dom/isvisible';\n/**\n * A utility class that helps cycling over focusable {@link module:ui/view~View views} in a\n * {@link module:ui/viewcollection~ViewCollection} when the focus is tracked by the\n * {@link module:utils/focustracker~FocusTracker} instance. It helps implementing keyboard\n * navigation in HTML forms, toolbars, lists and the like.\n *\n * To work properly it requires:\n * * a collection of focusable (HTML `tabindex` attribute) views that implement the `focus()` method,\n * * an associated focus tracker to determine which view is focused.\n *\n * A simple cycler setup can look like this:\n *\n *\t\tconst focusables = new ViewCollection();\n *\t\tconst focusTracker = new FocusTracker();\n *\n *\t\t// Add focusable views to the focus tracker.\n *\t\tfocusTracker.add( ... );\n *\n * Then, the cycler can be used manually:\n *\n *\t\tconst cycler = new FocusCycler( { focusables, focusTracker } );\n *\n *\t\t// Will focus the first focusable view in #focusables.\n *\t\tcycler.focusFirst();\n *\n *\t\t// Will log the next focusable item in #focusables.\n *\t\tconsole.log( cycler.next );\n *\n * Alternatively, it can work side by side with the {@link module:utils/keystrokehandler~KeystrokeHandler}:\n *\n *\t\tconst keystrokeHandler = new KeystrokeHandler();\n *\n *\t\t// Activate the keystroke handler.\n *\t\tkeystrokeHandler.listenTo( sourceOfEvents );\n *\n *\t\tconst cycler = new FocusCycler( {\n *\t\t\tfocusables, focusTracker, keystrokeHandler,\n *\t\t\tactions: {\n *\t\t\t\t// When arrowup of arrowleft is detected by the #keystrokeHandler,\n *\t\t\t\t// focusPrevious() will be called on the cycler.\n *\t\t\t\tfocusPrevious: [ 'arrowup', 'arrowleft' ],\n *\t\t\t}\n *\t\t} );\n *\n * Check out the {@glink framework/guides/deep-dive/ui/focus-tracking \"Deep dive into focus tracking\" guide} to learn more.\n */\n\nexport default class FocusCycler {\n  /**\n   * Creates an instance of the focus cycler utility.\n   *\n   * @param {Object} options Configuration options.\n   * @param {module:utils/collection~Collection|Object} options.focusables\n   * @param {module:utils/focustracker~FocusTracker} options.focusTracker\n   * @param {module:utils/keystrokehandler~KeystrokeHandler} [options.keystrokeHandler]\n   * @param {Object} [options.actions]\n   */\n  constructor(options) {\n    Object.assign(this, options);\n    /**\n     * A {@link module:ui/view~View view} collection that the cycler operates on.\n     *\n     * @readonly\n     * @member {module:utils/collection~Collection} #focusables\n     */\n\n    /**\n     * A focus tracker instance that the cycler uses to determine the current focus\n     * state in {@link #focusables}.\n     *\n     * @readonly\n     * @member {module:utils/focustracker~FocusTracker} #focusTracker\n     */\n\n    /**\n     * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}\n     * which can respond to certain keystrokes and cycle the focus.\n     *\n     * @readonly\n     * @member {module:utils/keystrokehandler~KeystrokeHandler} #keystrokeHandler\n     */\n\n    /**\n     * Actions that the cycler can take when a keystroke is pressed. Requires\n     * `options.keystrokeHandler` to be passed and working. When an action is\n     * performed, `preventDefault` and `stopPropagation` will be called on the event\n     * the keystroke fired in the DOM.\n     *\n     *\t\tactions: {\n     *\t\t\t// Will call #focusPrevious() when arrowleft or arrowup is pressed.\n     *\t\t\tfocusPrevious: [ 'arrowleft', 'arrowup' ],\n     *\n     *\t\t\t// Will call #focusNext() when arrowdown is pressed.\n     *\t\t\tfocusNext: 'arrowdown'\n     *\t\t}\n     *\n     * @readonly\n     * @member {Object} #actions\n     */\n\n    if (options.actions && options.keystrokeHandler) {\n      for (const methodName in options.actions) {\n        let actions = options.actions[methodName];\n\n        if (typeof actions == 'string') {\n          actions = [actions];\n        }\n\n        for (const keystroke of actions) {\n          options.keystrokeHandler.set(keystroke, (data, cancel) => {\n            this[methodName]();\n            cancel();\n          });\n        }\n      }\n    }\n  }\n  /**\n   * Returns the first focusable view in {@link #focusables}.\n   * Returns `null` if there is none.\n   *\n   * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n   *\n   * @readonly\n   * @member {module:ui/view~View|null} #first\n   */\n\n\n  get first() {\n    return this.focusables.find(isFocusable) || null;\n  }\n  /**\n   * Returns the last focusable view in {@link #focusables}.\n   * Returns `null` if there is none.\n   *\n   * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n   *\n   * @readonly\n   * @member {module:ui/view~View|null} #last\n   */\n\n\n  get last() {\n    return this.focusables.filter(isFocusable).slice(-1)[0] || null;\n  }\n  /**\n   * Returns the next focusable view in {@link #focusables} based on {@link #current}.\n   * Returns `null` if there is none.\n   *\n   * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n   *\n   * @readonly\n   * @member {module:ui/view~View|null} #next\n   */\n\n\n  get next() {\n    return this._getFocusableItem(1);\n  }\n  /**\n   * Returns the previous focusable view in {@link #focusables} based on {@link #current}.\n   * Returns `null` if there is none.\n   *\n   * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n   *\n   * @readonly\n   * @member {module:ui/view~View|null} #previous\n   */\n\n\n  get previous() {\n    return this._getFocusableItem(-1);\n  }\n  /**\n   * An index of the view in the {@link #focusables} which is focused according\n   * to {@link #focusTracker}. Returns `null` when there is no such view.\n   *\n   * @readonly\n   * @member {Number|null} #current\n   */\n\n\n  get current() {\n    let index = null; // There's no focused view in the focusables.\n\n    if (this.focusTracker.focusedElement === null) {\n      return null;\n    }\n\n    this.focusables.find((view, viewIndex) => {\n      const focused = view.element === this.focusTracker.focusedElement;\n\n      if (focused) {\n        index = viewIndex;\n      }\n\n      return focused;\n    });\n    return index;\n  }\n  /**\n   * Focuses the {@link #first} item in {@link #focusables}.\n   *\n   * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n   */\n\n\n  focusFirst() {\n    this._focus(this.first);\n  }\n  /**\n   * Focuses the {@link #last} item in {@link #focusables}.\n   *\n   * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n   */\n\n\n  focusLast() {\n    this._focus(this.last);\n  }\n  /**\n   * Focuses the {@link #next} item in {@link #focusables}.\n   *\n   * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n   */\n\n\n  focusNext() {\n    this._focus(this.next);\n  }\n  /**\n   * Focuses the {@link #previous} item in {@link #focusables}.\n   *\n   * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n   */\n\n\n  focusPrevious() {\n    this._focus(this.previous);\n  }\n  /**\n   * Focuses the given view if it exists.\n   *\n   * @protected\n   * @param {module:ui/view~View} view\n   */\n\n\n  _focus(view) {\n    if (view) {\n      view.focus();\n    }\n  }\n  /**\n   * Returns the next or previous focusable view in {@link #focusables} with respect\n   * to {@link #current}.\n   *\n   * @protected\n   * @param {Number} step Either `1` for checking forward from {@link #current} or\n   * `-1` for checking backwards.\n   * @returns {module:ui/view~View|null}\n   */\n\n\n  _getFocusableItem(step) {\n    // Cache for speed.\n    const current = this.current;\n    const collectionLength = this.focusables.length;\n\n    if (!collectionLength) {\n      return null;\n    } // Start from the beginning if no view is focused.\n    // https://github.com/ckeditor/ckeditor5-ui/issues/206\n\n\n    if (current === null) {\n      return this[step === 1 ? 'first' : 'last'];\n    } // Cycle in both directions.\n\n\n    let index = (current + collectionLength + step) % collectionLength;\n\n    do {\n      const view = this.focusables.get(index);\n\n      if (isFocusable(view)) {\n        return view;\n      } // Cycle in both directions.\n\n\n      index = (index + collectionLength + step) % collectionLength;\n    } while (index !== current);\n\n    return null;\n  }\n\n} // Checks whether a view is focusable.\n//\n// @private\n// @param {module:ui/view~View} view A view to be checked.\n// @returns {Boolean}\n\nfunction isFocusable(view) {\n  return !!(view.focus && isVisible(view.element));\n}","map":{"version":3,"names":["isVisible","FocusCycler","constructor","options","Object","assign","actions","keystrokeHandler","methodName","keystroke","set","data","cancel","first","focusables","find","isFocusable","last","filter","slice","next","_getFocusableItem","previous","current","index","focusTracker","focusedElement","view","viewIndex","focused","element","focusFirst","_focus","focusLast","focusNext","focusPrevious","focus","step","collectionLength","length","get"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-ui/src/focuscycler.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/focuscycler\n */\n\nimport isVisible from '@ckeditor/ckeditor5-utils/src/dom/isvisible';\n\n/**\n * A utility class that helps cycling over focusable {@link module:ui/view~View views} in a\n * {@link module:ui/viewcollection~ViewCollection} when the focus is tracked by the\n * {@link module:utils/focustracker~FocusTracker} instance. It helps implementing keyboard\n * navigation in HTML forms, toolbars, lists and the like.\n *\n * To work properly it requires:\n * * a collection of focusable (HTML `tabindex` attribute) views that implement the `focus()` method,\n * * an associated focus tracker to determine which view is focused.\n *\n * A simple cycler setup can look like this:\n *\n *\t\tconst focusables = new ViewCollection();\n *\t\tconst focusTracker = new FocusTracker();\n *\n *\t\t// Add focusable views to the focus tracker.\n *\t\tfocusTracker.add( ... );\n *\n * Then, the cycler can be used manually:\n *\n *\t\tconst cycler = new FocusCycler( { focusables, focusTracker } );\n *\n *\t\t// Will focus the first focusable view in #focusables.\n *\t\tcycler.focusFirst();\n *\n *\t\t// Will log the next focusable item in #focusables.\n *\t\tconsole.log( cycler.next );\n *\n * Alternatively, it can work side by side with the {@link module:utils/keystrokehandler~KeystrokeHandler}:\n *\n *\t\tconst keystrokeHandler = new KeystrokeHandler();\n *\n *\t\t// Activate the keystroke handler.\n *\t\tkeystrokeHandler.listenTo( sourceOfEvents );\n *\n *\t\tconst cycler = new FocusCycler( {\n *\t\t\tfocusables, focusTracker, keystrokeHandler,\n *\t\t\tactions: {\n *\t\t\t\t// When arrowup of arrowleft is detected by the #keystrokeHandler,\n *\t\t\t\t// focusPrevious() will be called on the cycler.\n *\t\t\t\tfocusPrevious: [ 'arrowup', 'arrowleft' ],\n *\t\t\t}\n *\t\t} );\n *\n * Check out the {@glink framework/guides/deep-dive/ui/focus-tracking \"Deep dive into focus tracking\" guide} to learn more.\n */\nexport default class FocusCycler {\n\t/**\n\t * Creates an instance of the focus cycler utility.\n\t *\n\t * @param {Object} options Configuration options.\n\t * @param {module:utils/collection~Collection|Object} options.focusables\n\t * @param {module:utils/focustracker~FocusTracker} options.focusTracker\n\t * @param {module:utils/keystrokehandler~KeystrokeHandler} [options.keystrokeHandler]\n\t * @param {Object} [options.actions]\n\t */\n\tconstructor( options ) {\n\t\tObject.assign( this, options );\n\n\t\t/**\n\t\t * A {@link module:ui/view~View view} collection that the cycler operates on.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/collection~Collection} #focusables\n\t\t */\n\n\t\t/**\n\t\t * A focus tracker instance that the cycler uses to determine the current focus\n\t\t * state in {@link #focusables}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/focustracker~FocusTracker} #focusTracker\n\t\t */\n\n\t\t/**\n\t\t * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}\n\t\t * which can respond to certain keystrokes and cycle the focus.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/keystrokehandler~KeystrokeHandler} #keystrokeHandler\n\t\t */\n\n\t\t/**\n\t\t * Actions that the cycler can take when a keystroke is pressed. Requires\n\t\t * `options.keystrokeHandler` to be passed and working. When an action is\n\t\t * performed, `preventDefault` and `stopPropagation` will be called on the event\n\t\t * the keystroke fired in the DOM.\n\t\t *\n\t\t *\t\tactions: {\n\t\t *\t\t\t// Will call #focusPrevious() when arrowleft or arrowup is pressed.\n\t\t *\t\t\tfocusPrevious: [ 'arrowleft', 'arrowup' ],\n\t\t *\n\t\t *\t\t\t// Will call #focusNext() when arrowdown is pressed.\n\t\t *\t\t\tfocusNext: 'arrowdown'\n\t\t *\t\t}\n\t\t *\n\t\t * @readonly\n\t\t * @member {Object} #actions\n\t\t */\n\n\t\tif ( options.actions && options.keystrokeHandler ) {\n\t\t\tfor ( const methodName in options.actions ) {\n\t\t\t\tlet actions = options.actions[ methodName ];\n\n\t\t\t\tif ( typeof actions == 'string' ) {\n\t\t\t\t\tactions = [ actions ];\n\t\t\t\t}\n\n\t\t\t\tfor ( const keystroke of actions ) {\n\t\t\t\t\toptions.keystrokeHandler.set( keystroke, ( data, cancel ) => {\n\t\t\t\t\t\tthis[ methodName ]();\n\t\t\t\t\t\tcancel();\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the first focusable view in {@link #focusables}.\n\t * Returns `null` if there is none.\n\t *\n\t * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #first\n\t */\n\tget first() {\n\t\treturn this.focusables.find( isFocusable ) || null;\n\t}\n\n\t/**\n\t * Returns the last focusable view in {@link #focusables}.\n\t * Returns `null` if there is none.\n\t *\n\t * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #last\n\t */\n\tget last() {\n\t\treturn this.focusables.filter( isFocusable ).slice( -1 )[ 0 ] || null;\n\t}\n\n\t/**\n\t * Returns the next focusable view in {@link #focusables} based on {@link #current}.\n\t * Returns `null` if there is none.\n\t *\n\t * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #next\n\t */\n\tget next() {\n\t\treturn this._getFocusableItem( 1 );\n\t}\n\n\t/**\n\t * Returns the previous focusable view in {@link #focusables} based on {@link #current}.\n\t * Returns `null` if there is none.\n\t *\n\t * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #previous\n\t */\n\tget previous() {\n\t\treturn this._getFocusableItem( -1 );\n\t}\n\n\t/**\n\t * An index of the view in the {@link #focusables} which is focused according\n\t * to {@link #focusTracker}. Returns `null` when there is no such view.\n\t *\n\t * @readonly\n\t * @member {Number|null} #current\n\t */\n\tget current() {\n\t\tlet index = null;\n\n\t\t// There's no focused view in the focusables.\n\t\tif ( this.focusTracker.focusedElement === null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis.focusables.find( ( view, viewIndex ) => {\n\t\t\tconst focused = view.element === this.focusTracker.focusedElement;\n\n\t\t\tif ( focused ) {\n\t\t\t\tindex = viewIndex;\n\t\t\t}\n\n\t\t\treturn focused;\n\t\t} );\n\n\t\treturn index;\n\t}\n\n\t/**\n\t * Focuses the {@link #first} item in {@link #focusables}.\n\t *\n\t * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n\t */\n\tfocusFirst() {\n\t\tthis._focus( this.first );\n\t}\n\n\t/**\n\t * Focuses the {@link #last} item in {@link #focusables}.\n\t *\n\t * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n\t */\n\tfocusLast() {\n\t\tthis._focus( this.last );\n\t}\n\n\t/**\n\t * Focuses the {@link #next} item in {@link #focusables}.\n\t *\n\t * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n\t */\n\tfocusNext() {\n\t\tthis._focus( this.next );\n\t}\n\n\t/**\n\t * Focuses the {@link #previous} item in {@link #focusables}.\n\t *\n\t * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n\t */\n\tfocusPrevious() {\n\t\tthis._focus( this.previous );\n\t}\n\n\t/**\n\t * Focuses the given view if it exists.\n\t *\n\t * @protected\n\t * @param {module:ui/view~View} view\n\t */\n\t_focus( view ) {\n\t\tif ( view ) {\n\t\t\tview.focus();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the next or previous focusable view in {@link #focusables} with respect\n\t * to {@link #current}.\n\t *\n\t * @protected\n\t * @param {Number} step Either `1` for checking forward from {@link #current} or\n\t * `-1` for checking backwards.\n\t * @returns {module:ui/view~View|null}\n\t */\n\t_getFocusableItem( step ) {\n\t\t// Cache for speed.\n\t\tconst current = this.current;\n\t\tconst collectionLength = this.focusables.length;\n\n\t\tif ( !collectionLength ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Start from the beginning if no view is focused.\n\t\t// https://github.com/ckeditor/ckeditor5-ui/issues/206\n\t\tif ( current === null ) {\n\t\t\treturn this[ step === 1 ? 'first' : 'last' ];\n\t\t}\n\n\t\t// Cycle in both directions.\n\t\tlet index = ( current + collectionLength + step ) % collectionLength;\n\n\t\tdo {\n\t\t\tconst view = this.focusables.get( index );\n\n\t\t\tif ( isFocusable( view ) ) {\n\t\t\t\treturn view;\n\t\t\t}\n\n\t\t\t// Cycle in both directions.\n\t\t\tindex = ( index + collectionLength + step ) % collectionLength;\n\t\t} while ( index !== current );\n\n\t\treturn null;\n\t}\n}\n\n// Checks whether a view is focusable.\n//\n// @private\n// @param {module:ui/view~View} view A view to be checked.\n// @returns {Boolean}\nfunction isFocusable( view ) {\n\treturn !!( view.focus && isVisible( view.element ) );\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,SAAP,MAAsB,6CAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,WAAN,CAAkB;EAChC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCC,WAAW,CAAEC,OAAF,EAAY;IACtBC,MAAM,CAACC,MAAP,CAAe,IAAf,EAAqBF,OAArB;IAEA;AACF;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEE,IAAKA,OAAO,CAACG,OAAR,IAAmBH,OAAO,CAACI,gBAAhC,EAAmD;MAClD,KAAM,MAAMC,UAAZ,IAA0BL,OAAO,CAACG,OAAlC,EAA4C;QAC3C,IAAIA,OAAO,GAAGH,OAAO,CAACG,OAAR,CAAiBE,UAAjB,CAAd;;QAEA,IAAK,OAAOF,OAAP,IAAkB,QAAvB,EAAkC;UACjCA,OAAO,GAAG,CAAEA,OAAF,CAAV;QACA;;QAED,KAAM,MAAMG,SAAZ,IAAyBH,OAAzB,EAAmC;UAClCH,OAAO,CAACI,gBAAR,CAAyBG,GAAzB,CAA8BD,SAA9B,EAAyC,CAAEE,IAAF,EAAQC,MAAR,KAAoB;YAC5D,KAAMJ,UAAN;YACAI,MAAM;UACN,CAHD;QAIA;MACD;IACD;EACD;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACU,IAALC,KAAK,GAAG;IACX,OAAO,KAAKC,UAAL,CAAgBC,IAAhB,CAAsBC,WAAtB,KAAuC,IAA9C;EACA;EAED;AACD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"},"metadata":{},"sourceType":"module"}