{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals Node */\n\n/**\n * @module engine/view/renderer\n */\nimport ViewText from './text';\nimport ViewPosition from './position';\nimport { INLINE_FILLER, INLINE_FILLER_LENGTH, startsWithFiller, isInlineFiller } from './filler';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport insertAt from '@ckeditor/ckeditor5-utils/src/dom/insertat';\nimport remove from '@ckeditor/ckeditor5-utils/src/dom/remove';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isComment from '@ckeditor/ckeditor5-utils/src/dom/iscomment';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport fastDiff from '@ckeditor/ckeditor5-utils/src/fastdiff';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport '../../theme/renderer.css';\n/**\n * Renderer is responsible for updating the DOM structure and the DOM selection based on\n * the {@link module:engine/view/renderer~Renderer#markToSync information about updated view nodes}.\n * In other words, it renders the view to the DOM.\n *\n * Its main responsibility is to make only the necessary, minimal changes to the DOM. However, unlike in many\n * virtual DOM implementations, the primary reason for doing minimal changes is not the performance but ensuring\n * that native editing features such as text composition, autocompletion, spell checking, selection's x-index are\n * affected as little as possible.\n *\n * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform view nodes and positions\n * to and from the DOM.\n */\n\nexport default class Renderer {\n  /**\n   * Creates a renderer instance.\n   *\n   * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.\n   * @param {module:engine/view/documentselection~DocumentSelection} selection View selection.\n   */\n  constructor(domConverter, selection) {\n    /**\n     * Set of DOM Documents instances.\n     *\n     * @readonly\n     * @member {Set.<Document>}\n     */\n    this.domDocuments = new Set();\n    /**\n     * Converter instance.\n     *\n     * @readonly\n     * @member {module:engine/view/domconverter~DomConverter}\n     */\n\n    this.domConverter = domConverter;\n    /**\n     * Set of nodes which attributes changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedAttributes = new Set();\n    /**\n     * Set of elements which child lists changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedChildren = new Set();\n    /**\n     * Set of text nodes which text data changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedTexts = new Set();\n    /**\n     * View selection. Renderer updates DOM selection based on the view selection.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection}\n     */\n\n    this.selection = selection;\n    /**\n     * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if\n     * this is set to `false`.\n     *\n     * @member {Boolean}\n     * @observable\n     */\n\n    this.set('isFocused', false);\n    /**\n     * Indicates whether the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n     * When they stop selecting, the property goes back to `false`.\n     *\n     * Note: In some browsers, the renderer will stop rendering the selection and inline fillers while the user is making\n     * a selection to avoid glitches in DOM selection\n     * (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n     *\n     * @member {Boolean}\n     * @observable\n     */\n\n    this.set('isSelecting', false); // Rendering the selection and inline filler manipulation should be postponed in (non-Android) Blink until the user finishes\n    // creating the selection in DOM to avoid accidental selection collapsing\n    // (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n    // When the user stops selecting, all pending changes should be rendered ASAP, though.\n\n    if (env.isBlink && !env.isAndroid) {\n      this.on('change:isSelecting', () => {\n        if (!this.isSelecting) {\n          this.render();\n        }\n      });\n    }\n    /**\n     * The text node in which the inline filler was rendered.\n     *\n     * @private\n     * @member {Text}\n     */\n\n\n    this._inlineFiller = null;\n    /**\n     * DOM element containing fake selection.\n     *\n     * @private\n     * @type {null|HTMLElement}\n     */\n\n    this._fakeSelectionContainer = null;\n  }\n  /**\n   * Marks a view node to be updated in the DOM by {@link #render `render()`}.\n   *\n   * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.\n   *\n   * @see #markedAttributes\n   * @see #markedChildren\n   * @see #markedTexts\n   *\n   * @param {module:engine/view/document~ChangeType} type Type of the change.\n   * @param {module:engine/view/node~Node} node Node to be marked.\n   */\n\n\n  markToSync(type, node) {\n    if (type === 'text') {\n      if (this.domConverter.mapViewToDom(node.parent)) {\n        this.markedTexts.add(node);\n      }\n    } else {\n      // If the node has no DOM element it is not rendered yet,\n      // its children/attributes do not need to be marked to be sync.\n      if (!this.domConverter.mapViewToDom(node)) {\n        return;\n      }\n\n      if (type === 'attributes') {\n        this.markedAttributes.add(node);\n      } else if (type === 'children') {\n        this.markedChildren.add(node);\n      } else {\n        /**\n         * Unknown type passed to Renderer.markToSync.\n         *\n         * @error view-renderer-unknown-type\n         */\n        throw new CKEditorError('view-renderer-unknown-type', this);\n      }\n    }\n  }\n  /**\n   * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and\n   * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.\n   *\n   * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,\n   * so it does as little as it is needed to update the DOM.\n   *\n   * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed\n   * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be\n   * removed as long as the selection is in the text node which needed it at first.\n   */\n\n\n  render() {\n    let inlineFillerPosition;\n    const isInlineFillerRenderingPossible = env.isBlink && !env.isAndroid ? !this.isSelecting : true; // Refresh mappings.\n\n    for (const element of this.markedChildren) {\n      this._updateChildrenMappings(element);\n    } // Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n    // DOM selection collapsing\n    // (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\n\n    if (isInlineFillerRenderingPossible) {\n      // There was inline filler rendered in the DOM but it's not\n      // at the selection position any more, so we can remove it\n      // (cause even if it's needed, it must be placed in another location).\n      if (this._inlineFiller && !this._isSelectionInInlineFiller()) {\n        this._removeInlineFiller();\n      } // If we've got the filler, let's try to guess its position in the view.\n\n\n      if (this._inlineFiller) {\n        inlineFillerPosition = this._getInlineFillerPosition();\n      } // Otherwise, if it's needed, create it at the selection position.\n      else if (this._needsInlineFillerAtSelection()) {\n        inlineFillerPosition = this.selection.getFirstPosition(); // Do not use `markToSync` so it will be added even if the parent is already added.\n\n        this.markedChildren.add(inlineFillerPosition.parent);\n      }\n    } // Paranoid check: we make sure the inline filler has any parent so it can be mapped to view position\n    // by DomConverter.\n    else if (this._inlineFiller && this._inlineFiller.parentNode) {\n      // While the user is making selection, preserve the inline filler at its original position.\n      inlineFillerPosition = this.domConverter.domPositionToView(this._inlineFiller);\n    }\n\n    for (const element of this.markedAttributes) {\n      this._updateAttrs(element);\n    }\n\n    for (const element of this.markedChildren) {\n      this._updateChildren(element, {\n        inlineFillerPosition\n      });\n    }\n\n    for (const node of this.markedTexts) {\n      if (!this.markedChildren.has(node.parent) && this.domConverter.mapViewToDom(node.parent)) {\n        this._updateText(node, {\n          inlineFillerPosition\n        });\n      }\n    } // * Check whether the inline filler is required and where it really is in the DOM.\n    //   At this point in most cases it will be in the DOM, but there are exceptions.\n    //   For example, if the inline filler was deep in the created DOM structure, it will not be created.\n    //   Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,\n    //   it will not be present. Fix those and similar scenarios.\n    // * Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n    //   DOM selection collapsing\n    //   (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\n\n    if (isInlineFillerRenderingPossible) {\n      if (inlineFillerPosition) {\n        const fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);\n        const domDocument = fillerDomPosition.parent.ownerDocument;\n\n        if (!startsWithFiller(fillerDomPosition.parent)) {\n          // Filler has not been created at filler position. Create it now.\n          this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);\n        } else {\n          // Filler has been found, save it.\n          this._inlineFiller = fillerDomPosition.parent;\n        }\n      } else {\n        // There is no filler needed.\n        this._inlineFiller = null;\n      }\n    } // First focus the new editing host, then update the selection.\n    // Otherwise, FF may throw an error (https://github.com/ckeditor/ckeditor5/issues/721).\n\n\n    this._updateFocus();\n\n    this._updateSelection();\n\n    this.markedTexts.clear();\n    this.markedAttributes.clear();\n    this.markedChildren.clear();\n  }\n  /**\n   * Updates mappings of view element's children.\n   *\n   * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.\n   * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.\n   * Thanks to that these elements do not need to be re-rendered completely.\n   *\n   * @private\n   * @param {module:engine/view/node~Node} viewElement The view element whose children mappings will be updated.\n   */\n\n\n  _updateChildrenMappings(viewElement) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n\n    if (!domElement) {\n      // If there is no `domElement` it means that it was already removed from DOM and there is no need to process it.\n      return;\n    } // Removing nodes from the DOM as we iterate can cause `actualDomChildren`\n    // (which is a live-updating `NodeList`) to get out of sync with the\n    // indices that we compute as we iterate over `actions`.\n    // This would produce incorrect element mappings.\n    //\n    // Converting live list to an array to make the list static.\n\n\n    const actualDomChildren = Array.from(this.domConverter.mapViewToDom(viewElement).childNodes);\n    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, domElement.ownerDocument, {\n      withChildren: false\n    }));\n\n    const diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n\n    const actions = this._findReplaceActions(diff, actualDomChildren, expectedDomChildren);\n\n    if (actions.indexOf('replace') !== -1) {\n      const counter = {\n        equal: 0,\n        insert: 0,\n        delete: 0\n      };\n\n      for (const action of actions) {\n        if (action === 'replace') {\n          const insertIndex = counter.equal + counter.insert;\n          const deleteIndex = counter.equal + counter.delete;\n          const viewChild = viewElement.getChild(insertIndex); // UIElement and RawElement are special cases. Their children are not stored in a view (#799)\n          // so we cannot use them with replacing flow (since they use view children during rendering\n          // which will always result in rendering empty elements).\n\n          if (viewChild && !(viewChild.is('uiElement') || viewChild.is('rawElement'))) {\n            this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);\n          }\n\n          remove(expectedDomChildren[insertIndex]);\n          counter.equal++;\n        } else {\n          counter[action]++;\n        }\n      }\n    }\n  }\n  /**\n   * Updates mappings of a given view element.\n   *\n   * @private\n   * @param {module:engine/view/node~Node} viewElement The view element whose mappings will be updated.\n   * @param {Node} domElement The DOM element representing the given view element.\n   */\n\n\n  _updateElementMappings(viewElement, domElement) {\n    // Remap 'DomConverter' bindings.\n    this.domConverter.unbindDomElement(domElement);\n    this.domConverter.bindElements(domElement, viewElement); // View element may have children which needs to be updated, but are not marked, mark them to update.\n\n    this.markedChildren.add(viewElement); // Because we replace new view element mapping with the existing one, the corresponding DOM element\n    // will not be rerendered. The new view element may have different attributes than the previous one.\n    // Since its corresponding DOM element will not be rerendered, new attributes will not be added\n    // to the DOM, so we need to mark it here to make sure its attributes gets updated. See #1427 for more\n    // detailed case study.\n    // Also there are cases where replaced element is removed from the view structure and then has\n    // its attributes changed or removed. In such cases the element will not be present in `markedAttributes`\n    // and also may be the same (`element.isSimilar()`) as the reused element not having its attributes updated.\n    // To prevent such situations we always mark reused element to have its attributes rerenderd (#1560).\n\n    this.markedAttributes.add(viewElement);\n  }\n  /**\n   * Gets the position of the inline filler based on the current selection.\n   * Here, we assume that we know that the filler is needed and\n   * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,\n   * it is somewhere at the selection position.\n   *\n   * Note: The filler position cannot be restored based on the filler's DOM text node, because\n   * when this method is called (before rendering), the bindings will often be broken. View-to-DOM\n   * bindings are only dependable after rendering.\n   *\n   * @private\n   * @returns {module:engine/view/position~Position}\n   */\n\n\n  _getInlineFillerPosition() {\n    const firstPos = this.selection.getFirstPosition();\n\n    if (firstPos.parent.is('$text')) {\n      return ViewPosition._createBefore(this.selection.getFirstPosition().parent);\n    } else {\n      return firstPos;\n    }\n  }\n  /**\n   * Returns `true` if the selection has not left the inline filler's text node.\n   * If it is `true`, it means that the filler had been added for a reason and the selection did not\n   * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.\n   *\n   * @private\n   * @returns {Boolean} `true` if the inline filler and selection are in the same place.\n   */\n\n\n  _isSelectionInInlineFiller() {\n    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n      return false;\n    } // Note, we can't check if selection's position equals position of the\n    // this._inlineFiller node, because of #663. We may not be able to calculate\n    // the filler's position in the view at this stage.\n    // Instead, we check it the other way – whether selection is anchored in\n    // that text node or next to it.\n    // Possible options are:\n    // \"FILLER{}\"\n    // \"FILLERadded-text{}\"\n\n\n    const selectionPosition = this.selection.getFirstPosition();\n    const position = this.domConverter.viewPositionToDom(selectionPosition);\n\n    if (position && isText(position.parent) && startsWithFiller(position.parent)) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Removes the inline filler.\n   *\n   * @private\n   */\n\n\n  _removeInlineFiller() {\n    const domFillerNode = this._inlineFiller; // Something weird happened and the stored node doesn't contain the filler's text.\n\n    if (!startsWithFiller(domFillerNode)) {\n      /**\n       * The inline filler node was lost. Most likely, something overwrote the filler text node\n       * in the DOM.\n       *\n       * @error view-renderer-filler-was-lost\n       */\n      throw new CKEditorError('view-renderer-filler-was-lost', this);\n    }\n\n    if (isInlineFiller(domFillerNode)) {\n      domFillerNode.remove();\n    } else {\n      domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);\n    }\n\n    this._inlineFiller = null;\n  }\n  /**\n   * Checks if the inline {@link module:engine/view/filler filler} should be added.\n   *\n   * @private\n   * @returns {Boolean} `true` if the inline filler should be added.\n   */\n\n\n  _needsInlineFillerAtSelection() {\n    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n      return false;\n    }\n\n    const selectionPosition = this.selection.getFirstPosition();\n    const selectionParent = selectionPosition.parent;\n    const selectionOffset = selectionPosition.offset; // If there is no DOM root we do not care about fillers.\n\n    if (!this.domConverter.mapViewToDom(selectionParent.root)) {\n      return false;\n    }\n\n    if (!selectionParent.is('element')) {\n      return false;\n    } // Prevent adding inline filler inside elements with contenteditable=false.\n    // https://github.com/ckeditor/ckeditor5-engine/issues/1170\n\n\n    if (!isEditable(selectionParent)) {\n      return false;\n    } // We have block filler, we do not need inline one.\n\n\n    if (selectionOffset === selectionParent.getFillerOffset()) {\n      return false;\n    }\n\n    const nodeBefore = selectionPosition.nodeBefore;\n    const nodeAfter = selectionPosition.nodeAfter;\n\n    if (nodeBefore instanceof ViewText || nodeAfter instanceof ViewText) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Checks if text needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} viewText View text to update.\n   * @param {Object} options\n   * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n   * filler should be rendered.\n   */\n\n\n  _updateText(viewText, options) {\n    const domText = this.domConverter.findCorrespondingDomText(viewText);\n    const newDomText = this.domConverter.viewToDom(viewText, domText.ownerDocument);\n    const actualText = domText.data;\n    let expectedText = newDomText.data;\n    const filler = options.inlineFillerPosition;\n\n    if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {\n      expectedText = INLINE_FILLER + expectedText;\n    }\n\n    if (actualText != expectedText) {\n      const actions = fastDiff(actualText, expectedText);\n\n      for (const action of actions) {\n        if (action.type === 'insert') {\n          domText.insertData(action.index, action.values.join(''));\n        } else {\n          // 'delete'\n          domText.deleteData(action.index, action.howMany);\n        }\n      }\n    }\n  }\n  /**\n   * Checks if attribute list needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} viewElement The view element to update.\n   */\n\n\n  _updateAttrs(viewElement) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n\n    if (!domElement) {\n      // If there is no `domElement` it means that 'viewElement' is outdated as its mapping was updated\n      // in 'this._updateChildrenMappings()'. There is no need to process it as new view element which\n      // replaced old 'viewElement' mapping was also added to 'this.markedAttributes'\n      // in 'this._updateChildrenMappings()' so it will be processed separately.\n      return;\n    }\n\n    const domAttrKeys = Array.from(domElement.attributes).map(attr => attr.name);\n    const viewAttrKeys = viewElement.getAttributeKeys(); // Add or overwrite attributes.\n\n    for (const key of viewAttrKeys) {\n      this.domConverter.setDomElementAttribute(domElement, key, viewElement.getAttribute(key), viewElement);\n    } // Remove from DOM attributes which do not exists in the view.\n\n\n    for (const key of domAttrKeys) {\n      // All other attributes not present in the DOM should be removed.\n      if (!viewElement.hasAttribute(key)) {\n        this.domConverter.removeDomElementAttribute(domElement, key);\n      }\n    }\n  }\n  /**\n   * Checks if elements child list needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} viewElement View element to update.\n   * @param {Object} options\n   * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n   * filler should be rendered.\n   */\n\n\n  _updateChildren(viewElement, options) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n\n    if (!domElement) {\n      // If there is no `domElement` it means that it was already removed from DOM.\n      // There is no need to process it. It will be processed when re-inserted.\n      return;\n    }\n\n    const inlineFillerPosition = options.inlineFillerPosition;\n    const actualDomChildren = this.domConverter.mapViewToDom(viewElement).childNodes;\n    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, domElement.ownerDocument, {\n      bind: true\n    })); // Inline filler element has to be created as it is present in the DOM, but not in the view. It is required\n    // during diffing so text nodes could be compared correctly and also during rendering to maintain\n    // proper order and indexes while updating the DOM.\n\n    if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {\n      addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);\n    }\n\n    const diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n\n    let i = 0;\n    const nodesToUnbind = new Set(); // Handle deletions first.\n    // This is to prevent a situation where an element that already exists in `actualDomChildren` is inserted at a different\n    // index in `actualDomChildren`. Since `actualDomChildren` is a `NodeList`, this works like move, not like an insert,\n    // and it disrupts the whole algorithm. See https://github.com/ckeditor/ckeditor5/issues/6367.\n    //\n    // It doesn't matter in what order we remove or add nodes, as long as we remove and add correct nodes at correct indexes.\n\n    for (const action of diff) {\n      if (action === 'delete') {\n        nodesToUnbind.add(actualDomChildren[i]);\n        remove(actualDomChildren[i]);\n      } else if (action === 'equal') {\n        i++;\n      }\n    }\n\n    i = 0;\n\n    for (const action of diff) {\n      if (action === 'insert') {\n        insertAt(domElement, i, expectedDomChildren[i]);\n        i++;\n      } else if (action === 'equal') {\n        // Force updating text nodes inside elements which did not change and do not need to be re-rendered (#1125).\n        // Do it here (not in the loop above) because only after insertions the `i` index is correct.\n        this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i]));\n\n        i++;\n      }\n    } // Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during\n    // comparison with the expected DOM. We don't need to check child nodes, because if child node was reinserted,\n    // it was moved to DOM tree out of the removed node.\n\n\n    for (const node of nodesToUnbind) {\n      if (!node.parentNode) {\n        this.domConverter.unbindDomElement(node);\n      }\n    }\n  }\n  /**\n   * Shorthand for diffing two arrays or node lists of DOM nodes.\n   *\n   * @private\n   * @param {Array.<Node>|NodeList} actualDomChildren Actual DOM children\n   * @param {Array.<Node>|NodeList} expectedDomChildren Expected DOM children.\n   * @returns {Array.<String>} The list of actions based on the {@link module:utils/diff~diff} function.\n   */\n\n\n  _diffNodeLists(actualDomChildren, expectedDomChildren) {\n    actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);\n    return diff(actualDomChildren, expectedDomChildren, sameNodes.bind(null, this.domConverter));\n  }\n  /**\n   * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared\n   * within one `insert`/`delete` action group, for example:\n   *\n   * \t\tActual DOM:\t\t<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>\n   * \t\tExpected DOM:\t<p>Bar<b>123</b><i>Baz</i><b>456</b></p>\n   * \t\tInput actions:\t[ insert, insert, delete, delete, equal, insert, delete ]\n   * \t\tOutput actions:\t[ insert, replace, delete, equal, replace ]\n   *\n   * @private\n   * @param {Array.<String>} actions Actions array which is a result of the {@link module:utils/diff~diff} function.\n   * @param {Array.<Node>|NodeList} actualDom Actual DOM children\n   * @param {Array.<Node>} expectedDom Expected DOM children.\n   * @returns {Array.<String>} Actions array modified with the `replace` actions.\n   */\n\n\n  _findReplaceActions(actions, actualDom, expectedDom) {\n    // If there is no both 'insert' and 'delete' actions, no need to check for replaced elements.\n    if (actions.indexOf('insert') === -1 || actions.indexOf('delete') === -1) {\n      return actions;\n    }\n\n    let newActions = [];\n    let actualSlice = [];\n    let expectedSlice = [];\n    const counter = {\n      equal: 0,\n      insert: 0,\n      delete: 0\n    };\n\n    for (const action of actions) {\n      if (action === 'insert') {\n        expectedSlice.push(expectedDom[counter.equal + counter.insert]);\n      } else if (action === 'delete') {\n        actualSlice.push(actualDom[counter.equal + counter.delete]);\n      } else {\n        // equal\n        newActions = newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(x => x === 'equal' ? 'replace' : x));\n        newActions.push('equal'); // Reset stored elements on 'equal'.\n\n        actualSlice = [];\n        expectedSlice = [];\n      }\n\n      counter[action]++;\n    }\n\n    return newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(x => x === 'equal' ? 'replace' : x));\n  }\n  /**\n   * Marks text nodes to be synchronized.\n   *\n   * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.\n   *\n   * @private\n   * @param {module:engine/view/node~Node} viewNode View node to sync.\n   */\n\n\n  _markDescendantTextToSync(viewNode) {\n    if (!viewNode) {\n      return;\n    }\n\n    if (viewNode.is('$text')) {\n      this.markedTexts.add(viewNode);\n    } else if (viewNode.is('element')) {\n      for (const child of viewNode.getChildren()) {\n        this._markDescendantTextToSync(child);\n      }\n    }\n  }\n  /**\n   * Checks if the selection needs to be updated and possibly updates it.\n   *\n   * @private\n   */\n\n\n  _updateSelection() {\n    // Block updating DOM selection in (non-Android) Blink while the user is selecting to prevent accidental selection collapsing.\n    // Note: Structural changes in DOM must trigger selection rendering, though. Nodes the selection was anchored\n    // to, may disappear in DOM which would break the selection (e.g. in real-time collaboration scenarios).\n    // https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723\n    if (env.isBlink && !env.isAndroid && this.isSelecting && !this.markedChildren.size) {\n      return;\n    } // If there is no selection - remove DOM and fake selections.\n\n\n    if (this.selection.rangeCount === 0) {\n      this._removeDomSelection();\n\n      this._removeFakeSelection();\n\n      return;\n    }\n\n    const domRoot = this.domConverter.mapViewToDom(this.selection.editableElement); // Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.\n\n    if (!this.isFocused || !domRoot) {\n      return;\n    } // Render selection.\n\n\n    if (this.selection.isFake) {\n      this._updateFakeSelection(domRoot);\n    } else {\n      this._removeFakeSelection();\n\n      this._updateDomSelection(domRoot);\n    }\n  }\n  /**\n   * Updates the fake selection.\n   *\n   * @private\n   * @param {HTMLElement} domRoot A valid DOM root where the fake selection container should be added.\n   */\n\n\n  _updateFakeSelection(domRoot) {\n    const domDocument = domRoot.ownerDocument;\n\n    if (!this._fakeSelectionContainer) {\n      this._fakeSelectionContainer = createFakeSelectionContainer(domDocument);\n    }\n\n    const container = this._fakeSelectionContainer; // Bind fake selection container with the current selection *position*.\n\n    this.domConverter.bindFakeSelection(container, this.selection);\n\n    if (!this._fakeSelectionNeedsUpdate(domRoot)) {\n      return;\n    }\n\n    if (!container.parentElement || container.parentElement != domRoot) {\n      domRoot.appendChild(container);\n    }\n\n    container.textContent = this.selection.fakeSelectionLabel || '\\u00A0';\n    const domSelection = domDocument.getSelection();\n    const domRange = domDocument.createRange();\n    domSelection.removeAllRanges();\n    domRange.selectNodeContents(container);\n    domSelection.addRange(domRange);\n  }\n  /**\n   * Updates the DOM selection.\n   *\n   * @private\n   * @param {HTMLElement} domRoot A valid DOM root where the DOM selection should be rendered.\n   */\n\n\n  _updateDomSelection(domRoot) {\n    const domSelection = domRoot.ownerDocument.defaultView.getSelection(); // Let's check whether DOM selection needs updating at all.\n\n    if (!this._domSelectionNeedsUpdate(domSelection)) {\n      return;\n    } // Multi-range selection is not available in most browsers, and, at least in Chrome, trying to\n    // set such selection, that is not continuous, throws an error. Because of that, we will just use anchor\n    // and focus of view selection.\n    // Since we are not supporting multi-range selection, we also do not need to check if proper editable is\n    // selected. If there is any editable selected, it is okay (editable is taken from selection anchor).\n\n\n    const anchor = this.domConverter.viewPositionToDom(this.selection.anchor);\n    const focus = this.domConverter.viewPositionToDom(this.selection.focus);\n    domSelection.collapse(anchor.parent, anchor.offset);\n    domSelection.extend(focus.parent, focus.offset); // Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n\n    if (env.isGecko) {\n      fixGeckoSelectionAfterBr(focus, domSelection);\n    }\n  }\n  /**\n   * Checks whether a given DOM selection needs to be updated.\n   *\n   * @private\n   * @param {Selection} domSelection The DOM selection to check.\n   * @returns {Boolean}\n   */\n\n\n  _domSelectionNeedsUpdate(domSelection) {\n    if (!this.domConverter.isDomSelectionCorrect(domSelection)) {\n      // Current DOM selection is in incorrect position. We need to update it.\n      return true;\n    }\n\n    const oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);\n\n    if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {\n      return false;\n    } // If selection is not collapsed, it does not need to be updated if it is similar.\n\n\n    if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {\n      // Selection did not changed and is correct, do not update.\n      return false;\n    } // Selections are not similar.\n\n\n    return true;\n  }\n  /**\n   * Checks whether the fake selection needs to be updated.\n   *\n   * @private\n   * @param {HTMLElement} domRoot A valid DOM root where a new fake selection container should be added.\n   * @returns {Boolean}\n   */\n\n\n  _fakeSelectionNeedsUpdate(domRoot) {\n    const container = this._fakeSelectionContainer;\n    const domSelection = domRoot.ownerDocument.getSelection(); // Fake selection needs to be updated if there's no fake selection container, or the container currently sits\n    // in a different root.\n\n    if (!container || container.parentElement !== domRoot) {\n      return true;\n    } // Make sure that the selection actually is within the fake selection.\n\n\n    if (domSelection.anchorNode !== container && !container.contains(domSelection.anchorNode)) {\n      return true;\n    }\n\n    return container.textContent !== this.selection.fakeSelectionLabel;\n  }\n  /**\n   * Removes the DOM selection.\n   *\n   * @private\n   */\n\n\n  _removeDomSelection() {\n    for (const doc of this.domDocuments) {\n      const domSelection = doc.getSelection();\n\n      if (domSelection.rangeCount) {\n        const activeDomElement = doc.activeElement;\n        const viewElement = this.domConverter.mapDomToView(activeDomElement);\n\n        if (activeDomElement && viewElement) {\n          doc.getSelection().removeAllRanges();\n        }\n      }\n    }\n  }\n  /**\n   * Removes the fake selection.\n   *\n   * @private\n   */\n\n\n  _removeFakeSelection() {\n    const container = this._fakeSelectionContainer;\n\n    if (container) {\n      container.remove();\n    }\n  }\n  /**\n   * Checks if focus needs to be updated and possibly updates it.\n   *\n   * @private\n   */\n\n\n  _updateFocus() {\n    if (this.isFocused) {\n      const editable = this.selection.editableElement;\n\n      if (editable) {\n        this.domConverter.focus(editable);\n      }\n    }\n  }\n\n}\nmix(Renderer, ObservableMixin); // Checks if provided element is editable.\n//\n// @private\n// @param {module:engine/view/element~Element} element\n// @returns {Boolean}\n\nfunction isEditable(element) {\n  if (element.getAttribute('contenteditable') == 'false') {\n    return false;\n  }\n\n  const parent = element.findAncestor(element => element.hasAttribute('contenteditable'));\n  return !parent || parent.getAttribute('contenteditable') == 'true';\n} // Adds inline filler at a given position.\n//\n// The position can be given as an array of DOM nodes and an offset in that array,\n// or a DOM parent element and an offset in that element.\n//\n// @private\n// @param {Document} domDocument\n// @param {Element|Array.<Node>} domParentOrArray\n// @param {Number} offset\n// @returns {Text} The DOM text node that contains an inline filler.\n\n\nfunction addInlineFiller(domDocument, domParentOrArray, offset) {\n  const childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;\n  const nodeAfterFiller = childNodes[offset];\n\n  if (isText(nodeAfterFiller)) {\n    nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;\n    return nodeAfterFiller;\n  } else {\n    const fillerNode = domDocument.createTextNode(INLINE_FILLER);\n\n    if (Array.isArray(domParentOrArray)) {\n      childNodes.splice(offset, 0, fillerNode);\n    } else {\n      insertAt(domParentOrArray, offset, fillerNode);\n    }\n\n    return fillerNode;\n  }\n} // Whether two DOM nodes should be considered as similar.\n// Nodes are considered similar if they have the same tag name.\n//\n// @private\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\n\n\nfunction areSimilar(node1, node2) {\n  return isNode(node1) && isNode(node2) && !isText(node1) && !isText(node2) && !isComment(node1) && !isComment(node2) && node1.tagName.toLowerCase() === node2.tagName.toLowerCase();\n} // Whether two dom nodes should be considered as the same.\n// Two nodes which are considered the same are:\n//\n//\t\t* Text nodes with the same text.\n//\t\t* Element nodes represented by the same object.\n//\t\t* Two block filler elements.\n//\n// @private\n// @param {String} blockFillerMode Block filler mode, see {@link module:engine/view/domconverter~DomConverter#blockFillerMode}.\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\n\n\nfunction sameNodes(domConverter, actualDomChild, expectedDomChild) {\n  // Elements.\n  if (actualDomChild === expectedDomChild) {\n    return true;\n  } // Texts.\n  else if (isText(actualDomChild) && isText(expectedDomChild)) {\n    return actualDomChild.data === expectedDomChild.data;\n  } // Block fillers.\n  else if (domConverter.isBlockFiller(actualDomChild) && domConverter.isBlockFiller(expectedDomChild)) {\n    return true;\n  } // Not matching types.\n\n\n  return false;\n} // The following is a Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n// When the native DOM selection is at the end of the block and preceded by <br /> e.g.\n//\n//\t\t<p>foo<br/>[]</p>\n//\n// which happens a lot when using the soft line break, the browser fails to (visually) move the\n// caret to the new line. A quick fix is as simple as force–refreshing the selection with the same range.\n\n\nfunction fixGeckoSelectionAfterBr(focus, domSelection) {\n  const parent = focus.parent; // This fix works only when the focus point is at the very end of an element.\n  // There is no point in running it in cases unrelated to the browser bug.\n\n  if (parent.nodeType != Node.ELEMENT_NODE || focus.offset != parent.childNodes.length - 1) {\n    return;\n  }\n\n  const childAtOffset = parent.childNodes[focus.offset]; // To stay on the safe side, the fix being as specific as possible, it targets only the\n  // selection which is at the very end of the element and preceded by <br />.\n\n  if (childAtOffset && childAtOffset.tagName == 'BR') {\n    domSelection.addRange(domSelection.getRangeAt(0));\n  }\n}\n\nfunction filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {\n  const childList = Array.from(domChildList);\n\n  if (childList.length == 0 || !fakeSelectionContainer) {\n    return childList;\n  }\n\n  const last = childList[childList.length - 1];\n\n  if (last == fakeSelectionContainer) {\n    childList.pop();\n  }\n\n  return childList;\n} // Creates a fake selection container for a given document.\n//\n// @private\n// @param {Document} domDocument\n// @returns {HTMLElement}\n\n\nfunction createFakeSelectionContainer(domDocument) {\n  const container = domDocument.createElement('div');\n  container.className = 'ck-fake-selection-container';\n  Object.assign(container.style, {\n    position: 'fixed',\n    top: 0,\n    left: '-9999px',\n    // See https://github.com/ckeditor/ckeditor5/issues/752.\n    width: '42px'\n  }); // Fill it with a text node so we can update it later.\n\n  container.textContent = '\\u00A0';\n  return container;\n}","map":{"version":3,"names":["ViewText","ViewPosition","INLINE_FILLER","INLINE_FILLER_LENGTH","startsWithFiller","isInlineFiller","mix","diff","insertAt","remove","ObservableMixin","CKEditorError","isText","isComment","isNode","fastDiff","env","Renderer","constructor","domConverter","selection","domDocuments","Set","markedAttributes","markedChildren","markedTexts","set","isBlink","isAndroid","on","isSelecting","render","_inlineFiller","_fakeSelectionContainer","markToSync","type","node","mapViewToDom","parent","add","inlineFillerPosition","isInlineFillerRenderingPossible","element","_updateChildrenMappings","_isSelectionInInlineFiller","_removeInlineFiller","_getInlineFillerPosition","_needsInlineFillerAtSelection","getFirstPosition","parentNode","domPositionToView","_updateAttrs","_updateChildren","has","_updateText","fillerDomPosition","viewPositionToDom","domDocument","ownerDocument","addInlineFiller","offset","_updateFocus","_updateSelection","clear","viewElement","domElement","actualDomChildren","Array","from","childNodes","expectedDomChildren","viewChildrenToDom","withChildren","_diffNodeLists","actions","_findReplaceActions","indexOf","counter","equal","insert","delete","action","insertIndex","deleteIndex","viewChild","getChild","is","_updateElementMappings","unbindDomElement","bindElements","firstPos","_createBefore","rangeCount","isCollapsed","selectionPosition","position","domFillerNode","data","substr","selectionParent","selectionOffset","root","isEditable","getFillerOffset","nodeBefore","nodeAfter","viewText","options","domText","findCorrespondingDomText","newDomText","viewToDom","actualText","expectedText","filler","index","insertData","values","join","deleteData","howMany","domAttrKeys","attributes","map","attr","name","viewAttrKeys","getAttributeKeys","key","setDomElementAttribute","getAttribute","hasAttribute","removeDomElementAttribute","bind","i","nodesToUnbind","_markDescendantTextToSync","domToView","filterOutFakeSelectionContainer","sameNodes","actualDom","expectedDom","newActions","actualSlice","expectedSlice","push","concat","areSimilar","x","viewNode","child","getChildren","size","_removeDomSelection","_removeFakeSelection","domRoot","editableElement","isFocused","isFake","_updateFakeSelection","_updateDomSelection","createFakeSelectionContainer","container","bindFakeSelection","_fakeSelectionNeedsUpdate","parentElement","appendChild","textContent","fakeSelectionLabel","domSelection","getSelection","domRange","createRange","removeAllRanges","selectNodeContents","addRange","defaultView","_domSelectionNeedsUpdate","anchor","focus","collapse","extend","isGecko","fixGeckoSelectionAfterBr","isDomSelectionCorrect","oldViewSelection","domSelectionToView","isEqual","isSimilar","anchorNode","contains","doc","activeDomElement","activeElement","mapDomToView","editable","findAncestor","domParentOrArray","nodeAfterFiller","fillerNode","createTextNode","isArray","splice","node1","node2","tagName","toLowerCase","actualDomChild","expectedDomChild","isBlockFiller","nodeType","Node","ELEMENT_NODE","length","childAtOffset","getRangeAt","domChildList","fakeSelectionContainer","childList","last","pop","createElement","className","Object","assign","style","top","left","width"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/view/renderer.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals Node */\n\n/**\n * @module engine/view/renderer\n */\n\nimport ViewText from './text';\nimport ViewPosition from './position';\nimport { INLINE_FILLER, INLINE_FILLER_LENGTH, startsWithFiller, isInlineFiller } from './filler';\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport insertAt from '@ckeditor/ckeditor5-utils/src/dom/insertat';\nimport remove from '@ckeditor/ckeditor5-utils/src/dom/remove';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isComment from '@ckeditor/ckeditor5-utils/src/dom/iscomment';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport fastDiff from '@ckeditor/ckeditor5-utils/src/fastdiff';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\n\nimport '../../theme/renderer.css';\n\n/**\n * Renderer is responsible for updating the DOM structure and the DOM selection based on\n * the {@link module:engine/view/renderer~Renderer#markToSync information about updated view nodes}.\n * In other words, it renders the view to the DOM.\n *\n * Its main responsibility is to make only the necessary, minimal changes to the DOM. However, unlike in many\n * virtual DOM implementations, the primary reason for doing minimal changes is not the performance but ensuring\n * that native editing features such as text composition, autocompletion, spell checking, selection's x-index are\n * affected as little as possible.\n *\n * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform view nodes and positions\n * to and from the DOM.\n */\nexport default class Renderer {\n\t/**\n\t * Creates a renderer instance.\n\t *\n\t * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.\n\t * @param {module:engine/view/documentselection~DocumentSelection} selection View selection.\n\t */\n\tconstructor( domConverter, selection ) {\n\t\t/**\n\t\t * Set of DOM Documents instances.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<Document>}\n\t\t */\n\t\tthis.domDocuments = new Set();\n\n\t\t/**\n\t\t * Converter instance.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/domconverter~DomConverter}\n\t\t */\n\t\tthis.domConverter = domConverter;\n\n\t\t/**\n\t\t * Set of nodes which attributes changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedAttributes = new Set();\n\n\t\t/**\n\t\t * Set of elements which child lists changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedChildren = new Set();\n\n\t\t/**\n\t\t * Set of text nodes which text data changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedTexts = new Set();\n\n\t\t/**\n\t\t * View selection. Renderer updates DOM selection based on the view selection.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/documentselection~DocumentSelection}\n\t\t */\n\t\tthis.selection = selection;\n\n\t\t/**\n\t\t * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if\n\t\t * this is set to `false`.\n\t\t *\n\t\t * @member {Boolean}\n\t\t * @observable\n\t\t */\n\t\tthis.set( 'isFocused', false );\n\n\t\t/**\n\t\t * Indicates whether the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n\t\t * When they stop selecting, the property goes back to `false`.\n\t\t *\n\t\t * Note: In some browsers, the renderer will stop rendering the selection and inline fillers while the user is making\n\t\t * a selection to avoid glitches in DOM selection\n\t\t * (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\t\t *\n\t\t * @member {Boolean}\n\t\t * @observable\n\t\t */\n\t\tthis.set( 'isSelecting', false );\n\n\t\t// Rendering the selection and inline filler manipulation should be postponed in (non-Android) Blink until the user finishes\n\t\t// creating the selection in DOM to avoid accidental selection collapsing\n\t\t// (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\t\t// When the user stops selecting, all pending changes should be rendered ASAP, though.\n\t\tif ( env.isBlink && !env.isAndroid ) {\n\t\t\tthis.on( 'change:isSelecting', () => {\n\t\t\t\tif ( !this.isSelecting ) {\n\t\t\t\t\tthis.render();\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t/**\n\t\t * The text node in which the inline filler was rendered.\n\t\t *\n\t\t * @private\n\t\t * @member {Text}\n\t\t */\n\t\tthis._inlineFiller = null;\n\n\t\t/**\n\t\t * DOM element containing fake selection.\n\t\t *\n\t\t * @private\n\t\t * @type {null|HTMLElement}\n\t\t */\n\t\tthis._fakeSelectionContainer = null;\n\t}\n\n\t/**\n\t * Marks a view node to be updated in the DOM by {@link #render `render()`}.\n\t *\n\t * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.\n\t *\n\t * @see #markedAttributes\n\t * @see #markedChildren\n\t * @see #markedTexts\n\t *\n\t * @param {module:engine/view/document~ChangeType} type Type of the change.\n\t * @param {module:engine/view/node~Node} node Node to be marked.\n\t */\n\tmarkToSync( type, node ) {\n\t\tif ( type === 'text' ) {\n\t\t\tif ( this.domConverter.mapViewToDom( node.parent ) ) {\n\t\t\t\tthis.markedTexts.add( node );\n\t\t\t}\n\t\t} else {\n\t\t\t// If the node has no DOM element it is not rendered yet,\n\t\t\t// its children/attributes do not need to be marked to be sync.\n\t\t\tif ( !this.domConverter.mapViewToDom( node ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( type === 'attributes' ) {\n\t\t\t\tthis.markedAttributes.add( node );\n\t\t\t} else if ( type === 'children' ) {\n\t\t\t\tthis.markedChildren.add( node );\n\t\t\t} else {\n\t\t\t\t/**\n\t\t\t\t * Unknown type passed to Renderer.markToSync.\n\t\t\t\t *\n\t\t\t\t * @error view-renderer-unknown-type\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'view-renderer-unknown-type', this );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and\n\t * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.\n\t *\n\t * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,\n\t * so it does as little as it is needed to update the DOM.\n\t *\n\t * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed\n\t * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be\n\t * removed as long as the selection is in the text node which needed it at first.\n\t */\n\trender() {\n\t\tlet inlineFillerPosition;\n\t\tconst isInlineFillerRenderingPossible = env.isBlink && !env.isAndroid ? !this.isSelecting : true;\n\n\t\t// Refresh mappings.\n\t\tfor ( const element of this.markedChildren ) {\n\t\t\tthis._updateChildrenMappings( element );\n\t\t}\n\n\t\t// Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n\t\t// DOM selection collapsing\n\t\t// (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\t\tif ( isInlineFillerRenderingPossible ) {\n\t\t\t// There was inline filler rendered in the DOM but it's not\n\t\t\t// at the selection position any more, so we can remove it\n\t\t\t// (cause even if it's needed, it must be placed in another location).\n\t\t\tif ( this._inlineFiller && !this._isSelectionInInlineFiller() ) {\n\t\t\t\tthis._removeInlineFiller();\n\t\t\t}\n\n\t\t\t// If we've got the filler, let's try to guess its position in the view.\n\t\t\tif ( this._inlineFiller ) {\n\t\t\t\tinlineFillerPosition = this._getInlineFillerPosition();\n\t\t\t}\n\t\t\t// Otherwise, if it's needed, create it at the selection position.\n\t\t\telse if ( this._needsInlineFillerAtSelection() ) {\n\t\t\t\tinlineFillerPosition = this.selection.getFirstPosition();\n\n\t\t\t\t// Do not use `markToSync` so it will be added even if the parent is already added.\n\t\t\t\tthis.markedChildren.add( inlineFillerPosition.parent );\n\t\t\t}\n\t\t}\n\t\t// Paranoid check: we make sure the inline filler has any parent so it can be mapped to view position\n\t\t// by DomConverter.\n\t\telse if ( this._inlineFiller && this._inlineFiller.parentNode ) {\n\t\t\t// While the user is making selection, preserve the inline filler at its original position.\n\t\t\tinlineFillerPosition = this.domConverter.domPositionToView( this._inlineFiller );\n\t\t}\n\n\t\tfor ( const element of this.markedAttributes ) {\n\t\t\tthis._updateAttrs( element );\n\t\t}\n\n\t\tfor ( const element of this.markedChildren ) {\n\t\t\tthis._updateChildren( element, { inlineFillerPosition } );\n\t\t}\n\n\t\tfor ( const node of this.markedTexts ) {\n\t\t\tif ( !this.markedChildren.has( node.parent ) && this.domConverter.mapViewToDom( node.parent ) ) {\n\t\t\t\tthis._updateText( node, { inlineFillerPosition } );\n\t\t\t}\n\t\t}\n\n\t\t// * Check whether the inline filler is required and where it really is in the DOM.\n\t\t//   At this point in most cases it will be in the DOM, but there are exceptions.\n\t\t//   For example, if the inline filler was deep in the created DOM structure, it will not be created.\n\t\t//   Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,\n\t\t//   it will not be present. Fix those and similar scenarios.\n\t\t// * Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n\t\t//   DOM selection collapsing\n\t\t//   (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\t\tif ( isInlineFillerRenderingPossible ) {\n\t\t\tif ( inlineFillerPosition ) {\n\t\t\t\tconst fillerDomPosition = this.domConverter.viewPositionToDom( inlineFillerPosition );\n\t\t\t\tconst domDocument = fillerDomPosition.parent.ownerDocument;\n\n\t\t\t\tif ( !startsWithFiller( fillerDomPosition.parent ) ) {\n\t\t\t\t\t// Filler has not been created at filler position. Create it now.\n\t\t\t\t\tthis._inlineFiller = addInlineFiller( domDocument, fillerDomPosition.parent, fillerDomPosition.offset );\n\t\t\t\t} else {\n\t\t\t\t\t// Filler has been found, save it.\n\t\t\t\t\tthis._inlineFiller = fillerDomPosition.parent;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is no filler needed.\n\t\t\t\tthis._inlineFiller = null;\n\t\t\t}\n\t\t}\n\n\t\t// First focus the new editing host, then update the selection.\n\t\t// Otherwise, FF may throw an error (https://github.com/ckeditor/ckeditor5/issues/721).\n\t\tthis._updateFocus();\n\t\tthis._updateSelection();\n\n\t\tthis.markedTexts.clear();\n\t\tthis.markedAttributes.clear();\n\t\tthis.markedChildren.clear();\n\t}\n\n\t/**\n\t * Updates mappings of view element's children.\n\t *\n\t * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.\n\t * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.\n\t * Thanks to that these elements do not need to be re-rendered completely.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewElement The view element whose children mappings will be updated.\n\t */\n\t_updateChildrenMappings( viewElement ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that it was already removed from DOM and there is no need to process it.\n\t\t\treturn;\n\t\t}\n\n\t\t// Removing nodes from the DOM as we iterate can cause `actualDomChildren`\n\t\t// (which is a live-updating `NodeList`) to get out of sync with the\n\t\t// indices that we compute as we iterate over `actions`.\n\t\t// This would produce incorrect element mappings.\n\t\t//\n\t\t// Converting live list to an array to make the list static.\n\t\tconst actualDomChildren = Array.from(\n\t\t\tthis.domConverter.mapViewToDom( viewElement ).childNodes\n\t\t);\n\t\tconst expectedDomChildren = Array.from(\n\t\t\tthis.domConverter.viewChildrenToDom( viewElement, domElement.ownerDocument, { withChildren: false } )\n\t\t);\n\t\tconst diff = this._diffNodeLists( actualDomChildren, expectedDomChildren );\n\t\tconst actions = this._findReplaceActions( diff, actualDomChildren, expectedDomChildren );\n\n\t\tif ( actions.indexOf( 'replace' ) !== -1 ) {\n\t\t\tconst counter = { equal: 0, insert: 0, delete: 0 };\n\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action === 'replace' ) {\n\t\t\t\t\tconst insertIndex = counter.equal + counter.insert;\n\t\t\t\t\tconst deleteIndex = counter.equal + counter.delete;\n\t\t\t\t\tconst viewChild = viewElement.getChild( insertIndex );\n\n\t\t\t\t\t// UIElement and RawElement are special cases. Their children are not stored in a view (#799)\n\t\t\t\t\t// so we cannot use them with replacing flow (since they use view children during rendering\n\t\t\t\t\t// which will always result in rendering empty elements).\n\t\t\t\t\tif ( viewChild && !( viewChild.is( 'uiElement' ) || viewChild.is( 'rawElement' ) ) ) {\n\t\t\t\t\t\tthis._updateElementMappings( viewChild, actualDomChildren[ deleteIndex ] );\n\t\t\t\t\t}\n\n\t\t\t\t\tremove( expectedDomChildren[ insertIndex ] );\n\t\t\t\t\tcounter.equal++;\n\t\t\t\t} else {\n\t\t\t\t\tcounter[ action ]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates mappings of a given view element.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewElement The view element whose mappings will be updated.\n\t * @param {Node} domElement The DOM element representing the given view element.\n\t */\n\t_updateElementMappings( viewElement, domElement ) {\n\t\t// Remap 'DomConverter' bindings.\n\t\tthis.domConverter.unbindDomElement( domElement );\n\t\tthis.domConverter.bindElements( domElement, viewElement );\n\n\t\t// View element may have children which needs to be updated, but are not marked, mark them to update.\n\t\tthis.markedChildren.add( viewElement );\n\n\t\t// Because we replace new view element mapping with the existing one, the corresponding DOM element\n\t\t// will not be rerendered. The new view element may have different attributes than the previous one.\n\t\t// Since its corresponding DOM element will not be rerendered, new attributes will not be added\n\t\t// to the DOM, so we need to mark it here to make sure its attributes gets updated. See #1427 for more\n\t\t// detailed case study.\n\t\t// Also there are cases where replaced element is removed from the view structure and then has\n\t\t// its attributes changed or removed. In such cases the element will not be present in `markedAttributes`\n\t\t// and also may be the same (`element.isSimilar()`) as the reused element not having its attributes updated.\n\t\t// To prevent such situations we always mark reused element to have its attributes rerenderd (#1560).\n\t\tthis.markedAttributes.add( viewElement );\n\t}\n\n\t/**\n\t * Gets the position of the inline filler based on the current selection.\n\t * Here, we assume that we know that the filler is needed and\n\t * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,\n\t * it is somewhere at the selection position.\n\t *\n\t * Note: The filler position cannot be restored based on the filler's DOM text node, because\n\t * when this method is called (before rendering), the bindings will often be broken. View-to-DOM\n\t * bindings are only dependable after rendering.\n\t *\n\t * @private\n\t * @returns {module:engine/view/position~Position}\n\t */\n\t_getInlineFillerPosition() {\n\t\tconst firstPos = this.selection.getFirstPosition();\n\n\t\tif ( firstPos.parent.is( '$text' ) ) {\n\t\t\treturn ViewPosition._createBefore( this.selection.getFirstPosition().parent );\n\t\t} else {\n\t\t\treturn firstPos;\n\t\t}\n\t}\n\n\t/**\n\t * Returns `true` if the selection has not left the inline filler's text node.\n\t * If it is `true`, it means that the filler had been added for a reason and the selection did not\n\t * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.\n\t *\n\t * @private\n\t * @returns {Boolean} `true` if the inline filler and selection are in the same place.\n\t */\n\t_isSelectionInInlineFiller() {\n\t\tif ( this.selection.rangeCount != 1 || !this.selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Note, we can't check if selection's position equals position of the\n\t\t// this._inlineFiller node, because of #663. We may not be able to calculate\n\t\t// the filler's position in the view at this stage.\n\t\t// Instead, we check it the other way – whether selection is anchored in\n\t\t// that text node or next to it.\n\n\t\t// Possible options are:\n\t\t// \"FILLER{}\"\n\t\t// \"FILLERadded-text{}\"\n\t\tconst selectionPosition = this.selection.getFirstPosition();\n\t\tconst position = this.domConverter.viewPositionToDom( selectionPosition );\n\n\t\tif ( position && isText( position.parent ) && startsWithFiller( position.parent ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Removes the inline filler.\n\t *\n\t * @private\n\t */\n\t_removeInlineFiller() {\n\t\tconst domFillerNode = this._inlineFiller;\n\n\t\t// Something weird happened and the stored node doesn't contain the filler's text.\n\t\tif ( !startsWithFiller( domFillerNode ) ) {\n\t\t\t/**\n\t\t\t * The inline filler node was lost. Most likely, something overwrote the filler text node\n\t\t\t * in the DOM.\n\t\t\t *\n\t\t\t * @error view-renderer-filler-was-lost\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-renderer-filler-was-lost', this );\n\t\t}\n\n\t\tif ( isInlineFiller( domFillerNode ) ) {\n\t\t\tdomFillerNode.remove();\n\t\t} else {\n\t\t\tdomFillerNode.data = domFillerNode.data.substr( INLINE_FILLER_LENGTH );\n\t\t}\n\n\t\tthis._inlineFiller = null;\n\t}\n\n\t/**\n\t * Checks if the inline {@link module:engine/view/filler filler} should be added.\n\t *\n\t * @private\n\t * @returns {Boolean} `true` if the inline filler should be added.\n\t */\n\t_needsInlineFillerAtSelection() {\n\t\tif ( this.selection.rangeCount != 1 || !this.selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst selectionPosition = this.selection.getFirstPosition();\n\t\tconst selectionParent = selectionPosition.parent;\n\t\tconst selectionOffset = selectionPosition.offset;\n\n\t\t// If there is no DOM root we do not care about fillers.\n\t\tif ( !this.domConverter.mapViewToDom( selectionParent.root ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !( selectionParent.is( 'element' ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Prevent adding inline filler inside elements with contenteditable=false.\n\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/1170\n\t\tif ( !isEditable( selectionParent ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We have block filler, we do not need inline one.\n\t\tif ( selectionOffset === selectionParent.getFillerOffset() ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst nodeBefore = selectionPosition.nodeBefore;\n\t\tconst nodeAfter = selectionPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof ViewText || nodeAfter instanceof ViewText ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if text needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} viewText View text to update.\n\t * @param {Object} options\n\t * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n\t * filler should be rendered.\n\t */\n\t_updateText( viewText, options ) {\n\t\tconst domText = this.domConverter.findCorrespondingDomText( viewText );\n\t\tconst newDomText = this.domConverter.viewToDom( viewText, domText.ownerDocument );\n\n\t\tconst actualText = domText.data;\n\t\tlet expectedText = newDomText.data;\n\n\t\tconst filler = options.inlineFillerPosition;\n\n\t\tif ( filler && filler.parent == viewText.parent && filler.offset == viewText.index ) {\n\t\t\texpectedText = INLINE_FILLER + expectedText;\n\t\t}\n\n\t\tif ( actualText != expectedText ) {\n\t\t\tconst actions = fastDiff( actualText, expectedText );\n\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action.type === 'insert' ) {\n\t\t\t\t\tdomText.insertData( action.index, action.values.join( '' ) );\n\t\t\t\t} else { // 'delete'\n\t\t\t\t\tdomText.deleteData( action.index, action.howMany );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if attribute list needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewElement The view element to update.\n\t */\n\t_updateAttrs( viewElement ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that 'viewElement' is outdated as its mapping was updated\n\t\t\t// in 'this._updateChildrenMappings()'. There is no need to process it as new view element which\n\t\t\t// replaced old 'viewElement' mapping was also added to 'this.markedAttributes'\n\t\t\t// in 'this._updateChildrenMappings()' so it will be processed separately.\n\t\t\treturn;\n\t\t}\n\n\t\tconst domAttrKeys = Array.from( domElement.attributes ).map( attr => attr.name );\n\t\tconst viewAttrKeys = viewElement.getAttributeKeys();\n\n\t\t// Add or overwrite attributes.\n\t\tfor ( const key of viewAttrKeys ) {\n\t\t\tthis.domConverter.setDomElementAttribute( domElement, key, viewElement.getAttribute( key ), viewElement );\n\t\t}\n\n\t\t// Remove from DOM attributes which do not exists in the view.\n\t\tfor ( const key of domAttrKeys ) {\n\t\t\t// All other attributes not present in the DOM should be removed.\n\t\t\tif ( !viewElement.hasAttribute( key ) ) {\n\t\t\t\tthis.domConverter.removeDomElementAttribute( domElement, key );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if elements child list needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewElement View element to update.\n\t * @param {Object} options\n\t * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n\t * filler should be rendered.\n\t */\n\t_updateChildren( viewElement, options ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that it was already removed from DOM.\n\t\t\t// There is no need to process it. It will be processed when re-inserted.\n\t\t\treturn;\n\t\t}\n\n\t\tconst inlineFillerPosition = options.inlineFillerPosition;\n\t\tconst actualDomChildren = this.domConverter.mapViewToDom( viewElement ).childNodes;\n\t\tconst expectedDomChildren = Array.from(\n\t\t\tthis.domConverter.viewChildrenToDom( viewElement, domElement.ownerDocument, { bind: true } )\n\t\t);\n\n\t\t// Inline filler element has to be created as it is present in the DOM, but not in the view. It is required\n\t\t// during diffing so text nodes could be compared correctly and also during rendering to maintain\n\t\t// proper order and indexes while updating the DOM.\n\t\tif ( inlineFillerPosition && inlineFillerPosition.parent === viewElement ) {\n\t\t\taddInlineFiller( domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset );\n\t\t}\n\n\t\tconst diff = this._diffNodeLists( actualDomChildren, expectedDomChildren );\n\n\t\tlet i = 0;\n\t\tconst nodesToUnbind = new Set();\n\n\t\t// Handle deletions first.\n\t\t// This is to prevent a situation where an element that already exists in `actualDomChildren` is inserted at a different\n\t\t// index in `actualDomChildren`. Since `actualDomChildren` is a `NodeList`, this works like move, not like an insert,\n\t\t// and it disrupts the whole algorithm. See https://github.com/ckeditor/ckeditor5/issues/6367.\n\t\t//\n\t\t// It doesn't matter in what order we remove or add nodes, as long as we remove and add correct nodes at correct indexes.\n\t\tfor ( const action of diff ) {\n\t\t\tif ( action === 'delete' ) {\n\t\t\t\tnodesToUnbind.add( actualDomChildren[ i ] );\n\t\t\t\tremove( actualDomChildren[ i ] );\n\t\t\t} else if ( action === 'equal' ) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\ti = 0;\n\n\t\tfor ( const action of diff ) {\n\t\t\tif ( action === 'insert' ) {\n\t\t\t\tinsertAt( domElement, i, expectedDomChildren[ i ] );\n\t\t\t\ti++;\n\t\t\t} else if ( action === 'equal' ) {\n\t\t\t\t// Force updating text nodes inside elements which did not change and do not need to be re-rendered (#1125).\n\t\t\t\t// Do it here (not in the loop above) because only after insertions the `i` index is correct.\n\t\t\t\tthis._markDescendantTextToSync( this.domConverter.domToView( expectedDomChildren[ i ] ) );\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t// Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during\n\t\t// comparison with the expected DOM. We don't need to check child nodes, because if child node was reinserted,\n\t\t// it was moved to DOM tree out of the removed node.\n\t\tfor ( const node of nodesToUnbind ) {\n\t\t\tif ( !node.parentNode ) {\n\t\t\t\tthis.domConverter.unbindDomElement( node );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Shorthand for diffing two arrays or node lists of DOM nodes.\n\t *\n\t * @private\n\t * @param {Array.<Node>|NodeList} actualDomChildren Actual DOM children\n\t * @param {Array.<Node>|NodeList} expectedDomChildren Expected DOM children.\n\t * @returns {Array.<String>} The list of actions based on the {@link module:utils/diff~diff} function.\n\t */\n\t_diffNodeLists( actualDomChildren, expectedDomChildren ) {\n\t\tactualDomChildren = filterOutFakeSelectionContainer( actualDomChildren, this._fakeSelectionContainer );\n\n\t\treturn diff( actualDomChildren, expectedDomChildren, sameNodes.bind( null, this.domConverter ) );\n\t}\n\n\t/**\n\t * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared\n\t * within one `insert`/`delete` action group, for example:\n\t *\n\t * \t\tActual DOM:\t\t<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>\n\t * \t\tExpected DOM:\t<p>Bar<b>123</b><i>Baz</i><b>456</b></p>\n\t * \t\tInput actions:\t[ insert, insert, delete, delete, equal, insert, delete ]\n\t * \t\tOutput actions:\t[ insert, replace, delete, equal, replace ]\n\t *\n\t * @private\n\t * @param {Array.<String>} actions Actions array which is a result of the {@link module:utils/diff~diff} function.\n\t * @param {Array.<Node>|NodeList} actualDom Actual DOM children\n\t * @param {Array.<Node>} expectedDom Expected DOM children.\n\t * @returns {Array.<String>} Actions array modified with the `replace` actions.\n\t */\n\t_findReplaceActions( actions, actualDom, expectedDom ) {\n\t\t// If there is no both 'insert' and 'delete' actions, no need to check for replaced elements.\n\t\tif ( actions.indexOf( 'insert' ) === -1 || actions.indexOf( 'delete' ) === -1 ) {\n\t\t\treturn actions;\n\t\t}\n\n\t\tlet newActions = [];\n\t\tlet actualSlice = [];\n\t\tlet expectedSlice = [];\n\n\t\tconst counter = { equal: 0, insert: 0, delete: 0 };\n\n\t\tfor ( const action of actions ) {\n\t\t\tif ( action === 'insert' ) {\n\t\t\t\texpectedSlice.push( expectedDom[ counter.equal + counter.insert ] );\n\t\t\t} else if ( action === 'delete' ) {\n\t\t\t\tactualSlice.push( actualDom[ counter.equal + counter.delete ] );\n\t\t\t} else { // equal\n\t\t\t\tnewActions = newActions.concat( diff( actualSlice, expectedSlice, areSimilar ).map( x => x === 'equal' ? 'replace' : x ) );\n\t\t\t\tnewActions.push( 'equal' );\n\t\t\t\t// Reset stored elements on 'equal'.\n\t\t\t\tactualSlice = [];\n\t\t\t\texpectedSlice = [];\n\t\t\t}\n\t\t\tcounter[ action ]++;\n\t\t}\n\n\t\treturn newActions.concat( diff( actualSlice, expectedSlice, areSimilar ).map( x => x === 'equal' ? 'replace' : x ) );\n\t}\n\n\t/**\n\t * Marks text nodes to be synchronized.\n\t *\n\t * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewNode View node to sync.\n\t */\n\t_markDescendantTextToSync( viewNode ) {\n\t\tif ( !viewNode ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( viewNode.is( '$text' ) ) {\n\t\t\tthis.markedTexts.add( viewNode );\n\t\t} else if ( viewNode.is( 'element' ) ) {\n\t\t\tfor ( const child of viewNode.getChildren() ) {\n\t\t\t\tthis._markDescendantTextToSync( child );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the selection needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t */\n\t_updateSelection() {\n\t\t// Block updating DOM selection in (non-Android) Blink while the user is selecting to prevent accidental selection collapsing.\n\t\t// Note: Structural changes in DOM must trigger selection rendering, though. Nodes the selection was anchored\n\t\t// to, may disappear in DOM which would break the selection (e.g. in real-time collaboration scenarios).\n\t\t// https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723\n\t\tif ( env.isBlink && !env.isAndroid && this.isSelecting && !this.markedChildren.size ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there is no selection - remove DOM and fake selections.\n\t\tif ( this.selection.rangeCount === 0 ) {\n\t\t\tthis._removeDomSelection();\n\t\t\tthis._removeFakeSelection();\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst domRoot = this.domConverter.mapViewToDom( this.selection.editableElement );\n\n\t\t// Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.\n\t\tif ( !this.isFocused || !domRoot ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Render selection.\n\t\tif ( this.selection.isFake ) {\n\t\t\tthis._updateFakeSelection( domRoot );\n\t\t} else {\n\t\t\tthis._removeFakeSelection();\n\t\t\tthis._updateDomSelection( domRoot );\n\t\t}\n\t}\n\n\t/**\n\t * Updates the fake selection.\n\t *\n\t * @private\n\t * @param {HTMLElement} domRoot A valid DOM root where the fake selection container should be added.\n\t */\n\t_updateFakeSelection( domRoot ) {\n\t\tconst domDocument = domRoot.ownerDocument;\n\n\t\tif ( !this._fakeSelectionContainer ) {\n\t\t\tthis._fakeSelectionContainer = createFakeSelectionContainer( domDocument );\n\t\t}\n\n\t\tconst container = this._fakeSelectionContainer;\n\n\t\t// Bind fake selection container with the current selection *position*.\n\t\tthis.domConverter.bindFakeSelection( container, this.selection );\n\n\t\tif ( !this._fakeSelectionNeedsUpdate( domRoot ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !container.parentElement || container.parentElement != domRoot ) {\n\t\t\tdomRoot.appendChild( container );\n\t\t}\n\n\t\tcontainer.textContent = this.selection.fakeSelectionLabel || '\\u00A0';\n\n\t\tconst domSelection = domDocument.getSelection();\n\t\tconst domRange = domDocument.createRange();\n\n\t\tdomSelection.removeAllRanges();\n\t\tdomRange.selectNodeContents( container );\n\t\tdomSelection.addRange( domRange );\n\t}\n\n\t/**\n\t * Updates the DOM selection.\n\t *\n\t * @private\n\t * @param {HTMLElement} domRoot A valid DOM root where the DOM selection should be rendered.\n\t */\n\t_updateDomSelection( domRoot ) {\n\t\tconst domSelection = domRoot.ownerDocument.defaultView.getSelection();\n\n\t\t// Let's check whether DOM selection needs updating at all.\n\t\tif ( !this._domSelectionNeedsUpdate( domSelection ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Multi-range selection is not available in most browsers, and, at least in Chrome, trying to\n\t\t// set such selection, that is not continuous, throws an error. Because of that, we will just use anchor\n\t\t// and focus of view selection.\n\t\t// Since we are not supporting multi-range selection, we also do not need to check if proper editable is\n\t\t// selected. If there is any editable selected, it is okay (editable is taken from selection anchor).\n\t\tconst anchor = this.domConverter.viewPositionToDom( this.selection.anchor );\n\t\tconst focus = this.domConverter.viewPositionToDom( this.selection.focus );\n\n\t\tdomSelection.collapse( anchor.parent, anchor.offset );\n\t\tdomSelection.extend( focus.parent, focus.offset );\n\n\t\t// Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n\t\tif ( env.isGecko ) {\n\t\t\tfixGeckoSelectionAfterBr( focus, domSelection );\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether a given DOM selection needs to be updated.\n\t *\n\t * @private\n\t * @param {Selection} domSelection The DOM selection to check.\n\t * @returns {Boolean}\n\t */\n\t_domSelectionNeedsUpdate( domSelection ) {\n\t\tif ( !this.domConverter.isDomSelectionCorrect( domSelection ) ) {\n\t\t\t// Current DOM selection is in incorrect position. We need to update it.\n\t\t\treturn true;\n\t\t}\n\n\t\tconst oldViewSelection = domSelection && this.domConverter.domSelectionToView( domSelection );\n\n\t\tif ( oldViewSelection && this.selection.isEqual( oldViewSelection ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If selection is not collapsed, it does not need to be updated if it is similar.\n\t\tif ( !this.selection.isCollapsed && this.selection.isSimilar( oldViewSelection ) ) {\n\t\t\t// Selection did not changed and is correct, do not update.\n\t\t\treturn false;\n\t\t}\n\n\t\t// Selections are not similar.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks whether the fake selection needs to be updated.\n\t *\n\t * @private\n\t * @param {HTMLElement} domRoot A valid DOM root where a new fake selection container should be added.\n\t * @returns {Boolean}\n\t */\n\t_fakeSelectionNeedsUpdate( domRoot ) {\n\t\tconst container = this._fakeSelectionContainer;\n\t\tconst domSelection = domRoot.ownerDocument.getSelection();\n\n\t\t// Fake selection needs to be updated if there's no fake selection container, or the container currently sits\n\t\t// in a different root.\n\t\tif ( !container || container.parentElement !== domRoot ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Make sure that the selection actually is within the fake selection.\n\t\tif ( domSelection.anchorNode !== container && !container.contains( domSelection.anchorNode ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn container.textContent !== this.selection.fakeSelectionLabel;\n\t}\n\n\t/**\n\t * Removes the DOM selection.\n\t *\n\t * @private\n\t */\n\t_removeDomSelection() {\n\t\tfor ( const doc of this.domDocuments ) {\n\t\t\tconst domSelection = doc.getSelection();\n\n\t\t\tif ( domSelection.rangeCount ) {\n\t\t\t\tconst activeDomElement = doc.activeElement;\n\t\t\t\tconst viewElement = this.domConverter.mapDomToView( activeDomElement );\n\n\t\t\t\tif ( activeDomElement && viewElement ) {\n\t\t\t\t\tdoc.getSelection().removeAllRanges();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes the fake selection.\n\t *\n\t * @private\n\t */\n\t_removeFakeSelection() {\n\t\tconst container = this._fakeSelectionContainer;\n\n\t\tif ( container ) {\n\t\t\tcontainer.remove();\n\t\t}\n\t}\n\n\t/**\n\t * Checks if focus needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t */\n\t_updateFocus() {\n\t\tif ( this.isFocused ) {\n\t\t\tconst editable = this.selection.editableElement;\n\n\t\t\tif ( editable ) {\n\t\t\t\tthis.domConverter.focus( editable );\n\t\t\t}\n\t\t}\n\t}\n}\n\nmix( Renderer, ObservableMixin );\n\n// Checks if provided element is editable.\n//\n// @private\n// @param {module:engine/view/element~Element} element\n// @returns {Boolean}\nfunction isEditable( element ) {\n\tif ( element.getAttribute( 'contenteditable' ) == 'false' ) {\n\t\treturn false;\n\t}\n\n\tconst parent = element.findAncestor( element => element.hasAttribute( 'contenteditable' ) );\n\n\treturn !parent || parent.getAttribute( 'contenteditable' ) == 'true';\n}\n\n// Adds inline filler at a given position.\n//\n// The position can be given as an array of DOM nodes and an offset in that array,\n// or a DOM parent element and an offset in that element.\n//\n// @private\n// @param {Document} domDocument\n// @param {Element|Array.<Node>} domParentOrArray\n// @param {Number} offset\n// @returns {Text} The DOM text node that contains an inline filler.\nfunction addInlineFiller( domDocument, domParentOrArray, offset ) {\n\tconst childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;\n\tconst nodeAfterFiller = childNodes[ offset ];\n\n\tif ( isText( nodeAfterFiller ) ) {\n\t\tnodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;\n\n\t\treturn nodeAfterFiller;\n\t} else {\n\t\tconst fillerNode = domDocument.createTextNode( INLINE_FILLER );\n\n\t\tif ( Array.isArray( domParentOrArray ) ) {\n\t\t\tchildNodes.splice( offset, 0, fillerNode );\n\t\t} else {\n\t\t\tinsertAt( domParentOrArray, offset, fillerNode );\n\t\t}\n\n\t\treturn fillerNode;\n\t}\n}\n\n// Whether two DOM nodes should be considered as similar.\n// Nodes are considered similar if they have the same tag name.\n//\n// @private\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\nfunction areSimilar( node1, node2 ) {\n\treturn isNode( node1 ) && isNode( node2 ) &&\n\t\t!isText( node1 ) && !isText( node2 ) &&\n\t\t!isComment( node1 ) && !isComment( node2 ) &&\n\t\tnode1.tagName.toLowerCase() === node2.tagName.toLowerCase();\n}\n\n// Whether two dom nodes should be considered as the same.\n// Two nodes which are considered the same are:\n//\n//\t\t* Text nodes with the same text.\n//\t\t* Element nodes represented by the same object.\n//\t\t* Two block filler elements.\n//\n// @private\n// @param {String} blockFillerMode Block filler mode, see {@link module:engine/view/domconverter~DomConverter#blockFillerMode}.\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\nfunction sameNodes( domConverter, actualDomChild, expectedDomChild ) {\n\t// Elements.\n\tif ( actualDomChild === expectedDomChild ) {\n\t\treturn true;\n\t}\n\t// Texts.\n\telse if ( isText( actualDomChild ) && isText( expectedDomChild ) ) {\n\t\treturn actualDomChild.data === expectedDomChild.data;\n\t}\n\t// Block fillers.\n\telse if ( domConverter.isBlockFiller( actualDomChild ) &&\n\t\tdomConverter.isBlockFiller( expectedDomChild ) ) {\n\t\treturn true;\n\t}\n\n\t// Not matching types.\n\treturn false;\n}\n\n// The following is a Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n// When the native DOM selection is at the end of the block and preceded by <br /> e.g.\n//\n//\t\t<p>foo<br/>[]</p>\n//\n// which happens a lot when using the soft line break, the browser fails to (visually) move the\n// caret to the new line. A quick fix is as simple as force–refreshing the selection with the same range.\nfunction fixGeckoSelectionAfterBr( focus, domSelection ) {\n\tconst parent = focus.parent;\n\n\t// This fix works only when the focus point is at the very end of an element.\n\t// There is no point in running it in cases unrelated to the browser bug.\n\tif ( parent.nodeType != Node.ELEMENT_NODE || focus.offset != parent.childNodes.length - 1 ) {\n\t\treturn;\n\t}\n\n\tconst childAtOffset = parent.childNodes[ focus.offset ];\n\n\t// To stay on the safe side, the fix being as specific as possible, it targets only the\n\t// selection which is at the very end of the element and preceded by <br />.\n\tif ( childAtOffset && childAtOffset.tagName == 'BR' ) {\n\t\tdomSelection.addRange( domSelection.getRangeAt( 0 ) );\n\t}\n}\n\nfunction filterOutFakeSelectionContainer( domChildList, fakeSelectionContainer ) {\n\tconst childList = Array.from( domChildList );\n\n\tif ( childList.length == 0 || !fakeSelectionContainer ) {\n\t\treturn childList;\n\t}\n\n\tconst last = childList[ childList.length - 1 ];\n\n\tif ( last == fakeSelectionContainer ) {\n\t\tchildList.pop();\n\t}\n\n\treturn childList;\n}\n\n// Creates a fake selection container for a given document.\n//\n// @private\n// @param {Document} domDocument\n// @returns {HTMLElement}\nfunction createFakeSelectionContainer( domDocument ) {\n\tconst container = domDocument.createElement( 'div' );\n\n\tcontainer.className = 'ck-fake-selection-container';\n\n\tObject.assign( container.style, {\n\t\tposition: 'fixed',\n\t\ttop: 0,\n\t\tleft: '-9999px',\n\t\t// See https://github.com/ckeditor/ckeditor5/issues/752.\n\t\twidth: '42px'\n\t} );\n\n\t// Fill it with a text node so we can update it later.\n\tcontainer.textContent = '\\u00A0';\n\n\treturn container;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}