{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/mapper\n */\nimport ModelPosition from '../model/position';\nimport ModelRange from '../model/range';\nimport ViewPosition from '../view/position';\nimport ViewRange from '../view/range';\nimport ViewText from '../view/text';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Maps elements, positions and markers between the {@link module:engine/view/document~Document view} and\n * the {@link module:engine/model/model model}.\n *\n * The instance of the Mapper used for the editing pipeline is available in\n * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.\n *\n * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map the complex model to/from view relations, you may provide custom callbacks for the\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by the {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds its own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class Mapper {\n  /**\n   * Creates an instance of the mapper.\n   */\n  constructor() {\n    /**\n     * Model element to view element mapping.\n     *\n     * @private\n     * @member {WeakMap}\n     */\n    this._modelToViewMapping = new WeakMap();\n    /**\n     * View element to model element mapping.\n     *\n     * @private\n     * @member {WeakMap}\n     */\n\n    this._viewToModelMapping = new WeakMap();\n    /**\n     * A map containing callbacks between view element names and functions evaluating length of view elements\n     * in model.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._viewToModelLengthCallbacks = new Map();\n    /**\n     * Model marker name to view elements mapping.\n     *\n     * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n     * One marker (name) can be mapped to multiple elements.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._markerNameToElements = new Map();\n    /**\n     * View element to model marker names mapping.\n     *\n     * This is reverse to {@link ~Mapper#_markerNameToElements} map.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._elementToMarkerNames = new Map();\n    /**\n     * The map of removed view elements with their current root (used for deferred unbinding).\n     *\n     * @private\n     * @member {Map.<module:engine/view/element~Element,module:engine/view/documentfragment~DocumentFragment>}\n     */\n\n    this._deferredBindingRemovals = new Map();\n    /**\n     * Stores marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element\n     * has been removed, moved or renamed).\n     *\n     * @private\n     * @member {Set.<module:engine/model/markercollection~Marker>}\n     */\n\n    this._unboundMarkerNames = new Set(); // Default mapper algorithm for mapping model position to view position.\n\n    this.on('modelToViewPosition', (evt, data) => {\n      if (data.viewPosition) {\n        return;\n      }\n\n      const viewContainer = this._modelToViewMapping.get(data.modelPosition.parent);\n\n      if (!viewContainer) {\n        /**\n         * A model position could not be mapped to the view because the parent of the model position\n         * does not have a mapped view element (might have not been converted yet or it has no converter).\n         *\n         * Make sure that the model element is correctly converted to the view.\n         *\n         * @error mapping-model-position-view-parent-not-found\n         */\n        throw new CKEditorError('mapping-model-position-view-parent-not-found', this, {\n          modelPosition: data.modelPosition\n        });\n      }\n\n      data.viewPosition = this.findPositionIn(viewContainer, data.modelPosition.offset);\n    }, {\n      priority: 'low'\n    }); // Default mapper algorithm for mapping view position to model position.\n\n    this.on('viewToModelPosition', (evt, data) => {\n      if (data.modelPosition) {\n        return;\n      }\n\n      const viewBlock = this.findMappedViewAncestor(data.viewPosition);\n\n      const modelParent = this._viewToModelMapping.get(viewBlock);\n\n      const modelOffset = this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);\n\n      data.modelPosition = ModelPosition._createAt(modelParent, modelOffset);\n    }, {\n      priority: 'low'\n    });\n  }\n  /**\n   * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n   * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n   * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n   * The information that elements are bound is also used to translate positions.\n   *\n   * @param {module:engine/model/element~Element} modelElement Model element.\n   * @param {module:engine/view/element~Element} viewElement View element.\n   */\n\n\n  bindElements(modelElement, viewElement) {\n    this._modelToViewMapping.set(modelElement, viewElement);\n\n    this._viewToModelMapping.set(viewElement, modelElement);\n  }\n  /**\n   * Unbinds the given {@link module:engine/view/element~Element view element} from the map.\n   *\n   * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n   * will be removed only if model element is still bound to the passed `viewElement`.\n   *\n   * This behavior allows for re-binding model element to another view element without fear of losing the new binding\n   * when the previously bound view element is unbound.\n   *\n   * @param {module:engine/view/element~Element} viewElement View element to unbind.\n   * @param {Object} [options={}] The options object.\n   * @param {Boolean} [options.defer=false] Controls whether the binding should be removed immediately or deferred until a\n   * {@link #flushDeferredBindings `flushDeferredBindings()`} call.\n   */\n\n\n  unbindViewElement(viewElement) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const modelElement = this.toModelElement(viewElement);\n\n    if (this._elementToMarkerNames.has(viewElement)) {\n      for (const markerName of this._elementToMarkerNames.get(viewElement)) {\n        this._unboundMarkerNames.add(markerName);\n      }\n    }\n\n    if (options.defer) {\n      this._deferredBindingRemovals.set(viewElement, viewElement.root);\n    } else {\n      this._viewToModelMapping.delete(viewElement);\n\n      if (this._modelToViewMapping.get(modelElement) == viewElement) {\n        this._modelToViewMapping.delete(modelElement);\n      }\n    }\n  }\n  /**\n   * Unbinds the given {@link module:engine/model/element~Element model element} from the map.\n   *\n   * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding\n   * will be removed only if the view element is still bound to the passed `modelElement`.\n   *\n   * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n   * when the previously bound model element is unbound.\n   *\n   * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n   */\n\n\n  unbindModelElement(modelElement) {\n    const viewElement = this.toViewElement(modelElement);\n\n    this._modelToViewMapping.delete(modelElement);\n\n    if (this._viewToModelMapping.get(viewElement) == modelElement) {\n      this._viewToModelMapping.delete(viewElement);\n    }\n  }\n  /**\n   * Binds the given marker name with the given {@link module:engine/view/element~Element view element}. The element\n   * will be added to the current set of elements bound with the given marker name.\n   *\n   * @param {module:engine/view/element~Element} element Element to bind.\n   * @param {String} name Marker name.\n   */\n\n\n  bindElementToMarker(element, name) {\n    const elements = this._markerNameToElements.get(name) || new Set();\n    elements.add(element);\n    const names = this._elementToMarkerNames.get(element) || new Set();\n    names.add(name);\n\n    this._markerNameToElements.set(name, elements);\n\n    this._elementToMarkerNames.set(element, names);\n  }\n  /**\n   * Unbinds an element from given marker name.\n   *\n   * @param {module:engine/view/element~Element} element Element to unbind.\n   * @param {String} name Marker name.\n   */\n\n\n  unbindElementFromMarkerName(element, name) {\n    const nameToElements = this._markerNameToElements.get(name);\n\n    if (nameToElements) {\n      nameToElements.delete(element);\n\n      if (nameToElements.size == 0) {\n        this._markerNameToElements.delete(name);\n      }\n    }\n\n    const elementToNames = this._elementToMarkerNames.get(element);\n\n    if (elementToNames) {\n      elementToNames.delete(name);\n\n      if (elementToNames.size == 0) {\n        this._elementToMarkerNames.delete(element);\n      }\n    }\n  }\n  /**\n   * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element\n   * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.\n   *\n   * @returns {Array.<String>}\n   */\n\n\n  flushUnboundMarkerNames() {\n    const markerNames = Array.from(this._unboundMarkerNames);\n\n    this._unboundMarkerNames.clear();\n\n    return markerNames;\n  }\n  /**\n   * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.\n   *\n   * See: {@link #unbindViewElement `unbindViewElement()`}.\n   */\n\n\n  flushDeferredBindings() {\n    for (const [viewElement, root] of this._deferredBindingRemovals) {\n      // Unbind it only if it wasn't re-attached to some root or document fragment.\n      if (viewElement.root == root) {\n        this.unbindViewElement(viewElement);\n      }\n    }\n\n    this._deferredBindingRemovals = new Map();\n  }\n  /**\n   * Removes all model to view and view to model bindings.\n   */\n\n\n  clearBindings() {\n    this._modelToViewMapping = new WeakMap();\n    this._viewToModelMapping = new WeakMap();\n    this._markerNameToElements = new Map();\n    this._elementToMarkerNames = new Map();\n    this._unboundMarkerNames = new Set();\n    this._deferredBindingRemovals = new Map();\n  }\n  /**\n   * Gets the corresponding model element.\n   *\n   * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.\n   *\n   * @param {module:engine/view/element~Element} viewElement View element.\n   * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.\n   */\n\n\n  toModelElement(viewElement) {\n    return this._viewToModelMapping.get(viewElement);\n  }\n  /**\n   * Gets the corresponding view element.\n   *\n   * @param {module:engine/model/element~Element} modelElement Model element.\n   * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.\n   */\n\n\n  toViewElement(modelElement) {\n    return this._modelToViewMapping.get(modelElement);\n  }\n  /**\n   * Gets the corresponding model range.\n   *\n   * @param {module:engine/view/range~Range} viewRange View range.\n   * @returns {module:engine/model/range~Range} Corresponding model range.\n   */\n\n\n  toModelRange(viewRange) {\n    return new ModelRange(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));\n  }\n  /**\n   * Gets the corresponding view range.\n   *\n   * @param {module:engine/model/range~Range} modelRange Model range.\n   * @returns {module:engine/view/range~Range} Corresponding view range.\n   */\n\n\n  toViewRange(modelRange) {\n    return new ViewRange(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));\n  }\n  /**\n   * Gets the corresponding model position.\n   *\n   * @fires viewToModelPosition\n   * @param {module:engine/view/position~Position} viewPosition View position.\n   * @returns {module:engine/model/position~Position} Corresponding model position.\n   */\n\n\n  toModelPosition(viewPosition) {\n    const data = {\n      viewPosition,\n      mapper: this\n    };\n    this.fire('viewToModelPosition', data);\n    return data.modelPosition;\n  }\n  /**\n   * Gets the corresponding view position.\n   *\n   * @fires modelToViewPosition\n   * @param {module:engine/model/position~Position} modelPosition Model position.\n   * @param {Object} [options] Additional options for position mapping process.\n   * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n   * in model tree which no longer exists. For example, it could be an end of a removed model range.\n   * @returns {module:engine/view/position~Position} Corresponding view position.\n   */\n\n\n  toViewPosition(modelPosition) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      isPhantom: false\n    };\n    const data = {\n      modelPosition,\n      mapper: this,\n      isPhantom: options.isPhantom\n    };\n    this.fire('modelToViewPosition', data);\n    return data.viewPosition;\n  }\n  /**\n   * Gets all view elements bound to the given marker name.\n   *\n   * @param {String} name Marker name.\n   * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with the given marker name or `null`\n   * if no elements are bound to the given marker name.\n   */\n\n\n  markerNameToElements(name) {\n    const boundElements = this._markerNameToElements.get(name);\n\n    if (!boundElements) {\n      return null;\n    }\n\n    const elements = new Set();\n\n    for (const element of boundElements) {\n      if (element.is('attributeElement')) {\n        for (const clone of element.getElementsWithSameId()) {\n          elements.add(clone);\n        }\n      } else {\n        elements.add(element);\n      }\n    }\n\n    return elements;\n  }\n  /**\n   * Registers a callback that evaluates the length in the model of a view element with the given name.\n   *\n   * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n   * a number representing the length of the view element in the model.\n   *\n   *\t\t// List item in view may contain nested list, which have other list items. In model though,\n   *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n   *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n   *\n   *\t\tfunction getViewListItemLength( element ) {\n   *\t\t\tlet length = 1;\n   *\n   *\t\t\tfor ( let child of element.getChildren() ) {\n   *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n   *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n   *\t\t\t\t\t\tlength += getViewListItemLength( item );\n   *\t\t\t\t\t}\n   *\t\t\t\t}\n   *\t\t\t}\n   *\n   *\t\t\treturn length;\n   *\t\t}\n   *\n   *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n   *\n   * @param {String} viewElementName Name of view element for which callback is registered.\n   * @param {Function} lengthCallback Function return a length of view element instance in model.\n   */\n\n\n  registerViewToModelLength(viewElementName, lengthCallback) {\n    this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);\n  }\n  /**\n   * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to\n   * the model.\n   *\n   * @param {module:engine/view/position~Position} viewPosition Position for which a mapped ancestor should be found.\n   * @returns {module:engine/view/element~Element}\n   */\n\n\n  findMappedViewAncestor(viewPosition) {\n    let parent = viewPosition.parent;\n\n    while (!this._viewToModelMapping.has(parent)) {\n      parent = parent.parent;\n    }\n\n    return parent;\n  }\n  /**\n   * Calculates model offset based on the view position and the block element.\n   *\n   * Example:\n   *\n   *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n   *\n   * Is a sum of:\n   *\n   *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n   *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n   *\n   * @private\n   * @param {module:engine/view/element~Element} viewParent Position parent.\n   * @param {Number} viewOffset Position offset.\n   * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n   * @returns {Number} Offset in the model.\n   */\n\n\n  _toModelOffset(viewParent, viewOffset, viewBlock) {\n    if (viewBlock != viewParent) {\n      // See example.\n      const offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);\n\n      const offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);\n\n      return offsetToParentStart + offsetInParent;\n    } // viewBlock == viewParent, so we need to calculate the offset in the parent element.\n    // If the position is a text it is simple (\"ba|r\" -> 2).\n\n\n    if (viewParent.is('$text')) {\n      return viewOffset;\n    } // If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n\n\n    let modelOffset = 0;\n\n    for (let i = 0; i < viewOffset; i++) {\n      modelOffset += this.getModelLength(viewParent.getChild(i));\n    }\n\n    return modelOffset;\n  }\n  /**\n   * Gets the length of the view element in the model.\n   *\n   * The length is calculated as follows:\n   * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to\n   * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),\n   * * length of a {@link module:engine/view/text~Text text node} is equal to the length of its\n   * {@link module:engine/view/text~Text#data data},\n   * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n   * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n   * * length of a non-mapped {@link module:engine/view/element~Element element} is equal to the length of its children.\n   *\n   * Examples:\n   *\n   *\t\tfoo                          -> 3 // Text length is equal to its data length.\n   *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n   *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n   *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n   *\n   * @param {module:engine/view/element~Element} viewNode View node.\n   * @returns {Number} Length of the node in the tree model.\n   */\n\n\n  getModelLength(viewNode) {\n    if (this._viewToModelLengthCallbacks.get(viewNode.name)) {\n      const callback = this._viewToModelLengthCallbacks.get(viewNode.name);\n\n      return callback(viewNode);\n    } else if (this._viewToModelMapping.has(viewNode)) {\n      return 1;\n    } else if (viewNode.is('$text')) {\n      return viewNode.data.length;\n    } else if (viewNode.is('uiElement')) {\n      return 0;\n    } else {\n      let len = 0;\n\n      for (const child of viewNode.getChildren()) {\n        len += this.getModelLength(child);\n      }\n\n      return len;\n    }\n  }\n  /**\n   * Finds the position in the view node (or in its children) with the expected model offset.\n   *\n   * Example:\n   *\n   *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n   *\n   *\t\tfindPositionIn( p, 4 ):\n   *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n   *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n   *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n   *\n   *\t\tfindPositionIn( b, 4 - ( 5 - 3 ) ):\n   *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n   *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n   *\n   *\t\tfindPositionIn( bar, 2 - ( 3 - 3 ) ):\n   *\t\tWe are in the text node so we can simple find the offset.\n   *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n   *\n   * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n   * @param {Number} expectedOffset Expected offset.\n   * @returns {module:engine/view/position~Position} Found position.\n   */\n\n\n  findPositionIn(viewParent, expectedOffset) {\n    // Last scanned view node.\n    let viewNode; // Length of the last scanned view node.\n\n    let lastLength = 0;\n    let modelOffset = 0;\n    let viewOffset = 0; // In the text node it is simple: the offset in the model equals the offset in the text.\n\n    if (viewParent.is('$text')) {\n      return new ViewPosition(viewParent, expectedOffset);\n    } // In other cases we add lengths of child nodes to find the proper offset.\n    // If it is smaller we add the length.\n\n\n    while (modelOffset < expectedOffset) {\n      viewNode = viewParent.getChild(viewOffset);\n      lastLength = this.getModelLength(viewNode);\n      modelOffset += lastLength;\n      viewOffset++;\n    } // If it equals we found the position.\n\n\n    if (modelOffset == expectedOffset) {\n      return this._moveViewPositionToTextNode(new ViewPosition(viewParent, viewOffset));\n    } // If it is higher we need to enter last child.\n    else {\n      // ( modelOffset - lastLength ) is the offset to the child we enter,\n      // so we subtract it from the expected offset to fine the offset in the child.\n      return this.findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));\n    }\n  }\n  /**\n   * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,\n   * it moves it into the text node instead.\n   *\n   *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n   *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n   *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n   *\n   * @private\n   * @param {module:engine/view/position~Position} viewPosition Position potentially next to the text node.\n   * @returns {module:engine/view/position~Position} Position in the text node if possible.\n   */\n\n\n  _moveViewPositionToTextNode(viewPosition) {\n    // If the position is just after a text node, put it at the end of that text node.\n    // If the position is just before a text node, put it at the beginning of that text node.\n    const nodeBefore = viewPosition.nodeBefore;\n    const nodeAfter = viewPosition.nodeAfter;\n\n    if (nodeBefore instanceof ViewText) {\n      return new ViewPosition(nodeBefore, nodeBefore.data.length);\n    } else if (nodeAfter instanceof ViewText) {\n      return new ViewPosition(nodeAfter, 0);\n    } // Otherwise, just return the given position.\n\n\n    return viewPosition;\n  }\n  /**\n   * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position\n   * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to\n   * calculate the {@link module:engine/view/position~Position view position}. The calculated view position should be added as\n   * a `viewPosition` value in the `data` object that is passed as one of parameters to the event callback.\n   *\n   * \t\t// Assume that \"captionedImage\" model element is converted to <img> and following <span> elements in view,\n   * \t\t// and the model element is bound to <img> element. Force mapping model positions inside \"captionedImage\" to that\n   * \t\t// <span> element.\n   *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n   *\t\t\tconst positionParent = modelPosition.parent;\n   *\n   *\t\t\tif ( positionParent.name == 'captionedImage' ) {\n   *\t\t\t\tconst viewImg = data.mapper.toViewElement( positionParent );\n   *\t\t\t\tconst viewCaption = viewImg.nextSibling; // The <span> element.\n   *\n   *\t\t\t\tdata.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );\n   *\n   *\t\t\t\t// Stop the event if other callbacks should not modify calculated value.\n   *\t\t\t\tevt.stop();\n   *\t\t\t}\n   *\t\t} );\n   *\n   * **Note:** keep in mind that sometimes a \"phantom\" model position is being converted. A \"phantom\" model position is\n   * a position that points to a nonexistent place in model. Such a position might still be valid for conversion, though\n   * (it would point to a correct place in the view when converted). One example of such a situation is when a range is\n   * removed from the model, there may be a need to map the range's end (which is no longer a valid model position). To\n   * handle such situations, check the `data.isPhantom` flag:\n   *\n   * \t\t// Assume that there is a \"customElement\" model element and whenever the position is before it,\n   * \t\t// we want to move it to the inside of the view element bound to \"customElement\".\n   *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n   *\t\t\tif ( data.isPhantom ) {\n   *\t\t\t\treturn;\n   *\t\t\t}\n   *\n   *\t\t\t// Below line might crash for phantom position that does not exist in model.\n   *\t\t\tconst sibling = data.modelPosition.nodeBefore;\n   *\n   *\t\t\t// Check if this is the element we are interested in.\n   *\t\t\tif ( !sibling.is( 'element', 'customElement' ) ) {\n   *\t\t\t\treturn;\n   *\t\t\t}\n   *\n   *\t\t\tconst viewElement = data.mapper.toViewElement( sibling );\n   *\n   *\t\t\tdata.viewPosition = new ViewPosition( sibling, 0 );\n   *\n   *\t\t\tevt.stop();\n   *\t\t} );\n   *\n   * **Note:** the default mapping callback is provided with a `low` priority setting and does not cancel the event, so it is possible to\n   * attach a custom callback after a default callback and also use `data.viewPosition` calculated by the default callback\n   * (for example to fix it).\n   *\n   * **Note:** the default mapping callback will not fire if `data.viewPosition` is already set.\n   *\n   * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n   * mapping between the given model and view elements is unsolvable by using just elements mapping and default algorithm.\n   * Also, the condition that checks if a special case scenario happened should be as simple as possible.\n   *\n   * @event modelToViewPosition\n   * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n   * the `viewPosition` value to that object with calculated the {@link module:engine/view/position~Position view position}.\n   * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n   */\n\n  /**\n   * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.\n   *\n   * \t\t// See example in `modelToViewPosition` event description.\n   * \t\t// This custom mapping will map positions from <span> element next to <img> to the \"captionedImage\" element.\n   *\t\tmapper.on( 'viewToModelPosition', ( evt, data ) => {\n   *\t\t\tconst positionParent = viewPosition.parent;\n   *\n   *\t\t\tif ( positionParent.hasClass( 'image-caption' ) ) {\n   *\t\t\t\tconst viewImg = positionParent.previousSibling;\n   *\t\t\t\tconst modelImg = data.mapper.toModelElement( viewImg );\n   *\n   *\t\t\t\tdata.modelPosition = new ModelPosition( modelImg, viewPosition.offset );\n   *\t\t\t\tevt.stop();\n   *\t\t\t}\n   *\t\t} );\n   *\n   * **Note:** the default mapping callback is provided with a `low` priority setting and does not cancel the event, so it is possible to\n   * attach a custom callback after the default callback and also use `data.modelPosition` calculated by the default callback\n   * (for example to fix it).\n   *\n   * **Note:** the default mapping callback will not fire if `data.modelPosition` is already set.\n   *\n   * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n   * mapping between the given model and view elements is unsolvable by using just elements mapping and default algorithm.\n   * Also, the condition that checks if special case scenario happened should be as simple as possible.\n   *\n   * @event viewToModelPosition\n   * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n   * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.\n   * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n   */\n\n\n}\nmix(Mapper, EmitterMixin);","map":{"version":3,"names":["ModelPosition","ModelRange","ViewPosition","ViewRange","ViewText","EmitterMixin","CKEditorError","mix","Mapper","constructor","_modelToViewMapping","WeakMap","_viewToModelMapping","_viewToModelLengthCallbacks","Map","_markerNameToElements","_elementToMarkerNames","_deferredBindingRemovals","_unboundMarkerNames","Set","on","evt","data","viewPosition","viewContainer","get","modelPosition","parent","findPositionIn","offset","priority","viewBlock","findMappedViewAncestor","modelParent","modelOffset","_toModelOffset","_createAt","bindElements","modelElement","viewElement","set","unbindViewElement","options","toModelElement","has","markerName","add","defer","root","delete","unbindModelElement","toViewElement","bindElementToMarker","element","name","elements","names","unbindElementFromMarkerName","nameToElements","size","elementToNames","flushUnboundMarkerNames","markerNames","Array","from","clear","flushDeferredBindings","clearBindings","toModelRange","viewRange","toModelPosition","start","end","toViewRange","modelRange","toViewPosition","mapper","fire","isPhantom","markerNameToElements","boundElements","is","clone","getElementsWithSameId","registerViewToModelLength","viewElementName","lengthCallback","viewParent","viewOffset","offsetToParentStart","index","offsetInParent","i","getModelLength","getChild","viewNode","callback","length","len","child","getChildren","expectedOffset","lastLength","_moveViewPositionToTextNode","nodeBefore","nodeAfter"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/mapper\n */\n\nimport ModelPosition from '../model/position';\nimport ModelRange from '../model/range';\n\nimport ViewPosition from '../view/position';\nimport ViewRange from '../view/range';\nimport ViewText from '../view/text';\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Maps elements, positions and markers between the {@link module:engine/view/document~Document view} and\n * the {@link module:engine/model/model model}.\n *\n * The instance of the Mapper used for the editing pipeline is available in\n * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.\n *\n * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map the complex model to/from view relations, you may provide custom callbacks for the\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by the {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds its own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Mapper {\n\t/**\n\t * Creates an instance of the mapper.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Model element to view element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._modelToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * View element to model element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._viewToModelMapping = new WeakMap();\n\n\t\t/**\n\t\t * A map containing callbacks between view element names and functions evaluating length of view elements\n\t\t * in model.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._viewToModelLengthCallbacks = new Map();\n\n\t\t/**\n\t\t * Model marker name to view elements mapping.\n\t\t *\n\t\t * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n\t\t * One marker (name) can be mapped to multiple elements.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._markerNameToElements = new Map();\n\n\t\t/**\n\t\t * View element to model marker names mapping.\n\t\t *\n\t\t * This is reverse to {@link ~Mapper#_markerNameToElements} map.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._elementToMarkerNames = new Map();\n\n\t\t/**\n\t\t * The map of removed view elements with their current root (used for deferred unbinding).\n\t\t *\n\t\t * @private\n\t\t * @member {Map.<module:engine/view/element~Element,module:engine/view/documentfragment~DocumentFragment>}\n\t\t */\n\t\tthis._deferredBindingRemovals = new Map();\n\n\t\t/**\n\t\t * Stores marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element\n\t\t * has been removed, moved or renamed).\n\t\t *\n\t\t * @private\n\t\t * @member {Set.<module:engine/model/markercollection~Marker>}\n\t\t */\n\t\tthis._unboundMarkerNames = new Set();\n\n\t\t// Default mapper algorithm for mapping model position to view position.\n\t\tthis.on( 'modelToViewPosition', ( evt, data ) => {\n\t\t\tif ( data.viewPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst viewContainer = this._modelToViewMapping.get( data.modelPosition.parent );\n\n\t\t\tif ( !viewContainer ) {\n\t\t\t\t/**\n\t\t\t\t * A model position could not be mapped to the view because the parent of the model position\n\t\t\t\t * does not have a mapped view element (might have not been converted yet or it has no converter).\n\t\t\t\t *\n\t\t\t\t * Make sure that the model element is correctly converted to the view.\n\t\t\t\t *\n\t\t\t\t * @error mapping-model-position-view-parent-not-found\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'mapping-model-position-view-parent-not-found', this, { modelPosition: data.modelPosition } );\n\t\t\t}\n\n\t\t\tdata.viewPosition = this.findPositionIn( viewContainer, data.modelPosition.offset );\n\t\t}, { priority: 'low' } );\n\n\t\t// Default mapper algorithm for mapping view position to model position.\n\t\tthis.on( 'viewToModelPosition', ( evt, data ) => {\n\t\t\tif ( data.modelPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst viewBlock = this.findMappedViewAncestor( data.viewPosition );\n\t\t\tconst modelParent = this._viewToModelMapping.get( viewBlock );\n\t\t\tconst modelOffset = this._toModelOffset( data.viewPosition.parent, data.viewPosition.offset, viewBlock );\n\n\t\t\tdata.modelPosition = ModelPosition._createAt( modelParent, modelOffset );\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n\t * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n\t * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n\t * The information that elements are bound is also used to translate positions.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t */\n\tbindElements( modelElement, viewElement ) {\n\t\tthis._modelToViewMapping.set( modelElement, viewElement );\n\t\tthis._viewToModelMapping.set( viewElement, modelElement );\n\t}\n\n\t/**\n\t * Unbinds the given {@link module:engine/view/element~Element view element} from the map.\n\t *\n\t * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n\t * will be removed only if model element is still bound to the passed `viewElement`.\n\t *\n\t * This behavior allows for re-binding model element to another view element without fear of losing the new binding\n\t * when the previously bound view element is unbound.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element to unbind.\n\t * @param {Object} [options={}] The options object.\n\t * @param {Boolean} [options.defer=false] Controls whether the binding should be removed immediately or deferred until a\n\t * {@link #flushDeferredBindings `flushDeferredBindings()`} call.\n\t */\n\tunbindViewElement( viewElement, options = {} ) {\n\t\tconst modelElement = this.toModelElement( viewElement );\n\n\t\tif ( this._elementToMarkerNames.has( viewElement ) ) {\n\t\t\tfor ( const markerName of this._elementToMarkerNames.get( viewElement ) ) {\n\t\t\t\tthis._unboundMarkerNames.add( markerName );\n\t\t\t}\n\t\t}\n\n\t\tif ( options.defer ) {\n\t\t\tthis._deferredBindingRemovals.set( viewElement, viewElement.root );\n\t\t} else {\n\t\t\tthis._viewToModelMapping.delete( viewElement );\n\n\t\t\tif ( this._modelToViewMapping.get( modelElement ) == viewElement ) {\n\t\t\t\tthis._modelToViewMapping.delete( modelElement );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Unbinds the given {@link module:engine/model/element~Element model element} from the map.\n\t *\n\t * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding\n\t * will be removed only if the view element is still bound to the passed `modelElement`.\n\t *\n\t * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n\t * when the previously bound model element is unbound.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n\t */\n\tunbindModelElement( modelElement ) {\n\t\tconst viewElement = this.toViewElement( modelElement );\n\n\t\tthis._modelToViewMapping.delete( modelElement );\n\n\t\tif ( this._viewToModelMapping.get( viewElement ) == modelElement ) {\n\t\t\tthis._viewToModelMapping.delete( viewElement );\n\t\t}\n\t}\n\n\t/**\n\t * Binds the given marker name with the given {@link module:engine/view/element~Element view element}. The element\n\t * will be added to the current set of elements bound with the given marker name.\n\t *\n\t * @param {module:engine/view/element~Element} element Element to bind.\n\t * @param {String} name Marker name.\n\t */\n\tbindElementToMarker( element, name ) {\n\t\tconst elements = this._markerNameToElements.get( name ) || new Set();\n\t\telements.add( element );\n\n\t\tconst names = this._elementToMarkerNames.get( element ) || new Set();\n\t\tnames.add( name );\n\n\t\tthis._markerNameToElements.set( name, elements );\n\t\tthis._elementToMarkerNames.set( element, names );\n\t}\n\n\t/**\n\t * Unbinds an element from given marker name.\n\t *\n\t * @param {module:engine/view/element~Element} element Element to unbind.\n\t * @param {String} name Marker name.\n\t */\n\tunbindElementFromMarkerName( element, name ) {\n\t\tconst nameToElements = this._markerNameToElements.get( name );\n\n\t\tif ( nameToElements ) {\n\t\t\tnameToElements.delete( element );\n\n\t\t\tif ( nameToElements.size == 0 ) {\n\t\t\t\tthis._markerNameToElements.delete( name );\n\t\t\t}\n\t\t}\n\n\t\tconst elementToNames = this._elementToMarkerNames.get( element );\n\n\t\tif ( elementToNames ) {\n\t\t\telementToNames.delete( name );\n\n\t\t\tif ( elementToNames.size == 0 ) {\n\t\t\t\tthis._elementToMarkerNames.delete( element );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element\n\t * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.\n\t *\n\t * @returns {Array.<String>}\n\t */\n\tflushUnboundMarkerNames() {\n\t\tconst markerNames = Array.from( this._unboundMarkerNames );\n\n\t\tthis._unboundMarkerNames.clear();\n\n\t\treturn markerNames;\n\t}\n\n\t/**\n\t * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.\n\t *\n\t * See: {@link #unbindViewElement `unbindViewElement()`}.\n\t */\n\tflushDeferredBindings() {\n\t\tfor ( const [ viewElement, root ] of this._deferredBindingRemovals ) {\n\t\t\t// Unbind it only if it wasn't re-attached to some root or document fragment.\n\t\t\tif ( viewElement.root == root ) {\n\t\t\t\tthis.unbindViewElement( viewElement );\n\t\t\t}\n\t\t}\n\n\t\tthis._deferredBindingRemovals = new Map();\n\t}\n\n\t/**\n\t * Removes all model to view and view to model bindings.\n\t */\n\tclearBindings() {\n\t\tthis._modelToViewMapping = new WeakMap();\n\t\tthis._viewToModelMapping = new WeakMap();\n\t\tthis._markerNameToElements = new Map();\n\t\tthis._elementToMarkerNames = new Map();\n\t\tthis._unboundMarkerNames = new Set();\n\t\tthis._deferredBindingRemovals = new Map();\n\t}\n\n\t/**\n\t * Gets the corresponding model element.\n\t *\n\t * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.\n\t */\n\ttoModelElement( viewElement ) {\n\t\treturn this._viewToModelMapping.get( viewElement );\n\t}\n\n\t/**\n\t * Gets the corresponding view element.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.\n\t */\n\ttoViewElement( modelElement ) {\n\t\treturn this._modelToViewMapping.get( modelElement );\n\t}\n\n\t/**\n\t * Gets the corresponding model range.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {module:engine/model/range~Range} Corresponding model range.\n\t */\n\ttoModelRange( viewRange ) {\n\t\treturn new ModelRange( this.toModelPosition( viewRange.start ), this.toModelPosition( viewRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding view range.\n\t *\n\t * @param {module:engine/model/range~Range} modelRange Model range.\n\t * @returns {module:engine/view/range~Range} Corresponding view range.\n\t */\n\ttoViewRange( modelRange ) {\n\t\treturn new ViewRange( this.toViewPosition( modelRange.start ), this.toViewPosition( modelRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding model position.\n\t *\n\t * @fires viewToModelPosition\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {module:engine/model/position~Position} Corresponding model position.\n\t */\n\ttoModelPosition( viewPosition ) {\n\t\tconst data = {\n\t\t\tviewPosition,\n\t\t\tmapper: this\n\t\t};\n\n\t\tthis.fire( 'viewToModelPosition', data );\n\n\t\treturn data.modelPosition;\n\t}\n\n\t/**\n\t * Gets the corresponding view position.\n\t *\n\t * @fires modelToViewPosition\n\t * @param {module:engine/model/position~Position} modelPosition Model position.\n\t * @param {Object} [options] Additional options for position mapping process.\n\t * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n\t * in model tree which no longer exists. For example, it could be an end of a removed model range.\n\t * @returns {module:engine/view/position~Position} Corresponding view position.\n\t */\n\ttoViewPosition( modelPosition, options = { isPhantom: false } ) {\n\t\tconst data = {\n\t\t\tmodelPosition,\n\t\t\tmapper: this,\n\t\t\tisPhantom: options.isPhantom\n\t\t};\n\n\t\tthis.fire( 'modelToViewPosition', data );\n\n\t\treturn data.viewPosition;\n\t}\n\n\t/**\n\t * Gets all view elements bound to the given marker name.\n\t *\n\t * @param {String} name Marker name.\n\t * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with the given marker name or `null`\n\t * if no elements are bound to the given marker name.\n\t */\n\tmarkerNameToElements( name ) {\n\t\tconst boundElements = this._markerNameToElements.get( name );\n\n\t\tif ( !boundElements ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst elements = new Set();\n\n\t\tfor ( const element of boundElements ) {\n\t\t\tif ( element.is( 'attributeElement' ) ) {\n\t\t\t\tfor ( const clone of element.getElementsWithSameId() ) {\n\t\t\t\t\telements.add( clone );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telements.add( element );\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Registers a callback that evaluates the length in the model of a view element with the given name.\n\t *\n\t * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n\t * a number representing the length of the view element in the model.\n\t *\n\t *\t\t// List item in view may contain nested list, which have other list items. In model though,\n\t *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n\t *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n\t *\n\t *\t\tfunction getViewListItemLength( element ) {\n\t *\t\t\tlet length = 1;\n\t *\n\t *\t\t\tfor ( let child of element.getChildren() ) {\n\t *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n\t *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n\t *\t\t\t\t\t\tlength += getViewListItemLength( item );\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\n\t *\t\t\treturn length;\n\t *\t\t}\n\t *\n\t *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n\t *\n\t * @param {String} viewElementName Name of view element for which callback is registered.\n\t * @param {Function} lengthCallback Function return a length of view element instance in model.\n\t */\n\tregisterViewToModelLength( viewElementName, lengthCallback ) {\n\t\tthis._viewToModelLengthCallbacks.set( viewElementName, lengthCallback );\n\t}\n\n\t/**\n\t * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to\n\t * the model.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition Position for which a mapped ancestor should be found.\n\t * @returns {module:engine/view/element~Element}\n\t */\n\tfindMappedViewAncestor( viewPosition ) {\n\t\tlet parent = viewPosition.parent;\n\n\t\twhile ( !this._viewToModelMapping.has( parent ) ) {\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Calculates model offset based on the view position and the block element.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n\t *\n\t * Is a sum of:\n\t *\n\t *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewParent Position parent.\n\t * @param {Number} viewOffset Position offset.\n\t * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n\t * @returns {Number} Offset in the model.\n\t */\n\t_toModelOffset( viewParent, viewOffset, viewBlock ) {\n\t\tif ( viewBlock != viewParent ) {\n\t\t\t// See example.\n\t\t\tconst offsetToParentStart = this._toModelOffset( viewParent.parent, viewParent.index, viewBlock );\n\t\t\tconst offsetInParent = this._toModelOffset( viewParent, viewOffset, viewParent );\n\n\t\t\treturn offsetToParentStart + offsetInParent;\n\t\t}\n\n\t\t// viewBlock == viewParent, so we need to calculate the offset in the parent element.\n\n\t\t// If the position is a text it is simple (\"ba|r\" -> 2).\n\t\tif ( viewParent.is( '$text' ) ) {\n\t\t\treturn viewOffset;\n\t\t}\n\n\t\t// If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n\t\tlet modelOffset = 0;\n\n\t\tfor ( let i = 0; i < viewOffset; i++ ) {\n\t\t\tmodelOffset += this.getModelLength( viewParent.getChild( i ) );\n\t\t}\n\n\t\treturn modelOffset;\n\t}\n\n\t/**\n\t * Gets the length of the view element in the model.\n\t *\n\t * The length is calculated as follows:\n\t * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to\n\t * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),\n\t * * length of a {@link module:engine/view/text~Text text node} is equal to the length of its\n\t * {@link module:engine/view/text~Text#data data},\n\t * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n\t * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n\t * * length of a non-mapped {@link module:engine/view/element~Element element} is equal to the length of its children.\n\t *\n\t * Examples:\n\t *\n\t *\t\tfoo                          -> 3 // Text length is equal to its data length.\n\t *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n\t *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n\t *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n\t *\n\t * @param {module:engine/view/element~Element} viewNode View node.\n\t * @returns {Number} Length of the node in the tree model.\n\t */\n\tgetModelLength( viewNode ) {\n\t\tif ( this._viewToModelLengthCallbacks.get( viewNode.name ) ) {\n\t\t\tconst callback = this._viewToModelLengthCallbacks.get( viewNode.name );\n\n\t\t\treturn callback( viewNode );\n\t\t} else if ( this._viewToModelMapping.has( viewNode ) ) {\n\t\t\treturn 1;\n\t\t} else if ( viewNode.is( '$text' ) ) {\n\t\t\treturn viewNode.data.length;\n\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tlet len = 0;\n\n\t\t\tfor ( const child of viewNode.getChildren() ) {\n\t\t\t\tlen += this.getModelLength( child );\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t}\n\n\t/**\n\t * Finds the position in the view node (or in its children) with the expected model offset.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n\t *\n\t *\t\tfindPositionIn( p, 4 ):\n\t *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n\t *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n\t *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n\t *\n\t *\t\tfindPositionIn( b, 4 - ( 5 - 3 ) ):\n\t *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n\t *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n\t *\n\t *\t\tfindPositionIn( bar, 2 - ( 3 - 3 ) ):\n\t *\t\tWe are in the text node so we can simple find the offset.\n\t *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n\t *\n\t * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n\t * @param {Number} expectedOffset Expected offset.\n\t * @returns {module:engine/view/position~Position} Found position.\n\t */\n\tfindPositionIn( viewParent, expectedOffset ) {\n\t\t// Last scanned view node.\n\t\tlet viewNode;\n\t\t// Length of the last scanned view node.\n\t\tlet lastLength = 0;\n\n\t\tlet modelOffset = 0;\n\t\tlet viewOffset = 0;\n\n\t\t// In the text node it is simple: the offset in the model equals the offset in the text.\n\t\tif ( viewParent.is( '$text' ) ) {\n\t\t\treturn new ViewPosition( viewParent, expectedOffset );\n\t\t}\n\n\t\t// In other cases we add lengths of child nodes to find the proper offset.\n\n\t\t// If it is smaller we add the length.\n\t\twhile ( modelOffset < expectedOffset ) {\n\t\t\tviewNode = viewParent.getChild( viewOffset );\n\t\t\tlastLength = this.getModelLength( viewNode );\n\t\t\tmodelOffset += lastLength;\n\t\t\tviewOffset++;\n\t\t}\n\n\t\t// If it equals we found the position.\n\t\tif ( modelOffset == expectedOffset ) {\n\t\t\treturn this._moveViewPositionToTextNode( new ViewPosition( viewParent, viewOffset ) );\n\t\t}\n\t\t// If it is higher we need to enter last child.\n\t\telse {\n\t\t\t// ( modelOffset - lastLength ) is the offset to the child we enter,\n\t\t\t// so we subtract it from the expected offset to fine the offset in the child.\n\t\t\treturn this.findPositionIn( viewNode, expectedOffset - ( modelOffset - lastLength ) );\n\t\t}\n\t}\n\n\t/**\n\t * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,\n\t * it moves it into the text node instead.\n\t *\n\t *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n\t *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n\t *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} viewPosition Position potentially next to the text node.\n\t * @returns {module:engine/view/position~Position} Position in the text node if possible.\n\t */\n\t_moveViewPositionToTextNode( viewPosition ) {\n\t\t// If the position is just after a text node, put it at the end of that text node.\n\t\t// If the position is just before a text node, put it at the beginning of that text node.\n\t\tconst nodeBefore = viewPosition.nodeBefore;\n\t\tconst nodeAfter = viewPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeBefore, nodeBefore.data.length );\n\t\t} else if ( nodeAfter instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeAfter, 0 );\n\t\t}\n\n\t\t// Otherwise, just return the given position.\n\t\treturn viewPosition;\n\t}\n\n\t/**\n\t * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position\n\t * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to\n\t * calculate the {@link module:engine/view/position~Position view position}. The calculated view position should be added as\n\t * a `viewPosition` value in the `data` object that is passed as one of parameters to the event callback.\n\t *\n\t * \t\t// Assume that \"captionedImage\" model element is converted to <img> and following <span> elements in view,\n\t * \t\t// and the model element is bound to <img> element. Force mapping model positions inside \"captionedImage\" to that\n\t * \t\t// <span> element.\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = modelPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.name == 'captionedImage' ) {\n\t *\t\t\t\tconst viewImg = data.mapper.toViewElement( positionParent );\n\t *\t\t\t\tconst viewCaption = viewImg.nextSibling; // The <span> element.\n\t *\n\t *\t\t\t\tdata.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );\n\t *\n\t *\t\t\t\t// Stop the event if other callbacks should not modify calculated value.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** keep in mind that sometimes a \"phantom\" model position is being converted. A \"phantom\" model position is\n\t * a position that points to a nonexistent place in model. Such a position might still be valid for conversion, though\n\t * (it would point to a correct place in the view when converted). One example of such a situation is when a range is\n\t * removed from the model, there may be a need to map the range's end (which is no longer a valid model position). To\n\t * handle such situations, check the `data.isPhantom` flag:\n\t *\n\t * \t\t// Assume that there is a \"customElement\" model element and whenever the position is before it,\n\t * \t\t// we want to move it to the inside of the view element bound to \"customElement\".\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tif ( data.isPhantom ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\t// Below line might crash for phantom position that does not exist in model.\n\t *\t\t\tconst sibling = data.modelPosition.nodeBefore;\n\t *\n\t *\t\t\t// Check if this is the element we are interested in.\n\t *\t\t\tif ( !sibling.is( 'element', 'customElement' ) ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\tconst viewElement = data.mapper.toViewElement( sibling );\n\t *\n\t *\t\t\tdata.viewPosition = new ViewPosition( sibling, 0 );\n\t *\n\t *\t\t\tevt.stop();\n\t *\t\t} );\n\t *\n\t * **Note:** the default mapping callback is provided with a `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after a default callback and also use `data.viewPosition` calculated by the default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** the default mapping callback will not fire if `data.viewPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between the given model and view elements is unsolvable by using just elements mapping and default algorithm.\n\t * Also, the condition that checks if a special case scenario happened should be as simple as possible.\n\t *\n\t * @event modelToViewPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * the `viewPosition` value to that object with calculated the {@link module:engine/view/position~Position view position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n\n\t/**\n\t * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.\n\t *\n\t * \t\t// See example in `modelToViewPosition` event description.\n\t * \t\t// This custom mapping will map positions from <span> element next to <img> to the \"captionedImage\" element.\n\t *\t\tmapper.on( 'viewToModelPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = viewPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.hasClass( 'image-caption' ) ) {\n\t *\t\t\t\tconst viewImg = positionParent.previousSibling;\n\t *\t\t\t\tconst modelImg = data.mapper.toModelElement( viewImg );\n\t *\n\t *\t\t\t\tdata.modelPosition = new ModelPosition( modelImg, viewPosition.offset );\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** the default mapping callback is provided with a `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after the default callback and also use `data.modelPosition` calculated by the default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** the default mapping callback will not fire if `data.modelPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between the given model and view elements is unsolvable by using just elements mapping and default algorithm.\n\t * Also, the condition that checks if special case scenario happened should be as simple as possible.\n\t *\n\t * @event viewToModelPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n}\n\nmix( Mapper, EmitterMixin );\n"],"mappings":"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ClF,IAAX,CAAgB2E,MAA9C,CAAP;IACA,CAFD,MAEO,IAAKQ,SAAS,YAAYrG,QAA1B,EAAqC;MAC3C,OAAO,IAAIF,YAAJ,CAAkBuG,SAAlB,EAA6B,CAA7B,CAAP;IACA,CAV0C,CAY3C;;;IACA,OAAOlF,YAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAzrB4B;AA4rB5BhB,GAAG,CAAEC,MAAF,EAAUH,YAAV,CAAH"},"metadata":{},"sourceType":"module"}