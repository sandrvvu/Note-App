{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.\n *\n * @module engine/conversion/downcasthelpers\n */\nimport ModelRange from '../model/range';\nimport ModelSelection from '../model/selection';\nimport ModelElement from '../model/element';\nimport ModelPosition from '../model/position';\nimport ViewAttributeElement from '../view/attributeelement';\nimport DocumentSelection from '../model/documentselection';\nimport ConversionHelpers from './conversionhelpers';\nimport { cloneDeep } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n/**\n * Downcast conversion helper functions.\n *\n * Learn more about {@glink framework/guides/deep-dive/conversion/downcast downcast helpers}.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\n\nexport default class DowncastHelpers extends ConversionHelpers {\n  /**\n   * Model element to view element conversion helper.\n   *\n   * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'paragraph',\n   *\t\t\tview: 'p'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'paragraph',\n   *\t\t\tview: 'div',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'fancyParagraph',\n   *\t\t\tview: {\n   *\t\t\t\tname: 'p',\n   *\t\t\t\tclasses: 'fancy'\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'heading',\n   *\t\t\tview: ( modelElement, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or\n   * the `children` props on a model description. You will find a couple examples below.\n   *\n   * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`\n   * description. For example, this model:\n   *\n   *\t\t<box>\n   *\t\t\t<paragraph>Some text.</paragraph>\n   *\t\t</box>\n   *\n   * will be converted into this structure in the view:\n   *\n   *\t\t<div class=\"box\" data-type=\"single\">\n   *\t\t\t<p>Some text.</p>\n   *\t\t</div>\n   *\n   * But if more items were inserted in the model:\n   *\n   *\t\t<box>\n   *\t\t\t<paragraph>Some text.</paragraph>\n   *\t\t\t<paragraph>Other item.</paragraph>\n   *\t\t</box>\n   *\n   * it will be converted into this structure in the view (note the element `data-type` change):\n   *\n   *\t\t<div class=\"box\" data-type=\"multiple\">\n   *\t\t\t<p>Some text.</p>\n   *\t\t\t<p>Other item.</p>\n   *\t\t</div>\n   *\n   * Such a converter would look like this (note that the `paragraph` elements are converted separately):\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: {\n   *\t \t\t\tname: 'box',\n   *\t \t\t\tchildren: true\n   *\t\t\t},\n   *\t\t\tview: ( modelElement, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createContainerElement( 'div', {\n   *\t\t\t\t\tclass: 'box',\n   *\t\t\t\t\t'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`\n   * description. For example, this model:\n   *\n   *\t\t<heading level=\"2\">Some text.</heading>\n   *\n   * will be converted into this structure in the view:\n   *\n   *\t\t<h2>Some text.</h2>\n   *\n   * But if the `heading` element's `level` attribute has been updated to `3` for example, then\n   * it will be converted into this structure in the view:\n   *\n   *\t\t<h3>Some text.</h3>\n   *\n   * Such a converter would look as follows:\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: {\n   *\t \t\t\tname: 'heading',\n   *\t \t\t\tattributes: 'level'\n   *\t\t\t},\n   *\t\t\tview: ( modelElement, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * You can read more about the element-to-element conversion in the\n   * {@glink framework/guides/deep-dive/conversion/downcast downcast conversion} guide.\n   *\n   * @method #elementToElement\n   * @param {Object} config Conversion configuration.\n   * @param {String|Object} config.model The description or a name of the model element to convert.\n   * @param {String|Array.<String>} [config.model.attributes] The list of attribute names that should be consumed while creating\n   * the view element. Note that the view will be reconverted if any of the listed attributes changes.\n  \t * @param {Boolean} [config.model.children] Specifies whether the view element requires reconversion if the list\n   * of the model child nodes changed.\n   * @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~ElementCreatorFunction}\n   * config.view A view element definition or a function that takes the model element and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n   * as parameters and returns a view container element.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n  elementToElement(config) {\n    return this.add(downcastElementToElement(config));\n  }\n  /**\n   * The model element to view structure (several elements) conversion helper.\n   *\n   * This conversion results in creating a view structure with one or more slots defined for the child nodes.\n   * For example, a model `<table>` may become this structure in the view:\n   *\n   *\t\t<figure class=\"table\">\n   *\t\t\t<table>\n   *\t\t\t\t<tbody>${ slot for table rows }</tbody>\n   *\t\t\t</table>\n   *\t\t</figure>\n   *\n   * The children of the model's `<table>` element will be inserted into the `<tbody>` element.\n   * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.\n   *\n   * An example converter that converts the following model structure:\n   *\n   *\t\t<wrappedParagraph>Some text.</wrappedParagraph>\n   *\n   * into this structure in the view:\n   *\n   *\t\t<div class=\"wrapper\">\n   *\t\t\t<p>Some text.</p>\n   *\t\t</div>\n   *\n   * would look like this:\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n   *\t\t\tmodel: 'wrappedParagraph',\n   *\t\t\tview: ( modelElement, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\tconst wrapperViewElement = writer.createContainerElement( 'div', { class: 'wrapper' } );\n   *\t\t\t\tconst paragraphViewElement = writer.createContainerElement( 'p' );\n   *\n   *\t\t\t\twriter.insert( writer.createPositionAt( wrapperViewElement, 0 ), paragraphViewElement );\n   *\t\t\t\twriter.insert( writer.createPositionAt( paragraphViewElement, 0 ), writer.createSlot() );\n   *\n   *\t\t\t\treturn wrapperViewElement;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * The `slorFor()` function can also take a callback that allows filtering which children of the model element\n   * should be converted into this slot.\n   *\n   * Imagine a table feature where for this model structure:\n   *\n   *\t\t<table headingRows=\"1\">\n   *\t\t\t<tableRow> ... table cells 1 ... </tableRow>\n   *\t\t\t<tableRow> ... table cells 2 ... </tableRow>\n   *\t\t\t<tableRow> ... table cells 3 ... </tableRow>\n   *\t\t\t<caption>Caption text</caption>\n   *\t\t</table>\n   *\n   * we want to generate this view structure:\n   *\n   *\t\t<figure class=\"table\">\n   *\t\t\t<table>\n   *\t\t\t\t<thead>\n   *\t\t\t\t\t<tr> ... table cells 1 ... </tr>\n   *\t\t\t\t</thead>\n   *\t\t\t\t<tbody>\n   *\t\t\t\t\t<tr> ... table cells 2 ... </tr>\n   *\t\t\t\t\t<tr> ... table cells 3 ... </tr>\n   *\t\t\t\t</tbody>\n   *\t\t\t</table>\n   *\t\t\t<figcaption>Caption text</figcaption>\n   *\t\t</figure>\n   *\n   * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements\n   * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.\n   *\n   * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.\n   * In the example above, this will handle the table caption.\n   *\n   * Such a converter would look like this:\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n   *\t\t\tmodel: {\n   *\t\t\t\tname: 'table',\n   *\t\t\t\tattributes: [ 'headingRows' ]\n   *\t\t\t},\n   *\t\t\tview: ( modelElement, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\tconst figureElement = writer.createContainerElement( 'figure', { class: 'table' } );\n   *\t\t\t\tconst tableElement = writer.createContainerElement( 'table' );\n   *\n   *\t\t\t\twriter.insert( writer.createPositionAt( figureElement, 0 ), tableElement );\n   *\n   *\t\t\t\tconst headingRows = modelElement.getAttribute( 'headingRows' ) || 0;\n   *\n   *\t\t\t\tif ( headingRows > 0 ) {\n   *\t\t\t\t\tconst tableHead = writer.createContainerElement( 'thead' );\n   *\n   *\t\t\t\t\tconst headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );\n   *\n   *\t\t\t\t\twriter.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );\n   *\t\t\t\t\twriter.insert( writer.createPositionAt( tableHead, 0 ), headSlot );\n   *\t\t\t\t}\n   *\n   *\t\t\t\tif ( headingRows < tableUtils.getRows( table ) ) {\n   *\t\t\t\t\tconst tableBody = writer.createContainerElement( 'tbody' );\n   *\n   *\t\t\t\t\tconst bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );\n   *\n   *\t\t\t\t\twriter.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );\n   *\t\t\t\t\twriter.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );\n   *\t\t\t\t}\n   *\n   *\t\t\t\tconst restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );\n   *\n   *\t\t\t\twriter.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );\n   *\n   *\t\t\t\treturn figureElement;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Note: The children of a model element that's being converted must be allocated in the same order in the view\n   * in which they are placed in the model.\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #elementToStructure\n   * @param {Object} config Conversion configuration.\n  \t * @param {String|Object} config.model The description or a name of the model element to convert.\n   * @param {String} [config.model.name] The name of the model element to convert.\n  \t * @param {String|Array.<String>} [config.model.attributes] The list of attribute names that should be consumed while creating\n   * the view structure. Note that the view will be reconverted if any of the listed attributes will change.\n   * @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} config.view A function\n   * that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast\n   * conversion API} as parameters and returns a view container element with slots for model child nodes to be converted into.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n\n\n  elementToStructure(config) {\n    return this.add(downcastElementToStructure(config));\n  }\n  /**\n   * Model attribute to view element conversion helper.\n   *\n   * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with\n   * `\"Foo\"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'bold',\n   *\t\t\tview: 'strong'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'bold',\n   *\t\t\tview: 'b',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'invert',\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tclasses: [ 'font-light', 'bg-dark' ]\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'fontSize',\n   *\t\t\t\tvalues: [ 'big', 'small' ]\n   *\t\t\t},\n   *\t\t\tview: {\n   *\t\t\t\tbig: {\n   *\t\t\t\t\tname: 'span',\n   *\t\t\t\t\tstyles: {\n   *\t\t\t\t\t\t'font-size': '1.2em'\n   *\t\t\t\t\t}\n   *\t\t\t\t},\n   *\t\t\t\tsmall: {\n   *\t\t\t\t\tname: 'span',\n   *\t\t\t\t\tstyles: {\n   *\t\t\t\t\t\t'font-size': '0.8em'\n   *\t\t\t\t\t}\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'bold',\n   *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createAttributeElement( 'span', {\n   *\t\t\t\t\tstyle: 'font-weight:' + modelAttributeValue\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'color',\n   *\t\t\t\tname: '$text'\n   *\t\t\t},\n   *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createAttributeElement( 'span', {\n   *\t\t\t\t\tstyle: 'color:' + modelAttributeValue\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #attributeToElement\n   * @param {Object} config Conversion configuration.\n   * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n   * of `String`s with possible values if the model attribute is an enumerable.\n   * @param {module:engine/view/elementdefinition~ElementDefinition|Object|\n   * module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction} config.view A view element definition or a function\n   * that takes the model attribute value and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view\n   * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`\n   * to view element definitions or functions.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n\n\n  attributeToElement(config) {\n    return this.add(downcastAttributeToElement(config));\n  }\n  /**\n   * Model attribute to view attribute conversion helper.\n   *\n   * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,\n   * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'source',\n   *\t\t\tview: 'src'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'source',\n   *\t\t\tview: 'href',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: {\n   *\t\t\t\tname: 'imageInline',\n   *\t\t\t\tkey: 'source'\n   *\t\t\t},\n   *\t\t\tview: 'src'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: {\n   *\t\t\t\tname: 'styled',\n   *\t\t\t\tvalues: [ 'dark', 'light' ]\n   *\t\t\t},\n   *\t\t\tview: {\n   *\t\t\t\tdark: {\n   *\t\t\t\t\tkey: 'class',\n   *\t\t\t\t\tvalue: [ 'styled', 'styled-dark' ]\n   *\t\t\t\t},\n   *\t\t\t\tlight: {\n   *\t\t\t\t\tkey: 'class',\n   *\t\t\t\t\tvalue: [ 'styled', 'styled-light' ]\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'styled',\n   *\t\t\tview: modelAttributeValue => ( {\n   *\t\t\t\tkey: 'class',\n   *\t\t\t\tvalue: 'styled-' + modelAttributeValue\n   *\t\t\t} )\n   *\t\t} );\n   *\n   * **Note**: Downcasting to a style property requires providing `value` as an object:\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'lineHeight',\n   *\t\t\tview: modelAttributeValue => ( {\n   *\t\t\t\tkey: 'style',\n   *\t\t\t\tvalue: {\n   *\t\t\t\t\t'line-height': modelAttributeValue,\n   *\t\t\t\t\t'border-bottom': '1px dotted #ba2'\n   *\t\t\t\t}\n   *\t\t\t} )\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #attributeToAttribute\n   * @param {Object} config Conversion configuration.\n   * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n   * the attribute key, possible values and, optionally, an element name to convert from.\n   * @param {String|Object|module:engine/conversion/downcasthelpers~AttributeCreatorFunction} config.view A view attribute key,\n   * or a `{ key, value }` object or a function that takes the model attribute value and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n   * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an\n   * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n   * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n   * `{ key, value }` objects or a functions.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n\n\n  attributeToAttribute(config) {\n    return this.add(downcastAttributeToAttribute(config));\n  }\n  /**\n   * Model marker to view element conversion helper.\n   *\n   * **Note**: This method should be used mainly for editing the downcast and it is recommended\n   * to use the {@link #markerToData `#markerToData()`} helper instead.\n   *\n   * This helper may produce invalid HTML code (e.g. a span between table cells).\n   * It should only be used when you are sure that the produced HTML will be semantically correct.\n   *\n   * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker\n   * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`\n   * becomes `<p>F<span data-marker=\"search\"></span>oo b<span data-marker=\"search\"></span>ar</p>` in the view.\n   *\n   *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: 'marker-search'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: 'search-result',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tattributes: {\n   *\t\t\t\t\t'data-marker': 'search'\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: ( markerData, conversionApi ) => {\n   *\t\t\t\tconst { writer } = conversionApi;\n   *\n   *\t\t\t\treturn writer.createUIElement( 'span', {\n   *\t\t\t\t\t'data-marker': 'search',\n   *\t\t\t\t\t'data-start': markerData.isOpening\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function\n   * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n   * as a parameters and should return an instance of the\n   * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from\n   * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,\n   * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for\n   * the marker end boundary element.\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #markerToElement\n   * @param {Object} config Conversion configuration.\n   * @param {String} config.model The name of the model marker (or model marker group) to convert.\n   * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function that\n   * takes the model marker data and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n   * as a parameters and returns a view UI element.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n\n\n  markerToElement(config) {\n    return this.add(downcastMarkerToElement(config));\n  }\n  /**\n   * Model marker to highlight conversion helper.\n   *\n   * This conversion results in creating a highlight on view nodes. For this kind of conversion,\n   * the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.\n   *\n   * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes\n   * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes\n   * `<p>F<span class=\"comment\">oo b</span>ar</p>` in the view.\n   *\n   * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,\n   * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).\n   * For example, a model marker set like this:\n   * `[<imageInline src=\"foo.jpg\"></imageInline>]` becomes `<img src=\"foo.jpg\" class=\"comment\"></img>` in the view.\n   *\n   * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it\n   * to a container element, it is the container element instance itself that applies values from the highlight descriptor.\n   * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n   *\t\t\tmodel: 'comment',\n   *\t\t\tview: { classes: 'comment' },\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n   *\t\t\tmodel: 'comment',\n   *\t\t\tview: ( data, conversionApi ) => {\n   *\t\t\t\t// Assuming that the marker name is in a form of comment:commentType:commentId.\n   *\t\t\t\tconst [ , commentType, commentId ] = data.markerName.split( ':' );\n   *\n   *\t\t\t\treturn {\n   *\t\t\t\t\tclasses: [ 'comment', 'comment-' + commentType ],\n   *\t\t\t\t\tattributes: { 'data-comment-id': commentId }\n   *\t\t\t\t};\n   *\t\t\t}\n   *\t\t} );\n   *\n   * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function\n   * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n   * as the parameters and should return a\n   * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.\n   * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #markerToHighlight\n   * @param {Object} config Conversion configuration.\n   * @param {String} config.model The name of the model marker (or model marker group) to convert.\n   * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n   * that will be used for highlighting or a function that takes the model marker data and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters\n   * and returns a highlight descriptor.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n\n\n  markerToHighlight(config) {\n    return this.add(downcastMarkerToHighlight(config));\n  }\n  /**\n   * Model marker converter for data downcast.\n   *\n   * This conversion creates a representation for model marker boundaries in the view:\n   *\n   * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.\n   * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.\n   *\n   * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.\n   * The default configuration for this conversion is that the first part is the `group` part and the rest of\n   * the marker name becomes the `name` part.\n   *\n   * Tag and attribute names and values are generated from the marker name:\n   *\n   * * The templates for attributes are `data-[group]-start-before=\"[name]\"`, `data-[group]-start-after=\"[name]\"`,\n   * `data-[group]-end-before=\"[name]\"` and `data-[group]-end-after=\"[name]\"`.\n   * * The templates for view elements are `<[group]-start name=\"[name]\">` and `<[group]-end name=\"[name]\">`.\n   *\n   * Attributes mark whether the given marker's start or end boundary is before or after the given element.\n   * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.\n   * The other two are used when the former two cannot be used.\n   *\n   * The conversion configuration can take a function that will generate different group and name parts.\n   * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two\n   * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.\n   *\n   * Basic usage:\n   *\n   *\t\t// Using the default conversion.\n   *\t\t// In this case, all markers with names starting with 'comment:' will be converted.\n   *\t\t// The `group` parameter will be set to `comment`.\n   *\t\t// The `name` parameter will be the rest of the marker name (without the `:`).\n   *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n   *\t\t\tmodel: 'comment'\n   *\t\t} );\n   *\n   * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked\n   * by `[]`):\n   *\n   *\t\t// Model:\n   *\t\t<paragraph>Foo[bar</paragraph>\n   *\t\t<imageBlock src=\"abc.jpg\"></imageBlock>]\n   *\n   *\t\t// View:\n   *\t\t<p>Foo<comment-start name=\"commentId:uid\"></comment-start>bar</p>\n   *\t\t<figure data-comment-end-after=\"commentId:uid\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n   *\n   * In the example above, the comment starts before \"bar\" and ends after the image.\n   *\n   * If the `name` part is empty, the following view may be generated:\n   *\n   *\t\t<p>Foo <myMarker-start></myMarker-start>bar</p>\n   *\t\t<figure data-myMarker-end-after=\"\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n   *\n   * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.\n   *\n   * Examples where `data-group-start-after` and `data-group-end-before` are used:\n   *\n   *\t\t// Model:\n   *\t\t<blockQuote>[]<paragraph>Foo</paragraph></blockQuote>\n   *\n   *\t\t// View:\n   *\t\t<blockquote><p data-group-end-before=\"name\" data-group-start-before=\"name\">Foo</p></blockquote>\n   *\n   * Similarly, when a marker is collapsed after the last element:\n   *\n   *\t\t// Model:\n   *\t\t<blockQuote><paragraph>Foo</paragraph>[]</blockQuote>\n   *\n   *\t\t// View:\n   *\t\t<blockquote><p data-group-end-after=\"name\" data-group-start-after=\"name\">Foo</p></blockquote>\n   *\n   * When there are multiple markers from the same group stored in the same attribute of the same element, their\n   * name parts are put together in the attribute value, for example: `data-group-start-before=\"name1,name2,name3\"`.\n   *\n   * Other examples of usage:\n   *\n   *\t\t// Using a custom function which is the same as the default conversion:\n   *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n   *\t\t\tmodel: 'comment'\n   *\t\t\tview: markerName => ( {\n   *\t\t\t\tgroup: 'comment',\n   *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n   *\t\t\t} )\n   *\t\t} );\n   *\n   *\t\t// Using the converter priority:\n   *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n   *\t\t\tmodel: 'comment'\n   *\t\t\tview: markerName => ( {\n   *\t\t\t\tgroup: 'comment',\n   *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n   *\t\t\t} ),\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.\n   *\n   * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to\n   * add a converter to the conversion process.\n   *\n   * @method #markerToData\n   * @param {Object} config Conversion configuration.\n   * @param {String} config.model The name of the model marker (or the model marker group) to convert.\n   * @param {Function} [config.view] A function that takes the model marker name and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters\n   * and returns an object with the `group` and `name` properties.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n\n\n  markerToData(config) {\n    return this.add(downcastMarkerToData(config));\n  }\n\n}\n/**\n * Function factory that creates a default downcast converter for text insertion changes.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'insert:$text', insertText() );\n *\n * @returns {Function} Insert text event converter.\n */\n\nexport function insertText() {\n  return (evt, data, conversionApi) => {\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    const viewWriter = conversionApi.writer;\n    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    const viewText = viewWriter.createText(data.item.data);\n    viewWriter.insert(viewPosition, viewText);\n  };\n}\n/**\n * Function factory that creates a default downcast converter for triggering attributes and children conversion.\n *\n * @returns {Function} The converter.\n */\n\nexport function insertAttributesAndChildren() {\n  return (evt, data, conversionApi) => {\n    conversionApi.convertAttributes(data.item); // Start converting children of the current item.\n    // In case of reconversion children were already re-inserted or converted separately.\n\n    if (!data.reconversion && data.item.is('element') && !data.item.isEmpty) {\n      conversionApi.convertChildren(data.item);\n    }\n  };\n}\n/**\n * Function factory that creates a default downcast converter for node remove changes.\n *\n *\t\tmodelDispatcher.on( 'remove', remove() );\n *\n * @returns {Function} Remove event converter.\n */\n\nexport function remove() {\n  return (evt, data, conversionApi) => {\n    // Find the view range start position by mapping the model position at which the remove happened.\n    const viewStart = conversionApi.mapper.toViewPosition(data.position);\n    const modelEnd = data.position.getShiftedBy(data.length);\n    const viewEnd = conversionApi.mapper.toViewPosition(modelEnd, {\n      isPhantom: true\n    });\n    const viewRange = conversionApi.writer.createRange(viewStart, viewEnd); // Trim the range to remove in case some UI elements are on the view range boundaries.\n\n    const removed = conversionApi.writer.remove(viewRange.getTrimmed()); // After the range is removed, unbind all view elements from the model.\n    // Range inside view document fragment is used to unbind deeply.\n\n    for (const child of conversionApi.writer.createRangeIn(removed).getItems()) {\n      conversionApi.mapper.unbindViewElement(child, {\n        defer: true\n      });\n    }\n  };\n}\n/**\n * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information\n * provided by the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor} object. If the priority\n * is not provided in the descriptor, the default priority will be used.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\n\nexport function createViewElementFromHighlightDescriptor(writer, descriptor) {\n  const viewElement = writer.createAttributeElement('span', descriptor.attributes);\n\n  if (descriptor.classes) {\n    viewElement._addClass(descriptor.classes);\n  }\n\n  if (typeof descriptor.priority === 'number') {\n    viewElement._priority = descriptor.priority;\n  }\n\n  viewElement._id = descriptor.id;\n  return viewElement;\n}\n/**\n * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}\n * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object and maps model positions from the selection to view positions.\n *\n *\t\tmodelDispatcher.on( 'selection', convertRangeSelection() );\n *\n * @returns {Function} Selection converter.\n */\n\nexport function convertRangeSelection() {\n  return (evt, data, conversionApi) => {\n    const selection = data.selection;\n\n    if (selection.isCollapsed) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(selection, 'selection')) {\n      return;\n    }\n\n    const viewRanges = [];\n\n    for (const range of selection.getRanges()) {\n      const viewRange = conversionApi.mapper.toViewRange(range);\n      viewRanges.push(viewRange);\n    }\n\n    conversionApi.writer.setSelection(viewRanges, {\n      backward: selection.isBackward\n    });\n  };\n}\n/**\n * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to\n * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object, maps the model selection position to the view position and breaks\n * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.\n *\n *\t\tmodelDispatcher.on( 'selection', convertCollapsedSelection() );\n *\n * An example of the view state before and after converting the collapsed selection:\n *\n *\t\t   <p><strong>f^oo<strong>bar</p>\n *\t\t-> <p><strong>f</strong>^<strong>oo</strong>bar</p>\n *\n * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is\n * converted, broken attributes might be merged again, or the position where the selection is may be wrapped\n * with different, appropriate attribute elements.\n *\n * See also {@link module:engine/conversion/downcasthelpers~clearAttributes} which does a clean-up\n * by merging attributes.\n *\n * @returns {Function} Selection converter.\n */\n\nexport function convertCollapsedSelection() {\n  return (evt, data, conversionApi) => {\n    const selection = data.selection;\n\n    if (!selection.isCollapsed) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(selection, 'selection')) {\n      return;\n    }\n\n    const viewWriter = conversionApi.writer;\n    const modelPosition = selection.getFirstPosition();\n    const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);\n    const brokenPosition = viewWriter.breakAttributes(viewPosition);\n    viewWriter.setSelection(brokenPosition);\n  };\n}\n/**\n * Function factory that creates a converter which clears artifacts after the previous\n * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty\n * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end\n * positions of all ranges.\n *\n *\t\t   <p><strong>^</strong></p>\n *\t\t-> <p>^</p>\n *\n *\t\t   <p><strong>foo</strong>^<strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n *\t\t   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n * This listener should be assigned before any converter for the new selection:\n *\n *\t\tmodelDispatcher.on( 'selection', clearAttributes() );\n *\n * See {@link module:engine/conversion/downcasthelpers~convertCollapsedSelection}\n * which does the opposite by breaking attributes in the selection position.\n *\n * @returns {Function} Selection converter.\n */\n\nexport function clearAttributes() {\n  return (evt, data, conversionApi) => {\n    const viewWriter = conversionApi.writer;\n    const viewSelection = viewWriter.document.selection;\n\n    for (const range of viewSelection.getRanges()) {\n      // Not collapsed selection should not have artifacts.\n      if (range.isCollapsed) {\n        // Position might be in the node removed by the view writer.\n        if (range.end.parent.isAttached()) {\n          conversionApi.writer.mergeAttributes(range.start);\n        }\n      }\n    }\n\n    viewWriter.setSelection(null);\n  };\n}\n/**\n * Function factory that creates a converter which converts the set/change/remove attribute changes from the model to the view.\n * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the\n * selection will be put inside it.\n *\n * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to\n * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model\n * but are represented as an element in the view:\n *\n *\t\t[paragraph]              MODEL ====> VIEW        <p>\n *\t\t\t|- a {bold: true}                             |- <b>\n *\t\t\t|- b {bold: true}                             |   |- ab\n *\t\t\t|- c                                          |- c\n *\n * Passed `Function` will be provided with the attribute value and then all the parameters of the\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be the wrapping element.\n * When the provided `Function` does not return any element, no conversion will take place.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:bold', wrap( ( modelAttributeValue, { writer } ) => {\n *\t\t\treturn writer.createAttributeElement( 'strong' );\n *\t\t} );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element that will be used for wrapping.\n * @returns {Function} Set/change attribute converter.\n */\n\nexport function wrap(elementCreator) {\n  return (evt, data, conversionApi) => {\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n      return;\n    } // Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed\n    // or the attribute was removed.\n\n\n    const oldViewElement = elementCreator(data.attributeOldValue, conversionApi, data); // Create node to wrap with.\n\n    const newViewElement = elementCreator(data.attributeNewValue, conversionApi, data);\n\n    if (!oldViewElement && !newViewElement) {\n      return;\n    }\n\n    conversionApi.consumable.consume(data.item, evt.name);\n    const viewWriter = conversionApi.writer;\n    const viewSelection = viewWriter.document.selection;\n\n    if (data.item instanceof ModelSelection || data.item instanceof DocumentSelection) {\n      // Selection attribute conversion.\n      viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);\n    } else {\n      // Node attribute conversion.\n      let viewRange = conversionApi.mapper.toViewRange(data.range); // First, unwrap the range from current wrapper.\n\n      if (data.attributeOldValue !== null && oldViewElement) {\n        viewRange = viewWriter.unwrap(viewRange, oldViewElement);\n      }\n\n      if (data.attributeNewValue !== null && newViewElement) {\n        viewWriter.wrap(viewRange, newViewElement);\n      }\n    }\n  };\n}\n/**\n * Function factory that creates a converter which converts node insertion changes from the model to the view.\n * The function passed will be provided with all the parameters of the dispatcher's\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be inserted into the view.\n *\n * The converter automatically consumes the corresponding value from the consumables list and binds the model and view elements.\n *\n *\t\tdowncastDispatcher.on(\n *\t\t\t'insert:myElem',\n *\t\t\tinsertElement( ( modelItem, { writer } ) => {\n *\t\t\t\tconst text = writer.createText( 'myText' );\n *\t\t\t\tconst myElem = writer.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );\n *\n *\t\t\t\t// Do something fancy with `myElem` using `modelItem` or other parameters.\n *\n *\t\t\t\treturn myElem;\n *\t\t\t}\n *\t\t) );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element, which will be inserted.\n * @param {module:engine/conversion/downcasthelpers~ConsumerFunction} [consumer] Function defining element consumption process.\n * By default this function just consume passed item insertion.\n * @returns {Function} Insert element event converter.\n */\n\nexport function insertElement(elementCreator) {\n  let consumer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultConsumer;\n  return (evt, data, conversionApi) => {\n    if (!consumer(data.item, conversionApi.consumable, {\n      preflight: true\n    })) {\n      return;\n    }\n\n    const viewElement = elementCreator(data.item, conversionApi, data);\n\n    if (!viewElement) {\n      return;\n    } // Consume an element insertion and all present attributes that are specified as a reconversion triggers.\n\n\n    consumer(data.item, conversionApi.consumable);\n    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    conversionApi.mapper.bindElements(data.item, viewElement);\n    conversionApi.writer.insert(viewPosition, viewElement); // Convert attributes before converting children.\n\n    conversionApi.convertAttributes(data.item); // Convert children or reinsert previous view elements.\n\n    reinsertOrConvertNodes(viewElement, data.item.getChildren(), conversionApi, {\n      reconversion: data.reconversion\n    });\n  };\n}\n/**\n * Function factory that creates a converter which converts a single model node insertion to a view structure.\n *\n * It is expected that the passed element creator function returns an {@link module:engine/view/element~Element} with attached slots\n * created with `writer.createSlot()` to indicate where child nodes should be converted.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n *\n * @protected\n * @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} elementCreator Function returning a view structure,\n * which will be inserted.\n * @param {module:engine/conversion/downcasthelpers~ConsumerFunction} consumer A callback that is expected to consume all the consumables\n * that were used by the element creator.\n * @returns {Function} Insert element event converter.\n*/\n\nexport function insertStructure(elementCreator, consumer) {\n  return (evt, data, conversionApi) => {\n    if (!consumer(data.item, conversionApi.consumable, {\n      preflight: true\n    })) {\n      return;\n    }\n\n    const slotsMap = new Map();\n\n    conversionApi.writer._registerSlotFactory(createSlotFactory(data.item, slotsMap, conversionApi)); // View creation.\n\n\n    const viewElement = elementCreator(data.item, conversionApi, data);\n\n    conversionApi.writer._clearSlotFactory();\n\n    if (!viewElement) {\n      return;\n    } // Check if all children are covered by slots and there is no child that landed in multiple slots.\n\n\n    validateSlotsChildren(data.item, slotsMap, conversionApi); // Consume an element insertion and all present attributes that are specified as a reconversion triggers.\n\n    consumer(data.item, conversionApi.consumable);\n    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    conversionApi.mapper.bindElements(data.item, viewElement);\n    conversionApi.writer.insert(viewPosition, viewElement); // Convert attributes before converting children.\n\n    conversionApi.convertAttributes(data.item); // Fill view slots with previous view elements or create new ones.\n\n    fillSlots(viewElement, slotsMap, conversionApi, {\n      reconversion: data.reconversion\n    });\n  };\n}\n/**\n * Function factory that creates a converter which converts marker adding change to the\n * {@link module:engine/view/uielement~UIElement view UI element}.\n *\n * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.\n * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning\n * and at the end of the range.\n *\n * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n *\n * @protected\n * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element\n * that will be inserted.\n * @returns {Function} Insert element event converter.\n */\n\nexport function insertUIElement(elementCreator) {\n  return (evt, data, conversionApi) => {\n    // Create two view elements. One will be inserted at the beginning of marker, one at the end.\n    // If marker is collapsed, only \"opening\" element will be inserted.\n    data.isOpening = true;\n    const viewStartElement = elementCreator(data, conversionApi);\n    data.isOpening = false;\n    const viewEndElement = elementCreator(data, conversionApi);\n\n    if (!viewStartElement || !viewEndElement) {\n      return;\n    }\n\n    const markerRange = data.markerRange; // Marker that is collapsed has consumable build differently that non-collapsed one.\n    // For more information see `addMarker` event description.\n    // If marker's range is collapsed - check if it can be consumed.\n\n    if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {\n      return;\n    } // If marker's range is not collapsed - consume all items inside.\n\n\n    for (const value of markerRange) {\n      if (!conversionApi.consumable.consume(value.item, evt.name)) {\n        return;\n      }\n    }\n\n    const mapper = conversionApi.mapper;\n    const viewWriter = conversionApi.writer; // Add \"opening\" element.\n\n    viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);\n    conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName); // Add \"closing\" element only if range is not collapsed.\n\n    if (!markerRange.isCollapsed) {\n      viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);\n      conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);\n    }\n\n    evt.stop();\n  };\n} // Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}\n// based on marker remove change.\n//\n// This converter unbinds elements from the marker name.\n//\n// @returns {Function} Removed UI element converter.\n\nfunction removeUIElement() {\n  return (evt, data, conversionApi) => {\n    const elements = conversionApi.mapper.markerNameToElements(data.markerName);\n\n    if (!elements) {\n      return;\n    }\n\n    for (const element of elements) {\n      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n      conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);\n    }\n\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n  };\n} // Function factory that creates a default converter for model markers.\n//\n// See {@link DowncastHelpers#markerToData} for more information what type of view is generated.\n//\n// This converter binds created UI elements and affected view elements with the marker name\n// using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n//\n// @returns {Function} Add marker converter.\n\n\nfunction insertMarkerData(viewCreator) {\n  return (evt, data, conversionApi) => {\n    const viewMarkerData = viewCreator(data.markerName, conversionApi);\n\n    if (!viewMarkerData) {\n      return;\n    }\n\n    const markerRange = data.markerRange;\n\n    if (!conversionApi.consumable.consume(markerRange, evt.name)) {\n      return;\n    } // Adding closing data first to keep the proper order in the view.\n\n\n    handleMarkerBoundary(markerRange, false, conversionApi, data, viewMarkerData);\n    handleMarkerBoundary(markerRange, true, conversionApi, data, viewMarkerData);\n    evt.stop();\n  };\n} // Helper function for `insertMarkerData()` that marks a marker boundary at the beginning or end of given `range`.\n\n\nfunction handleMarkerBoundary(range, isStart, conversionApi, data, viewMarkerData) {\n  const modelPosition = isStart ? range.start : range.end;\n  const elementAfter = modelPosition.nodeAfter && modelPosition.nodeAfter.is('element') ? modelPosition.nodeAfter : null;\n  const elementBefore = modelPosition.nodeBefore && modelPosition.nodeBefore.is('element') ? modelPosition.nodeBefore : null;\n\n  if (elementAfter || elementBefore) {\n    let modelElement;\n    let isBefore; // If possible, we want to add `data-group-start-before` and `data-group-end-after` attributes.\n\n    if (isStart && elementAfter || !isStart && !elementBefore) {\n      // [<elementAfter>...</elementAfter> -> <elementAfter data-group-start-before=\"...\">...</elementAfter>\n      // <parent>]<elementAfter> -> <parent><elementAfter data-group-end-before=\"...\">\n      modelElement = elementAfter;\n      isBefore = true;\n    } else {\n      // <elementBefore>...</elementBefore>] -> <elementBefore data-group-end-after=\"...\">...</elementBefore>\n      // </elementBefore>[</parent> -> </elementBefore data-group-start-after=\"...\"></parent>\n      modelElement = elementBefore;\n      isBefore = false;\n    }\n\n    const viewElement = conversionApi.mapper.toViewElement(modelElement); // In rare circumstances, the model element may be not mapped to any view element and that would cause an error.\n    // One of those situations is a soft break inside code block.\n\n    if (viewElement) {\n      insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData);\n      return;\n    }\n  }\n\n  const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);\n  insertMarkerAsElement(viewPosition, isStart, conversionApi, data, viewMarkerData);\n} // Helper function for `insertMarkerData()` that marks a marker boundary in the view as an attribute on a view element.\n\n\nfunction insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData) {\n  const attributeName = `data-${viewMarkerData.group}-${isStart ? 'start' : 'end'}-${isBefore ? 'before' : 'after'}`;\n  const markerNames = viewElement.hasAttribute(attributeName) ? viewElement.getAttribute(attributeName).split(',') : []; // Adding marker name at the beginning to have the same order in the attribute as there is with marker elements.\n\n  markerNames.unshift(viewMarkerData.name);\n  conversionApi.writer.setAttribute(attributeName, markerNames.join(','), viewElement);\n  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n} // Helper function for `insertMarkerData()` that marks a marker boundary in the view as a separate view ui element.\n\n\nfunction insertMarkerAsElement(position, isStart, conversionApi, data, viewMarkerData) {\n  const viewElementName = `${viewMarkerData.group}-${isStart ? 'start' : 'end'}`;\n  const attrs = viewMarkerData.name ? {\n    'name': viewMarkerData.name\n  } : null;\n  const viewElement = conversionApi.writer.createUIElement(viewElementName, attrs);\n  conversionApi.writer.insert(position, viewElement);\n  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n} // Function factory that creates a converter for removing a model marker data added by the {@link #insertMarkerData} converter.\n//\n// @returns {Function} Remove marker converter.\n\n\nfunction removeMarkerData(viewCreator) {\n  return (evt, data, conversionApi) => {\n    const viewData = viewCreator(data.markerName, conversionApi);\n\n    if (!viewData) {\n      return;\n    }\n\n    const elements = conversionApi.mapper.markerNameToElements(data.markerName);\n\n    if (!elements) {\n      return;\n    }\n\n    for (const element of elements) {\n      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n\n      if (element.is('containerElement')) {\n        removeMarkerFromAttribute(`data-${viewData.group}-start-before`, element);\n        removeMarkerFromAttribute(`data-${viewData.group}-start-after`, element);\n        removeMarkerFromAttribute(`data-${viewData.group}-end-before`, element);\n        removeMarkerFromAttribute(`data-${viewData.group}-end-after`, element);\n      } else {\n        conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);\n      }\n    }\n\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n\n    function removeMarkerFromAttribute(attributeName, element) {\n      if (element.hasAttribute(attributeName)) {\n        const markerNames = new Set(element.getAttribute(attributeName).split(','));\n        markerNames.delete(viewData.name);\n\n        if (markerNames.size == 0) {\n          conversionApi.writer.removeAttribute(attributeName, element);\n        } else {\n          conversionApi.writer.setAttribute(attributeName, Array.from(markerNames).join(','), element);\n        }\n      }\n    }\n  };\n} // Function factory that creates a converter which converts the set/change/remove attribute changes from the model to the view.\n//\n// Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate\n// a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element\n// attributes on a one-to-one basis.\n//\n// *Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.\n//\n// The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n// {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n//\n//\t\tmodelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {\n//\t\t\t// Change attribute key from `customAttr` to `class` in the view.\n//\t\t\tconst key = 'class';\n//\t\t\tlet value = data.attributeNewValue;\n//\n//\t\t\t// Force attribute value to 'empty' if the model element is empty.\n//\t\t\tif ( data.item.childCount === 0 ) {\n//\t\t\t\tvalue = 'empty';\n//\t\t\t}\n//\n//\t\t\t// Return the key-value pair.\n//\t\t\treturn { key, value };\n//\t\t} ) );\n//\n// @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which\n// represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.\n// The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.\n// @returns {Function} Set/change attribute converter.\n\n\nfunction changeAttribute(attributeCreator) {\n  return (evt, data, conversionApi) => {\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n      return;\n    }\n\n    const oldAttribute = attributeCreator(data.attributeOldValue, conversionApi, data);\n    const newAttribute = attributeCreator(data.attributeNewValue, conversionApi, data);\n\n    if (!oldAttribute && !newAttribute) {\n      return;\n    }\n\n    conversionApi.consumable.consume(data.item, evt.name);\n    const viewElement = conversionApi.mapper.toViewElement(data.item);\n    const viewWriter = conversionApi.writer; // If model item cannot be mapped to a view element, it means item is not an `Element` instance but a `TextProxy` node.\n    // Only elements can have attributes in a view so do not proceed for anything else (#1587).\n\n    if (!viewElement) {\n      /**\n       * This error occurs when a {@link module:engine/model/textproxy~TextProxy text node's} attribute is to be downcasted\n       * by an {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `Attribute to Attribute converter`}.\n       * In most cases it is caused by converters misconfiguration when only \"generic\" converter is defined:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n       *\t\t\tmodel: 'attribute-name',\n       *\t\t\tview: 'attribute-name'\n       *\t\t} ) );\n       *\n       * and given attribute is used on text node, for example:\n       *\n       *\t\tmodel.change( writer => {\n       *\t\t\twriter.insertText( 'Foo', { 'attribute-name': 'bar' }, parent, 0 );\n       *\t\t} );\n       *\n       * In such cases, to convert the same attribute for both {@link module:engine/model/element~Element}\n       * and {@link module:engine/model/textproxy~TextProxy `Text`} nodes, text specific\n       * {@link module:engine/conversion/conversion~Conversion#attributeToElement `Attribute to Element converter`}\n       * with higher {@link module:utils/priorities~PriorityString priority} must also be defined:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n       *\t\t\tmodel: {\n       *\t\t\t\tkey: 'attribute-name',\n       *\t\t\t\tname: '$text'\n       *\t\t\t},\n       *\t\t\tview: ( value, { writer } ) => {\n       *\t\t\t\treturn writer.createAttributeElement( 'span', { 'attribute-name': value } );\n       *\t\t\t},\n       *\t\t\tconverterPriority: 'high'\n       *\t\t} ) );\n       *\n       * @error conversion-attribute-to-attribute-on-text\n       */\n      throw new CKEditorError('conversion-attribute-to-attribute-on-text', conversionApi.dispatcher, data);\n    } // First remove the old attribute if there was one.\n\n\n    if (data.attributeOldValue !== null && oldAttribute) {\n      if (oldAttribute.key == 'class') {\n        const classes = toArray(oldAttribute.value);\n\n        for (const className of classes) {\n          viewWriter.removeClass(className, viewElement);\n        }\n      } else if (oldAttribute.key == 'style') {\n        const keys = Object.keys(oldAttribute.value);\n\n        for (const key of keys) {\n          viewWriter.removeStyle(key, viewElement);\n        }\n      } else {\n        viewWriter.removeAttribute(oldAttribute.key, viewElement);\n      }\n    } // Then set the new attribute.\n\n\n    if (data.attributeNewValue !== null && newAttribute) {\n      if (newAttribute.key == 'class') {\n        const classes = toArray(newAttribute.value);\n\n        for (const className of classes) {\n          viewWriter.addClass(className, viewElement);\n        }\n      } else if (newAttribute.key == 'style') {\n        const keys = Object.keys(newAttribute.value);\n\n        for (const key of keys) {\n          viewWriter.setStyle(key, newAttribute.value[key], viewElement);\n        }\n      } else {\n        viewWriter.setAttribute(newAttribute.key, newAttribute.value, viewElement);\n      }\n    }\n  };\n} // Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with\n// {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.\n// See {link module:engine/conversion/downcasthelpers~createViewElementFromHighlightDescriptor}.\n//\n// It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be\n// created and the selection will be put inside it.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name\n// using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction highlightText(highlightDescriptor) {\n  return (evt, data, conversionApi) => {\n    if (!data.item) {\n      return;\n    }\n\n    if (!(data.item instanceof ModelSelection || data.item instanceof DocumentSelection) && !data.item.is('$textProxy')) {\n      return;\n    }\n\n    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    const viewWriter = conversionApi.writer;\n    const viewElement = createViewElementFromHighlightDescriptor(viewWriter, descriptor);\n    const viewSelection = viewWriter.document.selection;\n\n    if (data.item instanceof ModelSelection || data.item instanceof DocumentSelection) {\n      viewWriter.wrap(viewSelection.getFirstRange(), viewElement, viewSelection);\n    } else {\n      const viewRange = conversionApi.mapper.toViewRange(data.range);\n      const rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);\n\n      for (const element of rangeAfterWrap.getItems()) {\n        if (element.is('attributeElement') && element.isSimilar(viewElement)) {\n          conversionApi.mapper.bindElementToMarker(element, data.markerName); // One attribute element is enough, because all of them are bound together by the view writer.\n          // Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.\n\n          break;\n        }\n      }\n    }\n  };\n} // Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.\n//\n// The converter checks if an element has the `addHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.\n// In such case the converter will consume all element's children, assuming that they were handled by the element itself.\n//\n// When the `addHighlight` custom property is not present, the element is not converted in any special way.\n// This means that converters will proceed to convert the element's child nodes.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using\n// the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction highlightElement(highlightDescriptor) {\n  return (evt, data, conversionApi) => {\n    if (!data.item) {\n      return;\n    }\n\n    if (!(data.item instanceof ModelElement)) {\n      return;\n    }\n\n    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    }\n\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n      return;\n    }\n\n    const viewElement = conversionApi.mapper.toViewElement(data.item);\n\n    if (viewElement && viewElement.getCustomProperty('addHighlight')) {\n      // Consume element itself.\n      conversionApi.consumable.consume(data.item, evt.name); // Consume all children nodes.\n\n      for (const value of ModelRange._createIn(data.item)) {\n        conversionApi.consumable.consume(value.item, evt.name);\n      }\n\n      viewElement.getCustomProperty('addHighlight')(viewElement, descriptor, conversionApi.writer);\n      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n    }\n  };\n} // Function factory that creates a converter which converts the removing model marker to the view.\n//\n// Both text nodes and elements are handled by this converter but they are handled a bit differently.\n//\n// Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the\n// provided highlight descriptor. See {link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n//\n// For elements, the converter checks if an element has the `removeHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.\n// In such case, the children of that element will not be converted.\n//\n// When `removeHighlight` is not present, the element is not converted in any special way.\n// The converter will proceed to convert the element's child nodes instead.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter unbinds elements from the marker name.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction removeHighlight(highlightDescriptor) {\n  return (evt, data, conversionApi) => {\n    // This conversion makes sense only for non-collapsed range.\n    if (data.markerRange.isCollapsed) {\n      return;\n    }\n\n    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    } // View element that will be used to unwrap `AttributeElement`s.\n\n\n    const viewHighlightElement = createViewElementFromHighlightDescriptor(conversionApi.writer, descriptor); // Get all elements bound with given marker name.\n\n    const elements = conversionApi.mapper.markerNameToElements(data.markerName);\n\n    if (!elements) {\n      return;\n    }\n\n    for (const element of elements) {\n      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n\n      if (element.is('attributeElement')) {\n        conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element), viewHighlightElement);\n      } else {\n        // if element.is( 'containerElement' ).\n        element.getCustomProperty('removeHighlight')(element, descriptor.id, conversionApi.writer);\n      }\n    }\n\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n  };\n} // Model element to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToElement `.elementToElement()` downcast helper} for examples and config params description.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The description or a name of the model element to convert.\n// @param {String|Array.<String>} [config.model.attributes] List of attributes triggering element reconversion.\n// @param {Boolean} [config.model.children] Should reconvert element if the list of model child nodes changed.\n// @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~ElementCreatorFunction}\n// config.view\n// @returns {Function} Conversion helper.\n\n\nfunction downcastElementToElement(config) {\n  config = cloneDeep(config);\n  config.model = normalizeModelElementConfig(config.model);\n  config.view = normalizeToElementConfig(config.view, 'container'); // Trigger reconversion on children list change if element is a subject to any reconversion.\n  // This is required to be able to trigger Differ#refreshItem() on a direct child of the reconverted element.\n\n  if (config.model.attributes.length) {\n    config.model.children = true;\n  }\n\n  return dispatcher => {\n    dispatcher.on('insert:' + config.model.name, insertElement(config.view, createConsumer(config.model)), {\n      priority: config.converterPriority || 'normal'\n    });\n\n    if (config.model.children || config.model.attributes.length) {\n      dispatcher.on('reduceChanges', createChangeReducer(config.model), {\n        priority: 'low'\n      });\n    }\n  };\n} // Model element to view structure conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToStructure `.elementToStructure()` downcast helper} for examples and config params description.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model\n// @param {String} [config.model.name]\n// @param {Array.<String>} [config.model.attributes]\n// @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} config.view\n// @returns {Function} Conversion helper.\n\n\nfunction downcastElementToStructure(config) {\n  config = cloneDeep(config);\n  config.model = normalizeModelElementConfig(config.model);\n  config.view = normalizeToElementConfig(config.view, 'container'); // Trigger reconversion on children list change because it always needs to use slots to put children in proper places.\n  // This is required to be able to trigger Differ#refreshItem() on a direct child of the reconverted element.\n\n  config.model.children = true;\n  return dispatcher => {\n    if (dispatcher._conversionApi.schema.checkChild(config.model.name, '$text')) {\n      /**\n       * This error occurs when a {@link module:engine/model/element~Element model element} is downcasted\n       * via {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure} helper but the element was\n       * allowed to host `$text` by the {@link module:engine/model/schema~Schema model schema}.\n       *\n       * For instance, this may be the result of `myElement` allowing the content of\n       * {@glink framework/guides/deep-dive/schema#generic-items `$block`} in its schema definition:\n       *\n       *\t\t// Element definition in schema.\n       *\t\tschema.register( 'myElement', {\n       *\t\t\tallowContentOf: '$block',\n       *\n       *\t\t\t// ...\n       *\t\t} );\n       *\n       *\t\t// ...\n       *\n       *\t\t// Conversion of myElement with the use of elementToStructure().\n       *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n       *\t\t\tmodel: 'myElement',\n       *\t\t\tview: ( modelElement, { writer } ) => {\n       *\t\t\t\t// ...\n       *\t\t\t}\n       *\t\t} );\n       *\n       * In such case, {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`} helper\n       * can be used instead to get around this problem:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n       *\t\t\tmodel: 'myElement',\n       *\t\t\tview: ( modelElement, { writer } ) => {\n       *\t\t\t\t// ...\n       *\t\t\t}\n       *\t\t} );\n       *\n       * @error conversion-element-to-structure-disallowed-text\n       * @param {String} elementName The name of the element the structure is to be created for.\n       */\n      throw new CKEditorError('conversion-element-to-structure-disallowed-text', dispatcher, {\n        elementName: config.model.name\n      });\n    }\n\n    dispatcher.on('insert:' + config.model.name, insertStructure(config.view, createConsumer(config.model)), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('reduceChanges', createChangeReducer(config.model), {\n      priority: 'low'\n    });\n  };\n} // Model attribute to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToElement `.attributeToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n// of `String`s with possible values if the model attribute is an enumerable.\n// @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction|\n// Object} config.view A view element definition or a function that takes the model attribute value and\n// {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} as parameters and returns a view attribute element.\n// If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values` to view element\n// definitions or functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastAttributeToElement(config) {\n  config = cloneDeep(config);\n  const modelKey = config.model.key ? config.model.key : config.model;\n  let eventName = 'attribute:' + modelKey;\n\n  if (config.model.name) {\n    eventName += ':' + config.model.name;\n  }\n\n  if (config.model.values) {\n    for (const modelValue of config.model.values) {\n      config.view[modelValue] = normalizeToElementConfig(config.view[modelValue], 'attribute');\n    }\n  } else {\n    config.view = normalizeToElementConfig(config.view, 'attribute');\n  }\n\n  const elementCreator = getFromAttributeCreator(config);\n  return dispatcher => {\n    dispatcher.on(eventName, wrap(elementCreator), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model attribute to view attribute conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToAttribute `.attributeToAttribute()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n// the attribute key, possible values and, optionally, an element name to convert from.\n// @param {String|Object|module:engine/conversion/downcasthelpers~AttributeCreatorFunction} config.view A view attribute key,\n// or a `{ key, value }` object or a function that takes the model attribute value and returns a `{ key, value }` object.\n// If `key` is `'class'`, `value` can be a `String` or an array of `String`s. If `key` is `'style'`, `value` is an object with\n// key-value pairs. In other cases, `value` is a `String`.\n// If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n// `{ key, value }` objects or a functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastAttributeToAttribute(config) {\n  config = cloneDeep(config);\n  const modelKey = config.model.key ? config.model.key : config.model;\n  let eventName = 'attribute:' + modelKey;\n\n  if (config.model.name) {\n    eventName += ':' + config.model.name;\n  }\n\n  if (config.model.values) {\n    for (const modelValue of config.model.values) {\n      config.view[modelValue] = normalizeToAttributeConfig(config.view[modelValue]);\n    }\n  } else {\n    config.view = normalizeToAttributeConfig(config.view);\n  }\n\n  const elementCreator = getFromAttributeCreator(config);\n  return dispatcher => {\n    dispatcher.on(eventName, changeAttribute(elementCreator), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model marker to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model marker data as a parameter and returns a view UI element.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastMarkerToElement(config) {\n  config = cloneDeep(config);\n  config.view = normalizeToElementConfig(config.view, 'ui');\n  return dispatcher => {\n    dispatcher.on('addMarker:' + config.model, insertUIElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('removeMarker:' + config.model, removeUIElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model marker to view data conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToData `markerToData()` downcast helper} to learn more.\n//\n// @param {Object} config\n// @param {String} config.model\n// @param {Function} [config.view]\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal']\n// @returns {Function} Conversion helper.\n\n\nfunction downcastMarkerToData(config) {\n  config = cloneDeep(config);\n  const group = config.model; // Default conversion.\n\n  if (!config.view) {\n    config.view = markerName => ({\n      group,\n      name: markerName.substr(config.model.length + 1)\n    });\n  }\n\n  return dispatcher => {\n    dispatcher.on('addMarker:' + group, insertMarkerData(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('removeMarker:' + group, removeMarkerData(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model marker to highlight conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n// that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastMarkerToHighlight(config) {\n  return dispatcher => {\n    dispatcher.on('addMarker:' + config.model, highlightText(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('addMarker:' + config.model, highlightElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('removeMarker:' + config.model, removeHighlight(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Takes `config.model`, and converts it to an object with normalized structure.\n//\n// @param {String|Object} model Model configuration or element name.\n// @param {String} model.name\n// @param {Array.<String>} [model.attributes]\n// @param {Boolean} [model.children]\n// @returns {Object}\n\n\nfunction normalizeModelElementConfig(model) {\n  if (typeof model == 'string') {\n    model = {\n      name: model\n    };\n  } // List of attributes that should trigger reconversion.\n\n\n  if (!model.attributes) {\n    model.attributes = [];\n  } else if (!Array.isArray(model.attributes)) {\n    model.attributes = [model.attributes];\n  } // Whether a children insertion/deletion should trigger reconversion.\n\n\n  model.children = !!model.children;\n  return model;\n} // Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it\n// to a function (because lower level converters accept only element creator functions).\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.\n// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.\n// @returns {Function} Element creator function to use in lower level converters.\n\n\nfunction normalizeToElementConfig(view, viewElementType) {\n  if (typeof view == 'function') {\n    // If `view` is already a function, don't do anything.\n    return view;\n  }\n\n  return (modelData, conversionApi) => createViewElementFromDefinition(view, conversionApi, viewElementType);\n} // Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {'container'|'attribute'|'ui'} viewElementType\n// @returns {module:engine/view/element~Element}\n\n\nfunction createViewElementFromDefinition(viewElementDefinition, conversionApi, viewElementType) {\n  if (typeof viewElementDefinition == 'string') {\n    // If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.\n    viewElementDefinition = {\n      name: viewElementDefinition\n    };\n  }\n\n  let element;\n  const viewWriter = conversionApi.writer;\n  const attributes = Object.assign({}, viewElementDefinition.attributes);\n\n  if (viewElementType == 'container') {\n    element = viewWriter.createContainerElement(viewElementDefinition.name, attributes);\n  } else if (viewElementType == 'attribute') {\n    const options = {\n      priority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY\n    };\n    element = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);\n  } else {\n    // 'ui'.\n    element = viewWriter.createUIElement(viewElementDefinition.name, attributes);\n  }\n\n  if (viewElementDefinition.styles) {\n    const keys = Object.keys(viewElementDefinition.styles);\n\n    for (const key of keys) {\n      viewWriter.setStyle(key, viewElementDefinition.styles[key], element);\n    }\n  }\n\n  if (viewElementDefinition.classes) {\n    const classes = viewElementDefinition.classes;\n\n    if (typeof classes == 'string') {\n      viewWriter.addClass(classes, element);\n    } else {\n      for (const className of classes) {\n        viewWriter.addClass(className, element);\n      }\n    }\n  }\n\n  return element;\n}\n\nfunction getFromAttributeCreator(config) {\n  if (config.model.values) {\n    return (modelAttributeValue, conversionApi) => {\n      const view = config.view[modelAttributeValue];\n\n      if (view) {\n        return view(modelAttributeValue, conversionApi);\n      }\n\n      return null;\n    };\n  } else {\n    return config.view;\n  }\n} // Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters\n// for generating a view attribute.\n//\n// @param {Object} view View configuration.\n\n\nfunction normalizeToAttributeConfig(view) {\n  if (typeof view == 'string') {\n    return modelAttributeValue => ({\n      key: view,\n      value: modelAttributeValue\n    });\n  } else if (typeof view == 'object') {\n    // { key, value, ... }\n    if (view.value) {\n      return () => view;\n    } // { key, ... }\n    else {\n      return modelAttributeValue => ({\n        key: view.key,\n        value: modelAttributeValue\n      });\n    }\n  } else {\n    // function.\n    return view;\n  }\n} // Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.\n\n\nfunction prepareDescriptor(highlightDescriptor, data, conversionApi) {\n  // If passed descriptor is a creator function, call it. If not, just use passed value.\n  const descriptor = typeof highlightDescriptor == 'function' ? highlightDescriptor(data, conversionApi) : highlightDescriptor;\n\n  if (!descriptor) {\n    return null;\n  } // Apply default descriptor priority.\n\n\n  if (!descriptor.priority) {\n    descriptor.priority = 10;\n  } // Default descriptor id is marker name.\n\n\n  if (!descriptor.id) {\n    descriptor.id = data.markerName;\n  }\n\n  return descriptor;\n} // Creates a function that checks a single differ diff item whether it should trigger reconversion.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {Function}\n\n\nfunction createChangeReducerCallback(model) {\n  return (node, change) => {\n    if (!node.is('element', model.name)) {\n      return false;\n    }\n\n    if (change.type == 'attribute') {\n      if (model.attributes.includes(change.attributeKey)) {\n        return true;\n      }\n    } else {\n      /* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. */\n      if (model.children) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n} // Creates a `reduceChanges` event handler for reconversion.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {Function}\n\n\nfunction createChangeReducer(model) {\n  const shouldReplace = createChangeReducerCallback(model);\n  return (evt, data) => {\n    const reducedChanges = [];\n\n    if (!data.reconvertedElements) {\n      data.reconvertedElements = new Set();\n    }\n\n    for (const change of data.changes) {\n      // For attribute use node affected by the change.\n      // For insert or remove use parent element because we need to check if it's added/removed child.\n      const node = change.position ? change.position.parent : change.range.start.nodeAfter;\n\n      if (!node || !shouldReplace(node, change)) {\n        reducedChanges.push(change);\n        continue;\n      } // If it's already marked for reconversion, so skip this change, otherwise add the diff items.\n\n\n      if (!data.reconvertedElements.has(node)) {\n        data.reconvertedElements.add(node);\n\n        const position = ModelPosition._createBefore(node);\n\n        reducedChanges.push({\n          type: 'remove',\n          name: node.name,\n          position,\n          length: 1\n        }, {\n          type: 'reinsert',\n          name: node.name,\n          position,\n          length: 1\n        });\n      }\n    }\n\n    data.changes = reducedChanges;\n  };\n} // Creates a function that checks if an element and its watched attributes can be consumed and consumes them.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {module:engine/conversion/downcasthelpers~ConsumerFunction}\n\n\nfunction createConsumer(model) {\n  return function (node, consumable) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const events = ['insert']; // Collect all set attributes that are triggering conversion.\n\n    for (const attributeName of model.attributes) {\n      if (node.hasAttribute(attributeName)) {\n        events.push(`attribute:${attributeName}`);\n      }\n    }\n\n    if (!events.every(event => consumable.test(node, event))) {\n      return false;\n    }\n\n    if (!options.preflight) {\n      events.forEach(event => consumable.consume(node, event));\n    }\n\n    return true;\n  };\n} // Creates a function that create view slots.\n//\n// @param {module:engine/model/element~Element} element\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {Function} Exposed by writer as createSlot().\n\n\nfunction createSlotFactory(element, slotsMap, conversionApi) {\n  return function (writer) {\n    let modeOrFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'children';\n    const slot = writer.createContainerElement('$slot');\n    let children = null;\n\n    if (modeOrFilter === 'children') {\n      children = Array.from(element.getChildren());\n    } else if (typeof modeOrFilter == 'function') {\n      children = Array.from(element.getChildren()).filter(element => modeOrFilter(element));\n    } else {\n      /**\n       * Unknown slot mode was provided to `writer.createSlot()` in downcast converter.\n       *\n       * @error conversion-slot-mode-unknown\n       */\n      throw new CKEditorError('conversion-slot-mode-unknown', conversionApi.dispatcher, {\n        modeOrFilter\n      });\n    }\n\n    slotsMap.set(slot, children);\n    return slot;\n  };\n} // Checks if all children are covered by slots and there is no child that landed in multiple slots.\n//\n// @param {module:engine/model/element~Element}\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction validateSlotsChildren(element, slotsMap, conversionApi) {\n  const childrenInSlots = Array.from(slotsMap.values()).flat();\n  const uniqueChildrenInSlots = new Set(childrenInSlots);\n\n  if (uniqueChildrenInSlots.size != childrenInSlots.length) {\n    /**\n     * Filters provided to `writer.createSlot()` overlap (at least two filters accept the same child element).\n     *\n     * @error conversion-slot-filter-overlap\n     * @param {module:engine/model/element~Element} element The element of which children would not be properly\n     * allocated to multiple slots.\n     */\n    throw new CKEditorError('conversion-slot-filter-overlap', conversionApi.dispatcher, {\n      element\n    });\n  }\n\n  if (uniqueChildrenInSlots.size != element.childCount) {\n    /**\n     * Filters provided to `writer.createSlot()` are incomplete and exclude at least one children element (one of\n     * the children elements would not be assigned to any of the slots).\n     *\n     * @error conversion-slot-filter-incomplete\n     * @param {module:engine/model/element~Element} element The element of which children would not be properly\n     * allocated to multiple slots.\n     */\n    throw new CKEditorError('conversion-slot-filter-incomplete', conversionApi.dispatcher, {\n      element\n    });\n  }\n} // Fill slots with appropriate view elements.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\n\n\nfunction fillSlots(viewElement, slotsMap, conversionApi, options) {\n  // Set temporary position mapping to redirect child view elements into a proper slots.\n  conversionApi.mapper.on('modelToViewPosition', toViewPositionMapping, {\n    priority: 'highest'\n  });\n  let currentSlot = null;\n  let currentSlotNodes = null; // Fill slots with nested view nodes.\n\n  for ([currentSlot, currentSlotNodes] of slotsMap) {\n    reinsertOrConvertNodes(viewElement, currentSlotNodes, conversionApi, options);\n    conversionApi.writer.move(conversionApi.writer.createRangeIn(currentSlot), conversionApi.writer.createPositionBefore(currentSlot));\n    conversionApi.writer.remove(currentSlot);\n  }\n\n  conversionApi.mapper.off('modelToViewPosition', toViewPositionMapping);\n\n  function toViewPositionMapping(evt, data) {\n    const element = data.modelPosition.nodeAfter; // Find the proper offset within the slot.\n\n    const index = currentSlotNodes.indexOf(element);\n\n    if (index < 0) {\n      return;\n    }\n\n    data.viewPosition = data.mapper.findPositionIn(currentSlot, index);\n  }\n} // Inserts view representation of `nodes` into the `viewElement` either by bringing back just removed view nodes\n// or by triggering conversion for them.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {Iterable.<module:engine/model/element~Element>} modelNodes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\n\n\nfunction reinsertOrConvertNodes(viewElement, modelNodes, conversionApi, options) {\n  // Fill with nested view nodes.\n  for (const modelChildNode of modelNodes) {\n    // Try reinserting the view node for the specified model node...\n    if (!reinsertNode(viewElement.root, modelChildNode, conversionApi, options)) {\n      // ...or else convert the model element to the view.\n      conversionApi.convertItem(modelChildNode);\n    }\n  }\n} // Checks if the view for the given model element could be reused and reinserts it to the view.\n//\n// @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewRoot\n// @param {module:engine/model/element~Element} modelElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\n// @returns {Boolean} `false` if view element can't be reused.\n\n\nfunction reinsertNode(viewRoot, modelElement, conversionApi, options) {\n  const {\n    writer,\n    mapper\n  } = conversionApi; // Don't reinsert if this is not a reconversion...\n\n  if (!options.reconversion) {\n    return false;\n  }\n\n  const viewChildNode = mapper.toViewElement(modelElement); // ...or there is no view to reinsert or it was already inserted to the view structure...\n\n  if (!viewChildNode || viewChildNode.root == viewRoot) {\n    return false;\n  } // ...or it was strictly marked as not to be reused.\n\n\n  if (!conversionApi.canReuseView(viewChildNode)) {\n    return false;\n  } // Otherwise reinsert the view node.\n\n\n  writer.move(writer.createRangeOn(viewChildNode), mapper.toViewPosition(ModelPosition._createBefore(modelElement)));\n  return true;\n} // The default consumer for insert events.\n// @param {module:engine/model/item~Item} item Model item.\n// @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The model consumable.\n// @param {Object} [options]\n// @param {Boolean} [options.preflight=false] Whether should consume or just check if can be consumed.\n// @returns {Boolean}\n\n\nfunction defaultConsumer(item, consumable) {\n  let {\n    preflight\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (preflight) {\n    return consumable.test(item, 'insert');\n  } else {\n    return consumable.consume(item, 'insert');\n  }\n}\n/**\n * An object describing how the marker highlight should be represented in the view.\n *\n * Each text node contained in a highlighted range will be wrapped in a `<span>`\n * {@link module:engine/view/attributeelement~AttributeElement view attribute element} with CSS class(es), attributes and a priority\n * described by this object.\n *\n * Additionally, each {@link module:engine/view/containerelement~ContainerElement container element} can handle displaying the highlight\n * separately by providing the `addHighlight` and `removeHighlight` custom properties. In this case:\n *\n *  * The `HighlightDescriptor` object is passed to the `addHighlight` function upon conversion and should be used to apply the highlight to\n *  the element.\n *  * The descriptor `id` is passed to the `removeHighlight` function upon conversion and should be used to remove the highlight with the\n *  given ID from the element.\n *\n * @typedef {Object} module:engine/conversion/downcasthelpers~HighlightDescriptor\n *\n * @property {String|Array.<String>} classes A CSS class or an array of classes to set. If the descriptor is used to\n * create an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these classes will be set\n * on that attribute element. If the descriptor is applied to an element, usually these classes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n *\n * @property {String} [id] Descriptor identifier. If not provided, it defaults to the converted marker's name.\n *\n * @property {Number} [priority] Descriptor priority. If not provided, it defaults to `10`. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element}, it will be that element's\n * {@link module:engine/view/attributeelement~AttributeElement#priority priority}. If the descriptor is applied to an element,\n * the priority will be used to determine which descriptor is more important.\n *\n * @property {Object} [attributes] Attributes to set. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these attributes will be set on that\n * attribute element. If the descriptor is applied to an element, usually these attributes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n */\n\n/**\n * A filtering function used to choose model child nodes to be downcasted into the specific view\n * {@link module:engine/view/downcastwriter~DowncastWriter#createSlot \"slot\"} while executing the\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`} converter.\n *\n * @callback module:engine/conversion/downcasthelpers~SlotFilter\n *\n * @param {module:engine/model/node~Node} node A model node.\n * @returns {Boolean} Whether the provided model node should be downcasted into this slot.\n *\n * @see module:engine/view/downcastwriter~DowncastWriter#createSlot\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n * @see module:engine/conversion/downcasthelpers~insertStructure\n */\n\n/**\n * A view element creator function that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi\n * downcast conversion API} as parameters and returns a view container element.\n *\n * @callback module:engine/conversion/downcasthelpers~ElementCreatorFunction\n * @param {module:engine/model/element~Element} element The model element to be converted to the view structure.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} event).\n * @param {module:engine/model/item~Item} data.item Inserted item.\n * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n * @returns {module:engine/view/element~Element} The view element.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement\n * @see module:engine/conversion/downcasthelpers~insertElement\n */\n\n/**\n * A function that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast\n * conversion API} as parameters and returns a view container element with slots for model child nodes to be converted into.\n *\n * @callback module:engine/conversion/downcasthelpers~StructureCreatorFunction\n * @param {module:engine/model/element~Element} element The model element to be converted to the view structure.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} event).\n * @param {module:engine/model/item~Item} data.item Inserted item.\n * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n * @returns {module:engine/view/element~Element} The view structure with slots for model child nodes.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n * @see module:engine/conversion/downcasthelpers~insertStructure\n */\n\n/**\n * A view element creator function that takes the model attribute value and\n * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view\n * attribute element.\n *\n * @callback module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction\n * @param {*} attributeValue The model attribute value to be converted to the view attribute element.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} event).\n * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n * or converted selection.\n * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n * @param {String} data.attributeKey Attribute key.\n * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n * @param {*} data.attributeNewValue New attribute value.\n * @returns {module:engine/view/attributeelement~AttributeElement} The view attribute element.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement\n * @see module:engine/conversion/downcasthelpers~wrap\n */\n\n/**\n * A function that takes the model attribute value and\n * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n * as parameters.\n *\n * @callback module:engine/conversion/downcasthelpers~AttributeCreatorFunction\n * @param {*} attributeValue The model attribute value to be converted to the view attribute element.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} event).\n * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n * or converted selection.\n * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n * @param {String} data.attributeKey Attribute key.\n * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n * @param {*} data.attributeNewValue New attribute value.\n * @returns {Object|null} A `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n * array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute\n */\n\n/**\n * A function that is expected to consume all the consumables that were used by the element creator.\n *\n * @callback module:engine/conversion/downcasthelpers~ConsumerFunction\n * @param {module:engine/model/element~Element} element The model element to be converted to the view structure.\n * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The `ModelConsumable` same as in\n * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#consumable `DowncastConversionApi.consumable`}.\n * @param {Object} [options]\n * @param {Boolean} [options.preflight=false] Whether should consume or just check if can be consumed.\n * @returns {Boolean} `true` if all consumable values were available and were consumed, `false` otherwise.\n *\n * @see module:engine/conversion/downcasthelpers~insertStructure\n */","map":{"version":3,"names":["ModelRange","ModelSelection","ModelElement","ModelPosition","ViewAttributeElement","DocumentSelection","ConversionHelpers","cloneDeep","CKEditorError","toArray","DowncastHelpers","elementToElement","config","add","downcastElementToElement","elementToStructure","downcastElementToStructure","attributeToElement","downcastAttributeToElement","attributeToAttribute","downcastAttributeToAttribute","markerToElement","downcastMarkerToElement","markerToHighlight","downcastMarkerToHighlight","markerToData","downcastMarkerToData","insertText","evt","data","conversionApi","consumable","consume","item","name","viewWriter","writer","viewPosition","mapper","toViewPosition","range","start","viewText","createText","insert","insertAttributesAndChildren","convertAttributes","reconversion","is","isEmpty","convertChildren","remove","viewStart","position","modelEnd","getShiftedBy","length","viewEnd","isPhantom","viewRange","createRange","removed","getTrimmed","child","createRangeIn","getItems","unbindViewElement","defer","createViewElementFromHighlightDescriptor","descriptor","viewElement","createAttributeElement","attributes","classes","_addClass","priority","_priority","_id","id","convertRangeSelection","selection","isCollapsed","viewRanges","getRanges","toViewRange","push","setSelection","backward","isBackward","convertCollapsedSelection","modelPosition","getFirstPosition","brokenPosition","breakAttributes","clearAttributes","viewSelection","document","end","parent","isAttached","mergeAttributes","wrap","elementCreator","test","oldViewElement","attributeOldValue","newViewElement","attributeNewValue","getFirstRange","unwrap","insertElement","consumer","defaultConsumer","preflight","bindElements","reinsertOrConvertNodes","getChildren","insertStructure","slotsMap","Map","_registerSlotFactory","createSlotFactory","_clearSlotFactory","validateSlotsChildren","fillSlots","insertUIElement","isOpening","viewStartElement","viewEndElement","markerRange","value","bindElementToMarker","markerName","stop","removeUIElement","elements","markerNameToElements","element","unbindElementFromMarkerName","clear","createRangeOn","clearClonedElementsGroup","insertMarkerData","viewCreator","viewMarkerData","handleMarkerBoundary","isStart","elementAfter","nodeAfter","elementBefore","nodeBefore","modelElement","isBefore","toViewElement","insertMarkerAsAttribute","insertMarkerAsElement","attributeName","group","markerNames","hasAttribute","getAttribute","split","unshift","setAttribute","join","viewElementName","attrs","createUIElement","removeMarkerData","viewData","removeMarkerFromAttribute","Set","delete","size","removeAttribute","Array","from","changeAttribute","attributeCreator","oldAttribute","newAttribute","dispatcher","key","className","removeClass","keys","Object","removeStyle","addClass","setStyle","highlightText","highlightDescriptor","prepareDescriptor","rangeAfterWrap","isSimilar","highlightElement","getCustomProperty","_createIn","removeHighlight","viewHighlightElement","model","normalizeModelElementConfig","view","normalizeToElementConfig","children","on","createConsumer","converterPriority","createChangeReducer","_conversionApi","schema","checkChild","elementName","modelKey","eventName","values","modelValue","getFromAttributeCreator","normalizeToAttributeConfig","substr","isArray","viewElementType","modelData","createViewElementFromDefinition","viewElementDefinition","assign","createContainerElement","options","DEFAULT_PRIORITY","styles","modelAttributeValue","createChangeReducerCallback","node","change","type","includes","attributeKey","shouldReplace","reducedChanges","reconvertedElements","changes","has","_createBefore","events","every","event","forEach","modeOrFilter","slot","filter","set","childrenInSlots","flat","uniqueChildrenInSlots","childCount","toViewPositionMapping","currentSlot","currentSlotNodes","move","createPositionBefore","off","index","indexOf","findPositionIn","modelNodes","modelChildNode","reinsertNode","root","convertItem","viewRoot","viewChildNode","canReuseView"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.\n *\n * @module engine/conversion/downcasthelpers\n */\n\nimport ModelRange from '../model/range';\nimport ModelSelection from '../model/selection';\nimport ModelElement from '../model/element';\nimport ModelPosition from '../model/position';\n\nimport ViewAttributeElement from '../view/attributeelement';\nimport DocumentSelection from '../model/documentselection';\nimport ConversionHelpers from './conversionhelpers';\n\nimport { cloneDeep } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n\n/**\n * Downcast conversion helper functions.\n *\n * Learn more about {@glink framework/guides/deep-dive/conversion/downcast downcast helpers}.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\nexport default class DowncastHelpers extends ConversionHelpers {\n\t/**\n\t * Model element to view element conversion helper.\n\t *\n\t * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'p'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'div',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'fancyParagraph',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'heading',\n\t *\t\t\tview: ( modelElement, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\treturn writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or\n\t * the `children` props on a model description. You will find a couple examples below.\n\t *\n\t * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`\n\t * description. For example, this model:\n\t *\n\t *\t\t<box>\n\t *\t\t\t<paragraph>Some text.</paragraph>\n\t *\t\t</box>\n\t *\n\t * will be converted into this structure in the view:\n\t *\n\t *\t\t<div class=\"box\" data-type=\"single\">\n\t *\t\t\t<p>Some text.</p>\n\t *\t\t</div>\n\t *\n\t * But if more items were inserted in the model:\n\t *\n\t *\t\t<box>\n\t *\t\t\t<paragraph>Some text.</paragraph>\n\t *\t\t\t<paragraph>Other item.</paragraph>\n\t *\t\t</box>\n\t *\n\t * it will be converted into this structure in the view (note the element `data-type` change):\n\t *\n\t *\t\t<div class=\"box\" data-type=\"multiple\">\n\t *\t\t\t<p>Some text.</p>\n\t *\t\t\t<p>Other item.</p>\n\t *\t\t</div>\n\t *\n\t * Such a converter would look like this (note that the `paragraph` elements are converted separately):\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: {\n\t *\t \t\t\tname: 'box',\n\t *\t \t\t\tchildren: true\n\t *\t\t\t},\n\t *\t\t\tview: ( modelElement, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\treturn writer.createContainerElement( 'div', {\n\t *\t\t\t\t\tclass: 'box',\n\t *\t\t\t\t\t'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`\n\t * description. For example, this model:\n\t *\n\t *\t\t<heading level=\"2\">Some text.</heading>\n\t *\n\t * will be converted into this structure in the view:\n\t *\n\t *\t\t<h2>Some text.</h2>\n\t *\n\t * But if the `heading` element's `level` attribute has been updated to `3` for example, then\n\t * it will be converted into this structure in the view:\n\t *\n\t *\t\t<h3>Some text.</h3>\n\t *\n\t * Such a converter would look as follows:\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: {\n\t *\t \t\t\tname: 'heading',\n\t *\t \t\t\tattributes: 'level'\n\t *\t\t\t},\n\t *\t\t\tview: ( modelElement, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\treturn writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * You can read more about the element-to-element conversion in the\n\t * {@glink framework/guides/deep-dive/conversion/downcast downcast conversion} guide.\n\t *\n\t * @method #elementToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.model The description or a name of the model element to convert.\n\t * @param {String|Array.<String>} [config.model.attributes] The list of attribute names that should be consumed while creating\n\t * the view element. Note that the view will be reconverted if any of the listed attributes changes.\n \t * @param {Boolean} [config.model.children] Specifies whether the view element requires reconversion if the list\n\t * of the model child nodes changed.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~ElementCreatorFunction}\n\t * config.view A view element definition or a function that takes the model element and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n\t * as parameters and returns a view container element.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\telementToElement( config ) {\n\t\treturn this.add( downcastElementToElement( config ) );\n\t}\n\n\t/**\n\t * The model element to view structure (several elements) conversion helper.\n\t *\n\t * This conversion results in creating a view structure with one or more slots defined for the child nodes.\n\t * For example, a model `<table>` may become this structure in the view:\n\t *\n\t *\t\t<figure class=\"table\">\n\t *\t\t\t<table>\n\t *\t\t\t\t<tbody>${ slot for table rows }</tbody>\n\t *\t\t\t</table>\n\t *\t\t</figure>\n\t *\n\t * The children of the model's `<table>` element will be inserted into the `<tbody>` element.\n\t * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.\n\t *\n\t * An example converter that converts the following model structure:\n\t *\n\t *\t\t<wrappedParagraph>Some text.</wrappedParagraph>\n\t *\n\t * into this structure in the view:\n\t *\n\t *\t\t<div class=\"wrapper\">\n\t *\t\t\t<p>Some text.</p>\n\t *\t\t</div>\n\t *\n\t * would look like this:\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n\t *\t\t\tmodel: 'wrappedParagraph',\n\t *\t\t\tview: ( modelElement, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\tconst wrapperViewElement = writer.createContainerElement( 'div', { class: 'wrapper' } );\n\t *\t\t\t\tconst paragraphViewElement = writer.createContainerElement( 'p' );\n\t *\n\t *\t\t\t\twriter.insert( writer.createPositionAt( wrapperViewElement, 0 ), paragraphViewElement );\n\t *\t\t\t\twriter.insert( writer.createPositionAt( paragraphViewElement, 0 ), writer.createSlot() );\n\t *\n\t *\t\t\t\treturn wrapperViewElement;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * The `slorFor()` function can also take a callback that allows filtering which children of the model element\n\t * should be converted into this slot.\n\t *\n\t * Imagine a table feature where for this model structure:\n\t *\n\t *\t\t<table headingRows=\"1\">\n\t *\t\t\t<tableRow> ... table cells 1 ... </tableRow>\n\t *\t\t\t<tableRow> ... table cells 2 ... </tableRow>\n\t *\t\t\t<tableRow> ... table cells 3 ... </tableRow>\n\t *\t\t\t<caption>Caption text</caption>\n\t *\t\t</table>\n\t *\n\t * we want to generate this view structure:\n\t *\n\t *\t\t<figure class=\"table\">\n\t *\t\t\t<table>\n\t *\t\t\t\t<thead>\n\t *\t\t\t\t\t<tr> ... table cells 1 ... </tr>\n\t *\t\t\t\t</thead>\n\t *\t\t\t\t<tbody>\n\t *\t\t\t\t\t<tr> ... table cells 2 ... </tr>\n\t *\t\t\t\t\t<tr> ... table cells 3 ... </tr>\n\t *\t\t\t\t</tbody>\n\t *\t\t\t</table>\n\t *\t\t\t<figcaption>Caption text</figcaption>\n\t *\t\t</figure>\n\t *\n\t * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements\n\t * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.\n\t *\n\t * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.\n\t * In the example above, this will handle the table caption.\n\t *\n\t * Such a converter would look like this:\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'table',\n\t *\t\t\t\tattributes: [ 'headingRows' ]\n\t *\t\t\t},\n\t *\t\t\tview: ( modelElement, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\tconst figureElement = writer.createContainerElement( 'figure', { class: 'table' } );\n\t *\t\t\t\tconst tableElement = writer.createContainerElement( 'table' );\n\t *\n\t *\t\t\t\twriter.insert( writer.createPositionAt( figureElement, 0 ), tableElement );\n\t *\n\t *\t\t\t\tconst headingRows = modelElement.getAttribute( 'headingRows' ) || 0;\n\t *\n\t *\t\t\t\tif ( headingRows > 0 ) {\n\t *\t\t\t\t\tconst tableHead = writer.createContainerElement( 'thead' );\n\t *\n\t *\t\t\t\t\tconst headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );\n\t *\n\t *\t\t\t\t\twriter.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );\n\t *\t\t\t\t\twriter.insert( writer.createPositionAt( tableHead, 0 ), headSlot );\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\tif ( headingRows < tableUtils.getRows( table ) ) {\n\t *\t\t\t\t\tconst tableBody = writer.createContainerElement( 'tbody' );\n\t *\n\t *\t\t\t\t\tconst bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );\n\t *\n\t *\t\t\t\t\twriter.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );\n\t *\t\t\t\t\twriter.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\tconst restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );\n\t *\n\t *\t\t\t\twriter.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );\n\t *\n\t *\t\t\t\treturn figureElement;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Note: The children of a model element that's being converted must be allocated in the same order in the view\n\t * in which they are placed in the model.\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToStructure\n\t * @param {Object} config Conversion configuration.\n \t * @param {String|Object} config.model The description or a name of the model element to convert.\n\t * @param {String} [config.model.name] The name of the model element to convert.\n \t * @param {String|Array.<String>} [config.model.attributes] The list of attribute names that should be consumed while creating\n\t * the view structure. Note that the view will be reconverted if any of the listed attributes will change.\n\t * @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} config.view A function\n\t * that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast\n\t * conversion API} as parameters and returns a view container element with slots for model child nodes to be converted into.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\telementToStructure( config ) {\n\t\treturn this.add( downcastElementToStructure( config ) );\n\t}\n\n\t/**\n\t * Model attribute to view element conversion helper.\n\t *\n\t * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with\n\t * `\"Foo\"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'strong'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'b',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'invert',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: [ 'font-light', 'bg-dark' ]\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalues: [ 'big', 'small' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tbig: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '1.2em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '0.8em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\treturn writer.createAttributeElement( 'span', {\n\t *\t\t\t\t\tstyle: 'font-weight:' + modelAttributeValue\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'color',\n\t *\t\t\t\tname: '$text'\n\t *\t\t\t},\n\t *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\treturn writer.createAttributeElement( 'span', {\n\t *\t\t\t\t\tstyle: 'color:' + modelAttributeValue\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n\t * of `String`s with possible values if the model attribute is an enumerable.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|Object|\n\t * module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction} config.view A view element definition or a function\n\t * that takes the model attribute value and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view\n\t * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`\n\t * to view element definitions or functions.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tattributeToElement( config ) {\n\t\treturn this.add( downcastAttributeToElement( config ) );\n\t}\n\n\t/**\n\t * Model attribute to view attribute conversion helper.\n\t *\n\t * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,\n\t * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tview: 'src'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tview: 'href',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'imageInline',\n\t *\t\t\t\tkey: 'source'\n\t *\t\t\t},\n\t *\t\t\tview: 'src'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'styled',\n\t *\t\t\t\tvalues: [ 'dark', 'light' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tdark: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'styled', 'styled-dark' ]\n\t *\t\t\t\t},\n\t *\t\t\t\tlight: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'styled', 'styled-light' ]\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'styled',\n\t *\t\t\tview: modelAttributeValue => ( {\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: 'styled-' + modelAttributeValue\n\t *\t\t\t} )\n\t *\t\t} );\n\t *\n\t * **Note**: Downcasting to a style property requires providing `value` as an object:\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'lineHeight',\n\t *\t\t\tview: modelAttributeValue => ( {\n\t *\t\t\t\tkey: 'style',\n\t *\t\t\t\tvalue: {\n\t *\t\t\t\t\t'line-height': modelAttributeValue,\n\t *\t\t\t\t\t'border-bottom': '1px dotted #ba2'\n\t *\t\t\t\t}\n\t *\t\t\t} )\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n\t * the attribute key, possible values and, optionally, an element name to convert from.\n\t * @param {String|Object|module:engine/conversion/downcasthelpers~AttributeCreatorFunction} config.view A view attribute key,\n\t * or a `{ key, value }` object or a function that takes the model attribute value and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n\t * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an\n\t * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n\t * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n\t * `{ key, value }` objects or a functions.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tattributeToAttribute( config ) {\n\t\treturn this.add( downcastAttributeToAttribute( config ) );\n\t}\n\n\t/**\n\t * Model marker to view element conversion helper.\n\t *\n\t * **Note**: This method should be used mainly for editing the downcast and it is recommended\n\t * to use the {@link #markerToData `#markerToData()`} helper instead.\n\t *\n\t * This helper may produce invalid HTML code (e.g. a span between table cells).\n\t * It should only be used when you are sure that the produced HTML will be semantically correct.\n\t *\n\t * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker\n\t * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`\n\t * becomes `<p>F<span data-marker=\"search\"></span>oo b<span data-marker=\"search\"></span>ar</p>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: 'marker-search'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: 'search-result',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tattributes: {\n\t *\t\t\t\t\t'data-marker': 'search'\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: ( markerData, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\treturn writer.createUIElement( 'span', {\n\t *\t\t\t\t\t'data-marker': 'search',\n\t *\t\t\t\t\t'data-start': markerData.isOpening\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function\n\t * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n\t * as a parameters and should return an instance of the\n\t * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,\n\t * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for\n\t * the marker end boundary element.\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #markerToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model marker (or model marker group) to convert.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function that\n\t * takes the model marker data and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n\t * as a parameters and returns a view UI element.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tmarkerToElement( config ) {\n\t\treturn this.add( downcastMarkerToElement( config ) );\n\t}\n\n\t/**\n\t * Model marker to highlight conversion helper.\n\t *\n\t * This conversion results in creating a highlight on view nodes. For this kind of conversion,\n\t * the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.\n\t *\n\t * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes\n\t * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes\n\t * `<p>F<span class=\"comment\">oo b</span>ar</p>` in the view.\n\t *\n\t * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,\n\t * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).\n\t * For example, a model marker set like this:\n\t * `[<imageInline src=\"foo.jpg\"></imageInline>]` becomes `<img src=\"foo.jpg\" class=\"comment\"></img>` in the view.\n\t *\n\t * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it\n\t * to a container element, it is the container element instance itself that applies values from the highlight descriptor.\n\t * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n\t *\t\t\tmodel: 'comment',\n\t *\t\t\tview: { classes: 'comment' },\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n\t *\t\t\tmodel: 'comment',\n\t *\t\t\tview: ( data, conversionApi ) => {\n\t *\t\t\t\t// Assuming that the marker name is in a form of comment:commentType:commentId.\n\t *\t\t\t\tconst [ , commentType, commentId ] = data.markerName.split( ':' );\n\t *\n\t *\t\t\t\treturn {\n\t *\t\t\t\t\tclasses: [ 'comment', 'comment-' + commentType ],\n\t *\t\t\t\t\tattributes: { 'data-comment-id': commentId }\n\t *\t\t\t\t};\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function\n\t * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n\t * as the parameters and should return a\n\t * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.\n\t * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #markerToHighlight\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model marker (or model marker group) to convert.\n\t * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n\t * that will be used for highlighting or a function that takes the model marker data and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters\n\t * and returns a highlight descriptor.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tmarkerToHighlight( config ) {\n\t\treturn this.add( downcastMarkerToHighlight( config ) );\n\t}\n\n\t/**\n\t * Model marker converter for data downcast.\n\t *\n\t * This conversion creates a representation for model marker boundaries in the view:\n\t *\n\t * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.\n\t * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.\n\t *\n\t * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.\n\t * The default configuration for this conversion is that the first part is the `group` part and the rest of\n\t * the marker name becomes the `name` part.\n\t *\n\t * Tag and attribute names and values are generated from the marker name:\n\t *\n\t * * The templates for attributes are `data-[group]-start-before=\"[name]\"`, `data-[group]-start-after=\"[name]\"`,\n\t * `data-[group]-end-before=\"[name]\"` and `data-[group]-end-after=\"[name]\"`.\n\t * * The templates for view elements are `<[group]-start name=\"[name]\">` and `<[group]-end name=\"[name]\">`.\n\t *\n\t * Attributes mark whether the given marker's start or end boundary is before or after the given element.\n\t * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.\n\t * The other two are used when the former two cannot be used.\n\t *\n\t * The conversion configuration can take a function that will generate different group and name parts.\n\t * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two\n\t * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.\n\t *\n\t * Basic usage:\n\t *\n\t *\t\t// Using the default conversion.\n\t *\t\t// In this case, all markers with names starting with 'comment:' will be converted.\n\t *\t\t// The `group` parameter will be set to `comment`.\n\t *\t\t// The `name` parameter will be the rest of the marker name (without the `:`).\n\t *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n\t *\t\t\tmodel: 'comment'\n\t *\t\t} );\n\t *\n\t * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked\n\t * by `[]`):\n\t *\n\t *\t\t// Model:\n\t *\t\t<paragraph>Foo[bar</paragraph>\n\t *\t\t<imageBlock src=\"abc.jpg\"></imageBlock>]\n\t *\n\t *\t\t// View:\n\t *\t\t<p>Foo<comment-start name=\"commentId:uid\"></comment-start>bar</p>\n\t *\t\t<figure data-comment-end-after=\"commentId:uid\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n\t *\n\t * In the example above, the comment starts before \"bar\" and ends after the image.\n\t *\n\t * If the `name` part is empty, the following view may be generated:\n\t *\n\t *\t\t<p>Foo <myMarker-start></myMarker-start>bar</p>\n\t *\t\t<figure data-myMarker-end-after=\"\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n\t *\n\t * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.\n\t *\n\t * Examples where `data-group-start-after` and `data-group-end-before` are used:\n\t *\n\t *\t\t// Model:\n\t *\t\t<blockQuote>[]<paragraph>Foo</paragraph></blockQuote>\n\t *\n\t *\t\t// View:\n\t *\t\t<blockquote><p data-group-end-before=\"name\" data-group-start-before=\"name\">Foo</p></blockquote>\n\t *\n\t * Similarly, when a marker is collapsed after the last element:\n\t *\n\t *\t\t// Model:\n\t *\t\t<blockQuote><paragraph>Foo</paragraph>[]</blockQuote>\n\t *\n\t *\t\t// View:\n\t *\t\t<blockquote><p data-group-end-after=\"name\" data-group-start-after=\"name\">Foo</p></blockquote>\n\t *\n\t * When there are multiple markers from the same group stored in the same attribute of the same element, their\n\t * name parts are put together in the attribute value, for example: `data-group-start-before=\"name1,name2,name3\"`.\n\t *\n\t * Other examples of usage:\n\t *\n\t *\t\t// Using a custom function which is the same as the default conversion:\n\t *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n\t *\t\t\tmodel: 'comment'\n\t *\t\t\tview: markerName => ( {\n\t *\t\t\t\tgroup: 'comment',\n\t *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n\t *\t\t\t} )\n\t *\t\t} );\n\t *\n\t *\t\t// Using the converter priority:\n\t *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n\t *\t\t\tmodel: 'comment'\n\t *\t\t\tview: markerName => ( {\n\t *\t\t\t\tgroup: 'comment',\n\t *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n\t *\t\t\t} ),\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.\n\t *\n\t * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to\n\t * add a converter to the conversion process.\n\t *\n\t * @method #markerToData\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model marker (or the model marker group) to convert.\n\t * @param {Function} [config.view] A function that takes the model marker name and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters\n\t * and returns an object with the `group` and `name` properties.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tmarkerToData( config ) {\n\t\treturn this.add( downcastMarkerToData( config ) );\n\t}\n}\n\n/**\n * Function factory that creates a default downcast converter for text insertion changes.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'insert:$text', insertText() );\n *\n * @returns {Function} Insert text event converter.\n */\nexport function insertText() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\t\tconst viewText = viewWriter.createText( data.item.data );\n\n\t\tviewWriter.insert( viewPosition, viewText );\n\t};\n}\n\n/**\n * Function factory that creates a default downcast converter for triggering attributes and children conversion.\n *\n * @returns {Function} The converter.\n */\nexport function insertAttributesAndChildren() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconversionApi.convertAttributes( data.item );\n\n\t\t// Start converting children of the current item.\n\t\t// In case of reconversion children were already re-inserted or converted separately.\n\t\tif ( !data.reconversion && data.item.is( 'element' ) && !data.item.isEmpty ) {\n\t\t\tconversionApi.convertChildren( data.item );\n\t\t}\n\t};\n}\n\n/**\n * Function factory that creates a default downcast converter for node remove changes.\n *\n *\t\tmodelDispatcher.on( 'remove', remove() );\n *\n * @returns {Function} Remove event converter.\n */\nexport function remove() {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Find the view range start position by mapping the model position at which the remove happened.\n\t\tconst viewStart = conversionApi.mapper.toViewPosition( data.position );\n\n\t\tconst modelEnd = data.position.getShiftedBy( data.length );\n\t\tconst viewEnd = conversionApi.mapper.toViewPosition( modelEnd, { isPhantom: true } );\n\n\t\tconst viewRange = conversionApi.writer.createRange( viewStart, viewEnd );\n\n\t\t// Trim the range to remove in case some UI elements are on the view range boundaries.\n\t\tconst removed = conversionApi.writer.remove( viewRange.getTrimmed() );\n\n\t\t// After the range is removed, unbind all view elements from the model.\n\t\t// Range inside view document fragment is used to unbind deeply.\n\t\tfor ( const child of conversionApi.writer.createRangeIn( removed ).getItems() ) {\n\t\t\tconversionApi.mapper.unbindViewElement( child, { defer: true } );\n\t\t}\n\t};\n}\n\n/**\n * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information\n * provided by the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor} object. If the priority\n * is not provided in the descriptor, the default priority will be used.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\nexport function createViewElementFromHighlightDescriptor( writer, descriptor ) {\n\tconst viewElement = writer.createAttributeElement( 'span', descriptor.attributes );\n\n\tif ( descriptor.classes ) {\n\t\tviewElement._addClass( descriptor.classes );\n\t}\n\n\tif ( typeof descriptor.priority === 'number' ) {\n\t\tviewElement._priority = descriptor.priority;\n\t}\n\n\tviewElement._id = descriptor.id;\n\n\treturn viewElement;\n}\n\n/**\n * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}\n * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object and maps model positions from the selection to view positions.\n *\n *\t\tmodelDispatcher.on( 'selection', convertRangeSelection() );\n *\n * @returns {Function} Selection converter.\n */\nexport function convertRangeSelection() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst selection = data.selection;\n\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( selection, 'selection' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( const range of selection.getRanges() ) {\n\t\t\tconst viewRange = conversionApi.mapper.toViewRange( range );\n\t\t\tviewRanges.push( viewRange );\n\t\t}\n\n\t\tconversionApi.writer.setSelection( viewRanges, { backward: selection.isBackward } );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to\n * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object, maps the model selection position to the view position and breaks\n * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.\n *\n *\t\tmodelDispatcher.on( 'selection', convertCollapsedSelection() );\n *\n * An example of the view state before and after converting the collapsed selection:\n *\n *\t\t   <p><strong>f^oo<strong>bar</p>\n *\t\t-> <p><strong>f</strong>^<strong>oo</strong>bar</p>\n *\n * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is\n * converted, broken attributes might be merged again, or the position where the selection is may be wrapped\n * with different, appropriate attribute elements.\n *\n * See also {@link module:engine/conversion/downcasthelpers~clearAttributes} which does a clean-up\n * by merging attributes.\n *\n * @returns {Function} Selection converter.\n */\nexport function convertCollapsedSelection() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst selection = data.selection;\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( selection, 'selection' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst modelPosition = selection.getFirstPosition();\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( modelPosition );\n\t\tconst brokenPosition = viewWriter.breakAttributes( viewPosition );\n\n\t\tviewWriter.setSelection( brokenPosition );\n\t};\n}\n\n/**\n * Function factory that creates a converter which clears artifacts after the previous\n * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty\n * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end\n * positions of all ranges.\n *\n *\t\t   <p><strong>^</strong></p>\n *\t\t-> <p>^</p>\n *\n *\t\t   <p><strong>foo</strong>^<strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n *\t\t   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n * This listener should be assigned before any converter for the new selection:\n *\n *\t\tmodelDispatcher.on( 'selection', clearAttributes() );\n *\n * See {@link module:engine/conversion/downcasthelpers~convertCollapsedSelection}\n * which does the opposite by breaking attributes in the selection position.\n *\n * @returns {Function} Selection converter.\n */\nexport function clearAttributes() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tfor ( const range of viewSelection.getRanges() ) {\n\t\t\t// Not collapsed selection should not have artifacts.\n\t\t\tif ( range.isCollapsed ) {\n\t\t\t\t// Position might be in the node removed by the view writer.\n\t\t\t\tif ( range.end.parent.isAttached() ) {\n\t\t\t\t\tconversionApi.writer.mergeAttributes( range.start );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tviewWriter.setSelection( null );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts the set/change/remove attribute changes from the model to the view.\n * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the\n * selection will be put inside it.\n *\n * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to\n * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model\n * but are represented as an element in the view:\n *\n *\t\t[paragraph]              MODEL ====> VIEW        <p>\n *\t\t\t|- a {bold: true}                             |- <b>\n *\t\t\t|- b {bold: true}                             |   |- ab\n *\t\t\t|- c                                          |- c\n *\n * Passed `Function` will be provided with the attribute value and then all the parameters of the\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be the wrapping element.\n * When the provided `Function` does not return any element, no conversion will take place.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:bold', wrap( ( modelAttributeValue, { writer } ) => {\n *\t\t\treturn writer.createAttributeElement( 'strong' );\n *\t\t} );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element that will be used for wrapping.\n * @returns {Function} Set/change attribute converter.\n */\nexport function wrap( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !conversionApi.consumable.test( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed\n\t\t// or the attribute was removed.\n\t\tconst oldViewElement = elementCreator( data.attributeOldValue, conversionApi, data );\n\n\t\t// Create node to wrap with.\n\t\tconst newViewElement = elementCreator( data.attributeNewValue, conversionApi, data );\n\n\t\tif ( !oldViewElement && !newViewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconversionApi.consumable.consume( data.item, evt.name );\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tif ( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) {\n\t\t\t// Selection attribute conversion.\n\t\t\tviewWriter.wrap( viewSelection.getFirstRange(), newViewElement );\n\t\t} else {\n\t\t\t// Node attribute conversion.\n\t\t\tlet viewRange = conversionApi.mapper.toViewRange( data.range );\n\n\t\t\t// First, unwrap the range from current wrapper.\n\t\t\tif ( data.attributeOldValue !== null && oldViewElement ) {\n\t\t\t\tviewRange = viewWriter.unwrap( viewRange, oldViewElement );\n\t\t\t}\n\n\t\t\tif ( data.attributeNewValue !== null && newViewElement ) {\n\t\t\t\tviewWriter.wrap( viewRange, newViewElement );\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts node insertion changes from the model to the view.\n * The function passed will be provided with all the parameters of the dispatcher's\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be inserted into the view.\n *\n * The converter automatically consumes the corresponding value from the consumables list and binds the model and view elements.\n *\n *\t\tdowncastDispatcher.on(\n *\t\t\t'insert:myElem',\n *\t\t\tinsertElement( ( modelItem, { writer } ) => {\n *\t\t\t\tconst text = writer.createText( 'myText' );\n *\t\t\t\tconst myElem = writer.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );\n *\n *\t\t\t\t// Do something fancy with `myElem` using `modelItem` or other parameters.\n *\n *\t\t\t\treturn myElem;\n *\t\t\t}\n *\t\t) );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element, which will be inserted.\n * @param {module:engine/conversion/downcasthelpers~ConsumerFunction} [consumer] Function defining element consumption process.\n * By default this function just consume passed item insertion.\n * @returns {Function} Insert element event converter.\n */\nexport function insertElement( elementCreator, consumer = defaultConsumer ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !consumer( data.item, conversionApi.consumable, { preflight: true } ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = elementCreator( data.item, conversionApi, data );\n\n\t\tif ( !viewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consume an element insertion and all present attributes that are specified as a reconversion triggers.\n\t\tconsumer( data.item, conversionApi.consumable );\n\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\n\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n\t\tconversionApi.writer.insert( viewPosition, viewElement );\n\n\t\t// Convert attributes before converting children.\n\t\tconversionApi.convertAttributes( data.item );\n\n\t\t// Convert children or reinsert previous view elements.\n\t\treinsertOrConvertNodes( viewElement, data.item.getChildren(), conversionApi, { reconversion: data.reconversion } );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts a single model node insertion to a view structure.\n *\n * It is expected that the passed element creator function returns an {@link module:engine/view/element~Element} with attached slots\n * created with `writer.createSlot()` to indicate where child nodes should be converted.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n *\n * @protected\n * @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} elementCreator Function returning a view structure,\n * which will be inserted.\n * @param {module:engine/conversion/downcasthelpers~ConsumerFunction} consumer A callback that is expected to consume all the consumables\n * that were used by the element creator.\n * @returns {Function} Insert element event converter.\n*/\nexport function insertStructure( elementCreator, consumer ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !consumer( data.item, conversionApi.consumable, { preflight: true } ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst slotsMap = new Map();\n\n\t\tconversionApi.writer._registerSlotFactory( createSlotFactory( data.item, slotsMap, conversionApi ) );\n\n\t\t// View creation.\n\t\tconst viewElement = elementCreator( data.item, conversionApi, data );\n\n\t\tconversionApi.writer._clearSlotFactory();\n\n\t\tif ( !viewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if all children are covered by slots and there is no child that landed in multiple slots.\n\t\tvalidateSlotsChildren( data.item, slotsMap, conversionApi );\n\n\t\t// Consume an element insertion and all present attributes that are specified as a reconversion triggers.\n\t\tconsumer( data.item, conversionApi.consumable );\n\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\n\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n\t\tconversionApi.writer.insert( viewPosition, viewElement );\n\n\t\t// Convert attributes before converting children.\n\t\tconversionApi.convertAttributes( data.item );\n\n\t\t// Fill view slots with previous view elements or create new ones.\n\t\tfillSlots( viewElement, slotsMap, conversionApi, { reconversion: data.reconversion } );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts marker adding change to the\n * {@link module:engine/view/uielement~UIElement view UI element}.\n *\n * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.\n * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning\n * and at the end of the range.\n *\n * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n *\n * @protected\n * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element\n * that will be inserted.\n * @returns {Function} Insert element event converter.\n */\nexport function insertUIElement( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Create two view elements. One will be inserted at the beginning of marker, one at the end.\n\t\t// If marker is collapsed, only \"opening\" element will be inserted.\n\t\tdata.isOpening = true;\n\t\tconst viewStartElement = elementCreator( data, conversionApi );\n\n\t\tdata.isOpening = false;\n\t\tconst viewEndElement = elementCreator( data, conversionApi );\n\n\t\tif ( !viewStartElement || !viewEndElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst markerRange = data.markerRange;\n\n\t\t// Marker that is collapsed has consumable build differently that non-collapsed one.\n\t\t// For more information see `addMarker` event description.\n\t\t// If marker's range is collapsed - check if it can be consumed.\n\t\tif ( markerRange.isCollapsed && !conversionApi.consumable.consume( markerRange, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If marker's range is not collapsed - consume all items inside.\n\t\tfor ( const value of markerRange ) {\n\t\t\tif ( !conversionApi.consumable.consume( value.item, evt.name ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst mapper = conversionApi.mapper;\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// Add \"opening\" element.\n\t\tviewWriter.insert( mapper.toViewPosition( markerRange.start ), viewStartElement );\n\t\tconversionApi.mapper.bindElementToMarker( viewStartElement, data.markerName );\n\n\t\t// Add \"closing\" element only if range is not collapsed.\n\t\tif ( !markerRange.isCollapsed ) {\n\t\t\tviewWriter.insert( mapper.toViewPosition( markerRange.end ), viewEndElement );\n\t\t\tconversionApi.mapper.bindElementToMarker( viewEndElement, data.markerName );\n\t\t}\n\n\t\tevt.stop();\n\t};\n}\n\n// Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}\n// based on marker remove change.\n//\n// This converter unbinds elements from the marker name.\n//\n// @returns {Function} Removed UI element converter.\nfunction removeUIElement() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const element of elements ) {\n\t\t\tconversionApi.mapper.unbindElementFromMarkerName( element, data.markerName );\n\t\t\tconversionApi.writer.clear( conversionApi.writer.createRangeOn( element ), element );\n\t\t}\n\n\t\tconversionApi.writer.clearClonedElementsGroup( data.markerName );\n\n\t\tevt.stop();\n\t};\n}\n\n// Function factory that creates a default converter for model markers.\n//\n// See {@link DowncastHelpers#markerToData} for more information what type of view is generated.\n//\n// This converter binds created UI elements and affected view elements with the marker name\n// using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n//\n// @returns {Function} Add marker converter.\nfunction insertMarkerData( viewCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewMarkerData = viewCreator( data.markerName, conversionApi );\n\n\t\tif ( !viewMarkerData ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst markerRange = data.markerRange;\n\n\t\tif ( !conversionApi.consumable.consume( markerRange, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Adding closing data first to keep the proper order in the view.\n\t\thandleMarkerBoundary( markerRange, false, conversionApi, data, viewMarkerData );\n\t\thandleMarkerBoundary( markerRange, true, conversionApi, data, viewMarkerData );\n\n\t\tevt.stop();\n\t};\n}\n\n// Helper function for `insertMarkerData()` that marks a marker boundary at the beginning or end of given `range`.\nfunction handleMarkerBoundary( range, isStart, conversionApi, data, viewMarkerData ) {\n\tconst modelPosition = isStart ? range.start : range.end;\n\tconst elementAfter = modelPosition.nodeAfter && modelPosition.nodeAfter.is( 'element' ) ? modelPosition.nodeAfter : null;\n\tconst elementBefore = modelPosition.nodeBefore && modelPosition.nodeBefore.is( 'element' ) ? modelPosition.nodeBefore : null;\n\n\tif ( elementAfter || elementBefore ) {\n\t\tlet modelElement;\n\t\tlet isBefore;\n\n\t\t// If possible, we want to add `data-group-start-before` and `data-group-end-after` attributes.\n\t\tif ( isStart && elementAfter || !isStart && !elementBefore ) {\n\t\t\t// [<elementAfter>...</elementAfter> -> <elementAfter data-group-start-before=\"...\">...</elementAfter>\n\t\t\t// <parent>]<elementAfter> -> <parent><elementAfter data-group-end-before=\"...\">\n\t\t\tmodelElement = elementAfter;\n\t\t\tisBefore = true;\n\t\t} else {\n\t\t\t// <elementBefore>...</elementBefore>] -> <elementBefore data-group-end-after=\"...\">...</elementBefore>\n\t\t\t// </elementBefore>[</parent> -> </elementBefore data-group-start-after=\"...\"></parent>\n\t\t\tmodelElement = elementBefore;\n\t\t\tisBefore = false;\n\t\t}\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( modelElement );\n\n\t\t// In rare circumstances, the model element may be not mapped to any view element and that would cause an error.\n\t\t// One of those situations is a soft break inside code block.\n\t\tif ( viewElement ) {\n\t\t\tinsertMarkerAsAttribute( viewElement, isStart, isBefore, conversionApi, data, viewMarkerData );\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst viewPosition = conversionApi.mapper.toViewPosition( modelPosition );\n\n\tinsertMarkerAsElement( viewPosition, isStart, conversionApi, data, viewMarkerData );\n}\n\n// Helper function for `insertMarkerData()` that marks a marker boundary in the view as an attribute on a view element.\nfunction insertMarkerAsAttribute( viewElement, isStart, isBefore, conversionApi, data, viewMarkerData ) {\n\tconst attributeName = `data-${ viewMarkerData.group }-${ isStart ? 'start' : 'end' }-${ isBefore ? 'before' : 'after' }`;\n\n\tconst markerNames = viewElement.hasAttribute( attributeName ) ? viewElement.getAttribute( attributeName ).split( ',' ) : [];\n\n\t// Adding marker name at the beginning to have the same order in the attribute as there is with marker elements.\n\tmarkerNames.unshift( viewMarkerData.name );\n\n\tconversionApi.writer.setAttribute( attributeName, markerNames.join( ',' ), viewElement );\n\tconversionApi.mapper.bindElementToMarker( viewElement, data.markerName );\n}\n\n// Helper function for `insertMarkerData()` that marks a marker boundary in the view as a separate view ui element.\nfunction insertMarkerAsElement( position, isStart, conversionApi, data, viewMarkerData ) {\n\tconst viewElementName = `${ viewMarkerData.group }-${ isStart ? 'start' : 'end' }`;\n\n\tconst attrs = viewMarkerData.name ? { 'name': viewMarkerData.name } : null;\n\tconst viewElement = conversionApi.writer.createUIElement( viewElementName, attrs );\n\n\tconversionApi.writer.insert( position, viewElement );\n\tconversionApi.mapper.bindElementToMarker( viewElement, data.markerName );\n}\n\n// Function factory that creates a converter for removing a model marker data added by the {@link #insertMarkerData} converter.\n//\n// @returns {Function} Remove marker converter.\nfunction removeMarkerData( viewCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewData = viewCreator( data.markerName, conversionApi );\n\n\t\tif ( !viewData ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const element of elements ) {\n\t\t\tconversionApi.mapper.unbindElementFromMarkerName( element, data.markerName );\n\n\t\t\tif ( element.is( 'containerElement' ) ) {\n\t\t\t\tremoveMarkerFromAttribute( `data-${ viewData.group }-start-before`, element );\n\t\t\t\tremoveMarkerFromAttribute( `data-${ viewData.group }-start-after`, element );\n\t\t\t\tremoveMarkerFromAttribute( `data-${ viewData.group }-end-before`, element );\n\t\t\t\tremoveMarkerFromAttribute( `data-${ viewData.group }-end-after`, element );\n\t\t\t} else {\n\t\t\t\tconversionApi.writer.clear( conversionApi.writer.createRangeOn( element ), element );\n\t\t\t}\n\t\t}\n\n\t\tconversionApi.writer.clearClonedElementsGroup( data.markerName );\n\n\t\tevt.stop();\n\n\t\tfunction removeMarkerFromAttribute( attributeName, element ) {\n\t\t\tif ( element.hasAttribute( attributeName ) ) {\n\t\t\t\tconst markerNames = new Set( element.getAttribute( attributeName ).split( ',' ) );\n\t\t\t\tmarkerNames.delete( viewData.name );\n\n\t\t\t\tif ( markerNames.size == 0 ) {\n\t\t\t\t\tconversionApi.writer.removeAttribute( attributeName, element );\n\t\t\t\t} else {\n\t\t\t\t\tconversionApi.writer.setAttribute( attributeName, Array.from( markerNames ).join( ',' ), element );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Function factory that creates a converter which converts the set/change/remove attribute changes from the model to the view.\n//\n// Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate\n// a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element\n// attributes on a one-to-one basis.\n//\n// *Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.\n//\n// The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n// {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n//\n//\t\tmodelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {\n//\t\t\t// Change attribute key from `customAttr` to `class` in the view.\n//\t\t\tconst key = 'class';\n//\t\t\tlet value = data.attributeNewValue;\n//\n//\t\t\t// Force attribute value to 'empty' if the model element is empty.\n//\t\t\tif ( data.item.childCount === 0 ) {\n//\t\t\t\tvalue = 'empty';\n//\t\t\t}\n//\n//\t\t\t// Return the key-value pair.\n//\t\t\treturn { key, value };\n//\t\t} ) );\n//\n// @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which\n// represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.\n// The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.\n// @returns {Function} Set/change attribute converter.\nfunction changeAttribute( attributeCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !conversionApi.consumable.test( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldAttribute = attributeCreator( data.attributeOldValue, conversionApi, data );\n\t\tconst newAttribute = attributeCreator( data.attributeNewValue, conversionApi, data );\n\n\t\tif ( !oldAttribute && !newAttribute ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconversionApi.consumable.consume( data.item, evt.name );\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// If model item cannot be mapped to a view element, it means item is not an `Element` instance but a `TextProxy` node.\n\t\t// Only elements can have attributes in a view so do not proceed for anything else (#1587).\n\t\tif ( !viewElement ) {\n\t\t\t/**\n\t\t\t * This error occurs when a {@link module:engine/model/textproxy~TextProxy text node's} attribute is to be downcasted\n\t\t\t * by an {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `Attribute to Attribute converter`}.\n\t\t\t * In most cases it is caused by converters misconfiguration when only \"generic\" converter is defined:\n\t\t\t *\n\t\t\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t\t\t *\t\t\tmodel: 'attribute-name',\n\t\t\t *\t\t\tview: 'attribute-name'\n\t\t\t *\t\t} ) );\n\t\t\t *\n\t\t\t * and given attribute is used on text node, for example:\n\t\t\t *\n\t\t\t *\t\tmodel.change( writer => {\n\t\t\t *\t\t\twriter.insertText( 'Foo', { 'attribute-name': 'bar' }, parent, 0 );\n\t\t\t *\t\t} );\n\t\t\t *\n\t\t\t * In such cases, to convert the same attribute for both {@link module:engine/model/element~Element}\n\t\t\t * and {@link module:engine/model/textproxy~TextProxy `Text`} nodes, text specific\n\t\t\t * {@link module:engine/conversion/conversion~Conversion#attributeToElement `Attribute to Element converter`}\n\t\t\t * with higher {@link module:utils/priorities~PriorityString priority} must also be defined:\n\t\t\t *\n\t\t\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t\t\t *\t\t\tmodel: {\n\t\t\t *\t\t\t\tkey: 'attribute-name',\n\t\t\t *\t\t\t\tname: '$text'\n\t\t\t *\t\t\t},\n\t\t\t *\t\t\tview: ( value, { writer } ) => {\n\t\t\t *\t\t\t\treturn writer.createAttributeElement( 'span', { 'attribute-name': value } );\n\t\t\t *\t\t\t},\n\t\t\t *\t\t\tconverterPriority: 'high'\n\t\t\t *\t\t} ) );\n\t\t\t *\n\t\t\t * @error conversion-attribute-to-attribute-on-text\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-attribute-to-attribute-on-text', conversionApi.dispatcher, data );\n\t\t}\n\n\t\t// First remove the old attribute if there was one.\n\t\tif ( data.attributeOldValue !== null && oldAttribute ) {\n\t\t\tif ( oldAttribute.key == 'class' ) {\n\t\t\t\tconst classes = toArray( oldAttribute.value );\n\n\t\t\t\tfor ( const className of classes ) {\n\t\t\t\t\tviewWriter.removeClass( className, viewElement );\n\t\t\t\t}\n\t\t\t} else if ( oldAttribute.key == 'style' ) {\n\t\t\t\tconst keys = Object.keys( oldAttribute.value );\n\n\t\t\t\tfor ( const key of keys ) {\n\t\t\t\t\tviewWriter.removeStyle( key, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tviewWriter.removeAttribute( oldAttribute.key, viewElement );\n\t\t\t}\n\t\t}\n\n\t\t// Then set the new attribute.\n\t\tif ( data.attributeNewValue !== null && newAttribute ) {\n\t\t\tif ( newAttribute.key == 'class' ) {\n\t\t\t\tconst classes = toArray( newAttribute.value );\n\n\t\t\t\tfor ( const className of classes ) {\n\t\t\t\t\tviewWriter.addClass( className, viewElement );\n\t\t\t\t}\n\t\t\t} else if ( newAttribute.key == 'style' ) {\n\t\t\t\tconst keys = Object.keys( newAttribute.value );\n\n\t\t\t\tfor ( const key of keys ) {\n\t\t\t\t\tviewWriter.setStyle( key, newAttribute.value[ key ], viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tviewWriter.setAttribute( newAttribute.key, newAttribute.value, viewElement );\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with\n// {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.\n// See {link module:engine/conversion/downcasthelpers~createViewElementFromHighlightDescriptor}.\n//\n// It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be\n// created and the selection will be put inside it.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name\n// using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightText( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !data.item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) && !data.item.is( '$textProxy' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewElement = createViewElementFromHighlightDescriptor( viewWriter, descriptor );\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tif ( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) {\n\t\t\tviewWriter.wrap( viewSelection.getFirstRange(), viewElement, viewSelection );\n\t\t} else {\n\t\t\tconst viewRange = conversionApi.mapper.toViewRange( data.range );\n\t\t\tconst rangeAfterWrap = viewWriter.wrap( viewRange, viewElement );\n\n\t\t\tfor ( const element of rangeAfterWrap.getItems() ) {\n\t\t\t\tif ( element.is( 'attributeElement' ) && element.isSimilar( viewElement ) ) {\n\t\t\t\t\tconversionApi.mapper.bindElementToMarker( element, data.markerName );\n\n\t\t\t\t\t// One attribute element is enough, because all of them are bound together by the view writer.\n\t\t\t\t\t// Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.\n//\n// The converter checks if an element has the `addHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.\n// In such case the converter will consume all element's children, assuming that they were handled by the element itself.\n//\n// When the `addHighlight` custom property is not present, the element is not converted in any special way.\n// This means that converters will proceed to convert the element's child nodes.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using\n// the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightElement( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !data.item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !( data.item instanceof ModelElement ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.test( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\n\t\tif ( viewElement && viewElement.getCustomProperty( 'addHighlight' ) ) {\n\t\t\t// Consume element itself.\n\t\t\tconversionApi.consumable.consume( data.item, evt.name );\n\n\t\t\t// Consume all children nodes.\n\t\t\tfor ( const value of ModelRange._createIn( data.item ) ) {\n\t\t\t\tconversionApi.consumable.consume( value.item, evt.name );\n\t\t\t}\n\n\t\t\tviewElement.getCustomProperty( 'addHighlight' )( viewElement, descriptor, conversionApi.writer );\n\n\t\t\tconversionApi.mapper.bindElementToMarker( viewElement, data.markerName );\n\t\t}\n\t};\n}\n\n// Function factory that creates a converter which converts the removing model marker to the view.\n//\n// Both text nodes and elements are handled by this converter but they are handled a bit differently.\n//\n// Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the\n// provided highlight descriptor. See {link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n//\n// For elements, the converter checks if an element has the `removeHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.\n// In such case, the children of that element will not be converted.\n//\n// When `removeHighlight` is not present, the element is not converted in any special way.\n// The converter will proceed to convert the element's child nodes instead.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter unbinds elements from the marker name.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction removeHighlight( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// This conversion makes sense only for non-collapsed range.\n\t\tif ( data.markerRange.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// View element that will be used to unwrap `AttributeElement`s.\n\t\tconst viewHighlightElement = createViewElementFromHighlightDescriptor( conversionApi.writer, descriptor );\n\n\t\t// Get all elements bound with given marker name.\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const element of elements ) {\n\t\t\tconversionApi.mapper.unbindElementFromMarkerName( element, data.markerName );\n\n\t\t\tif ( element.is( 'attributeElement' ) ) {\n\t\t\t\tconversionApi.writer.unwrap( conversionApi.writer.createRangeOn( element ), viewHighlightElement );\n\t\t\t} else {\n\t\t\t\t// if element.is( 'containerElement' ).\n\t\t\t\telement.getCustomProperty( 'removeHighlight' )( element, descriptor.id, conversionApi.writer );\n\t\t\t}\n\t\t}\n\n\t\tconversionApi.writer.clearClonedElementsGroup( data.markerName );\n\n\t\tevt.stop();\n\t};\n}\n\n// Model element to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToElement `.elementToElement()` downcast helper} for examples and config params description.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The description or a name of the model element to convert.\n// @param {String|Array.<String>} [config.model.attributes] List of attributes triggering element reconversion.\n// @param {Boolean} [config.model.children] Should reconvert element if the list of model child nodes changed.\n// @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~ElementCreatorFunction}\n// config.view\n// @returns {Function} Conversion helper.\nfunction downcastElementToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconfig.model = normalizeModelElementConfig( config.model );\n\tconfig.view = normalizeToElementConfig( config.view, 'container' );\n\n\t// Trigger reconversion on children list change if element is a subject to any reconversion.\n\t// This is required to be able to trigger Differ#refreshItem() on a direct child of the reconverted element.\n\tif ( config.model.attributes.length ) {\n\t\tconfig.model.children = true;\n\t}\n\n\treturn dispatcher => {\n\t\tdispatcher.on(\n\t\t\t'insert:' + config.model.name,\n\t\t\tinsertElement( config.view, createConsumer( config.model ) ),\n\t\t\t{ priority: config.converterPriority || 'normal' }\n\t\t);\n\n\t\tif ( config.model.children || config.model.attributes.length ) {\n\t\t\tdispatcher.on( 'reduceChanges', createChangeReducer( config.model ), { priority: 'low' } );\n\t\t}\n\t};\n}\n\n// Model element to view structure conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToStructure `.elementToStructure()` downcast helper} for examples and config params description.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model\n// @param {String} [config.model.name]\n// @param {Array.<String>} [config.model.attributes]\n// @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} config.view\n// @returns {Function} Conversion helper.\nfunction downcastElementToStructure( config ) {\n\tconfig = cloneDeep( config );\n\n\tconfig.model = normalizeModelElementConfig( config.model );\n\tconfig.view = normalizeToElementConfig( config.view, 'container' );\n\n\t// Trigger reconversion on children list change because it always needs to use slots to put children in proper places.\n\t// This is required to be able to trigger Differ#refreshItem() on a direct child of the reconverted element.\n\tconfig.model.children = true;\n\n\treturn dispatcher => {\n\t\tif ( dispatcher._conversionApi.schema.checkChild( config.model.name, '$text' ) ) {\n\t\t\t/**\n\t\t\t * This error occurs when a {@link module:engine/model/element~Element model element} is downcasted\n\t\t\t * via {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure} helper but the element was\n\t\t\t * allowed to host `$text` by the {@link module:engine/model/schema~Schema model schema}.\n\t\t\t *\n\t\t\t * For instance, this may be the result of `myElement` allowing the content of\n\t\t\t * {@glink framework/guides/deep-dive/schema#generic-items `$block`} in its schema definition:\n\t\t\t *\n\t\t\t *\t\t// Element definition in schema.\n\t\t\t *\t\tschema.register( 'myElement', {\n\t\t\t *\t\t\tallowContentOf: '$block',\n\t\t\t *\n\t\t\t *\t\t\t// ...\n\t\t\t *\t\t} );\n\t\t\t *\n\t\t\t *\t\t// ...\n\t\t\t *\n\t\t\t *\t\t// Conversion of myElement with the use of elementToStructure().\n\t\t\t *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n\t\t\t *\t\t\tmodel: 'myElement',\n\t\t\t *\t\t\tview: ( modelElement, { writer } ) => {\n\t\t\t *\t\t\t\t// ...\n\t\t\t *\t\t\t}\n\t\t\t *\t\t} );\n\t\t\t *\n\t\t\t * In such case, {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`} helper\n\t\t\t * can be used instead to get around this problem:\n\t\t\t *\n\t\t\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t\t\t *\t\t\tmodel: 'myElement',\n\t\t\t *\t\t\tview: ( modelElement, { writer } ) => {\n\t\t\t *\t\t\t\t// ...\n\t\t\t *\t\t\t}\n\t\t\t *\t\t} );\n\t\t\t *\n\t\t\t * @error conversion-element-to-structure-disallowed-text\n\t\t\t * @param {String} elementName The name of the element the structure is to be created for.\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-element-to-structure-disallowed-text', dispatcher, { elementName: config.model.name } );\n\t\t}\n\n\t\tdispatcher.on(\n\t\t\t'insert:' + config.model.name,\n\t\t\tinsertStructure( config.view, createConsumer( config.model ) ),\n\t\t\t{ priority: config.converterPriority || 'normal' }\n\t\t);\n\n\t\tdispatcher.on( 'reduceChanges', createChangeReducer( config.model ), { priority: 'low' } );\n\t};\n}\n\n// Model attribute to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToElement `.attributeToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n// of `String`s with possible values if the model attribute is an enumerable.\n// @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction|\n// Object} config.view A view element definition or a function that takes the model attribute value and\n// {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} as parameters and returns a view attribute element.\n// If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values` to view element\n// definitions or functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst modelKey = config.model.key ? config.model.key : config.model;\n\tlet eventName = 'attribute:' + modelKey;\n\n\tif ( config.model.name ) {\n\t\teventName += ':' + config.model.name;\n\t}\n\n\tif ( config.model.values ) {\n\t\tfor ( const modelValue of config.model.values ) {\n\t\t\tconfig.view[ modelValue ] = normalizeToElementConfig( config.view[ modelValue ], 'attribute' );\n\t\t}\n\t} else {\n\t\tconfig.view = normalizeToElementConfig( config.view, 'attribute' );\n\t}\n\n\tconst elementCreator = getFromAttributeCreator( config );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, wrap( elementCreator ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model attribute to view attribute conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToAttribute `.attributeToAttribute()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n// the attribute key, possible values and, optionally, an element name to convert from.\n// @param {String|Object|module:engine/conversion/downcasthelpers~AttributeCreatorFunction} config.view A view attribute key,\n// or a `{ key, value }` object or a function that takes the model attribute value and returns a `{ key, value }` object.\n// If `key` is `'class'`, `value` can be a `String` or an array of `String`s. If `key` is `'style'`, `value` is an object with\n// key-value pairs. In other cases, `value` is a `String`.\n// If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n// `{ key, value }` objects or a functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst modelKey = config.model.key ? config.model.key : config.model;\n\tlet eventName = 'attribute:' + modelKey;\n\n\tif ( config.model.name ) {\n\t\teventName += ':' + config.model.name;\n\t}\n\n\tif ( config.model.values ) {\n\t\tfor ( const modelValue of config.model.values ) {\n\t\t\tconfig.view[ modelValue ] = normalizeToAttributeConfig( config.view[ modelValue ] );\n\t\t}\n\t} else {\n\t\tconfig.view = normalizeToAttributeConfig( config.view );\n\t}\n\n\tconst elementCreator = getFromAttributeCreator( config );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, changeAttribute( elementCreator ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model marker to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model marker data as a parameter and returns a view UI element.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconfig.view = normalizeToElementConfig( config.view, 'ui' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + config.model, insertUIElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + config.model, removeUIElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model marker to view data conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToData `markerToData()` downcast helper} to learn more.\n//\n// @param {Object} config\n// @param {String} config.model\n// @param {Function} [config.view]\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal']\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToData( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst group = config.model;\n\n\t// Default conversion.\n\tif ( !config.view ) {\n\t\tconfig.view = markerName => ( {\n\t\t\tgroup,\n\t\t\tname: markerName.substr( config.model.length + 1 )\n\t\t} );\n\t}\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + group, insertMarkerData( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + group, removeMarkerData( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model marker to highlight conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n// that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToHighlight( config ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + config.model, highlightText( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'addMarker:' + config.model, highlightElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + config.model, removeHighlight( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Takes `config.model`, and converts it to an object with normalized structure.\n//\n// @param {String|Object} model Model configuration or element name.\n// @param {String} model.name\n// @param {Array.<String>} [model.attributes]\n// @param {Boolean} [model.children]\n// @returns {Object}\nfunction normalizeModelElementConfig( model ) {\n\tif ( typeof model == 'string' ) {\n\t\tmodel = { name: model };\n\t}\n\n\t// List of attributes that should trigger reconversion.\n\tif ( !model.attributes ) {\n\t\tmodel.attributes = [];\n\t} else if ( !Array.isArray( model.attributes ) ) {\n\t\tmodel.attributes = [ model.attributes ];\n\t}\n\n\t// Whether a children insertion/deletion should trigger reconversion.\n\tmodel.children = !!model.children;\n\n\treturn model;\n}\n\n// Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it\n// to a function (because lower level converters accept only element creator functions).\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.\n// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.\n// @returns {Function} Element creator function to use in lower level converters.\nfunction normalizeToElementConfig( view, viewElementType ) {\n\tif ( typeof view == 'function' ) {\n\t\t// If `view` is already a function, don't do anything.\n\t\treturn view;\n\t}\n\n\treturn ( modelData, conversionApi ) => createViewElementFromDefinition( view, conversionApi, viewElementType );\n}\n\n// Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {'container'|'attribute'|'ui'} viewElementType\n// @returns {module:engine/view/element~Element}\nfunction createViewElementFromDefinition( viewElementDefinition, conversionApi, viewElementType ) {\n\tif ( typeof viewElementDefinition == 'string' ) {\n\t\t// If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.\n\t\tviewElementDefinition = { name: viewElementDefinition };\n\t}\n\n\tlet element;\n\tconst viewWriter = conversionApi.writer;\n\tconst attributes = Object.assign( {}, viewElementDefinition.attributes );\n\n\tif ( viewElementType == 'container' ) {\n\t\telement = viewWriter.createContainerElement( viewElementDefinition.name, attributes );\n\t} else if ( viewElementType == 'attribute' ) {\n\t\tconst options = {\n\t\t\tpriority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY\n\t\t};\n\n\t\telement = viewWriter.createAttributeElement( viewElementDefinition.name, attributes, options );\n\t} else {\n\t\t// 'ui'.\n\t\telement = viewWriter.createUIElement( viewElementDefinition.name, attributes );\n\t}\n\n\tif ( viewElementDefinition.styles ) {\n\t\tconst keys = Object.keys( viewElementDefinition.styles );\n\n\t\tfor ( const key of keys ) {\n\t\t\tviewWriter.setStyle( key, viewElementDefinition.styles[ key ], element );\n\t\t}\n\t}\n\n\tif ( viewElementDefinition.classes ) {\n\t\tconst classes = viewElementDefinition.classes;\n\n\t\tif ( typeof classes == 'string' ) {\n\t\t\tviewWriter.addClass( classes, element );\n\t\t} else {\n\t\t\tfor ( const className of classes ) {\n\t\t\t\tviewWriter.addClass( className, element );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn element;\n}\n\nfunction getFromAttributeCreator( config ) {\n\tif ( config.model.values ) {\n\t\treturn ( modelAttributeValue, conversionApi ) => {\n\t\t\tconst view = config.view[ modelAttributeValue ];\n\n\t\t\tif ( view ) {\n\t\t\t\treturn view( modelAttributeValue, conversionApi );\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\t} else {\n\t\treturn config.view;\n\t}\n}\n\n// Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters\n// for generating a view attribute.\n//\n// @param {Object} view View configuration.\nfunction normalizeToAttributeConfig( view ) {\n\tif ( typeof view == 'string' ) {\n\t\treturn modelAttributeValue => ( { key: view, value: modelAttributeValue } );\n\t} else if ( typeof view == 'object' ) {\n\t\t// { key, value, ... }\n\t\tif ( view.value ) {\n\t\t\treturn () => view;\n\t\t}\n\t\t// { key, ... }\n\t\telse {\n\t\t\treturn modelAttributeValue => ( { key: view.key, value: modelAttributeValue } );\n\t\t}\n\t} else {\n\t\t// function.\n\t\treturn view;\n\t}\n}\n\n// Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.\nfunction prepareDescriptor( highlightDescriptor, data, conversionApi ) {\n\t// If passed descriptor is a creator function, call it. If not, just use passed value.\n\tconst descriptor = typeof highlightDescriptor == 'function' ?\n\t\thighlightDescriptor( data, conversionApi ) :\n\t\thighlightDescriptor;\n\n\tif ( !descriptor ) {\n\t\treturn null;\n\t}\n\n\t// Apply default descriptor priority.\n\tif ( !descriptor.priority ) {\n\t\tdescriptor.priority = 10;\n\t}\n\n\t// Default descriptor id is marker name.\n\tif ( !descriptor.id ) {\n\t\tdescriptor.id = data.markerName;\n\t}\n\n\treturn descriptor;\n}\n\n// Creates a function that checks a single differ diff item whether it should trigger reconversion.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {Function}\nfunction createChangeReducerCallback( model ) {\n\treturn ( node, change ) => {\n\t\tif ( !node.is( 'element', model.name ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( change.type == 'attribute' ) {\n\t\t\tif ( model.attributes.includes( change.attributeKey ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. */\n\t\t\tif ( model.children ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t};\n}\n\n// Creates a `reduceChanges` event handler for reconversion.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {Function}\nfunction createChangeReducer( model ) {\n\tconst shouldReplace = createChangeReducerCallback( model );\n\n\treturn ( evt, data ) => {\n\t\tconst reducedChanges = [];\n\n\t\tif ( !data.reconvertedElements ) {\n\t\t\tdata.reconvertedElements = new Set();\n\t\t}\n\n\t\tfor ( const change of data.changes ) {\n\t\t\t// For attribute use node affected by the change.\n\t\t\t// For insert or remove use parent element because we need to check if it's added/removed child.\n\t\t\tconst node = change.position ? change.position.parent : change.range.start.nodeAfter;\n\n\t\t\tif ( !node || !shouldReplace( node, change ) ) {\n\t\t\t\treducedChanges.push( change );\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If it's already marked for reconversion, so skip this change, otherwise add the diff items.\n\t\t\tif ( !data.reconvertedElements.has( node ) ) {\n\t\t\t\tdata.reconvertedElements.add( node );\n\n\t\t\t\tconst position = ModelPosition._createBefore( node );\n\n\t\t\t\treducedChanges.push( {\n\t\t\t\t\ttype: 'remove',\n\t\t\t\t\tname: node.name,\n\t\t\t\t\tposition,\n\t\t\t\t\tlength: 1\n\t\t\t\t}, {\n\t\t\t\t\ttype: 'reinsert',\n\t\t\t\t\tname: node.name,\n\t\t\t\t\tposition,\n\t\t\t\t\tlength: 1\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tdata.changes = reducedChanges;\n\t};\n}\n\n// Creates a function that checks if an element and its watched attributes can be consumed and consumes them.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {module:engine/conversion/downcasthelpers~ConsumerFunction}\nfunction createConsumer( model ) {\n\treturn ( node, consumable, options = {} ) => {\n\t\tconst events = [ 'insert' ];\n\n\t\t// Collect all set attributes that are triggering conversion.\n\t\tfor ( const attributeName of model.attributes ) {\n\t\t\tif ( node.hasAttribute( attributeName ) ) {\n\t\t\t\tevents.push( `attribute:${ attributeName }` );\n\t\t\t}\n\t\t}\n\n\t\tif ( !events.every( event => consumable.test( node, event ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !options.preflight ) {\n\t\t\tevents.forEach( event => consumable.consume( node, event ) );\n\t\t}\n\n\t\treturn true;\n\t};\n}\n\n// Creates a function that create view slots.\n//\n// @param {module:engine/model/element~Element} element\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {Function} Exposed by writer as createSlot().\nfunction createSlotFactory( element, slotsMap, conversionApi ) {\n\treturn ( writer, modeOrFilter = 'children' ) => {\n\t\tconst slot = writer.createContainerElement( '$slot' );\n\n\t\tlet children = null;\n\n\t\tif ( modeOrFilter === 'children' ) {\n\t\t\tchildren = Array.from( element.getChildren() );\n\t\t} else if ( typeof modeOrFilter == 'function' ) {\n\t\t\tchildren = Array.from( element.getChildren() ).filter( element => modeOrFilter( element ) );\n\t\t} else {\n\t\t\t/**\n\t\t\t * Unknown slot mode was provided to `writer.createSlot()` in downcast converter.\n\t\t\t *\n\t\t\t * @error conversion-slot-mode-unknown\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-slot-mode-unknown', conversionApi.dispatcher, { modeOrFilter } );\n\t\t}\n\n\t\tslotsMap.set( slot, children );\n\n\t\treturn slot;\n\t};\n}\n\n// Checks if all children are covered by slots and there is no child that landed in multiple slots.\n//\n// @param {module:engine/model/element~Element}\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction validateSlotsChildren( element, slotsMap, conversionApi ) {\n\tconst childrenInSlots = Array.from( slotsMap.values() ).flat();\n\tconst uniqueChildrenInSlots = new Set( childrenInSlots );\n\n\tif ( uniqueChildrenInSlots.size != childrenInSlots.length ) {\n\t\t/**\n\t\t * Filters provided to `writer.createSlot()` overlap (at least two filters accept the same child element).\n\t\t *\n\t\t * @error conversion-slot-filter-overlap\n\t\t * @param {module:engine/model/element~Element} element The element of which children would not be properly\n\t\t * allocated to multiple slots.\n\t\t */\n\t\tthrow new CKEditorError( 'conversion-slot-filter-overlap', conversionApi.dispatcher, { element } );\n\t}\n\n\tif ( uniqueChildrenInSlots.size != element.childCount ) {\n\t\t/**\n\t\t * Filters provided to `writer.createSlot()` are incomplete and exclude at least one children element (one of\n\t\t * the children elements would not be assigned to any of the slots).\n\t\t *\n\t\t * @error conversion-slot-filter-incomplete\n\t\t * @param {module:engine/model/element~Element} element The element of which children would not be properly\n\t\t * allocated to multiple slots.\n\t\t */\n\t\tthrow new CKEditorError( 'conversion-slot-filter-incomplete', conversionApi.dispatcher, { element } );\n\t}\n}\n\n// Fill slots with appropriate view elements.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\nfunction fillSlots( viewElement, slotsMap, conversionApi, options ) {\n\t// Set temporary position mapping to redirect child view elements into a proper slots.\n\tconversionApi.mapper.on( 'modelToViewPosition', toViewPositionMapping, { priority: 'highest' } );\n\n\tlet currentSlot = null;\n\tlet currentSlotNodes = null;\n\n\t// Fill slots with nested view nodes.\n\tfor ( [ currentSlot, currentSlotNodes ] of slotsMap ) {\n\t\treinsertOrConvertNodes( viewElement, currentSlotNodes, conversionApi, options );\n\n\t\tconversionApi.writer.move(\n\t\t\tconversionApi.writer.createRangeIn( currentSlot ),\n\t\t\tconversionApi.writer.createPositionBefore( currentSlot )\n\t\t);\n\t\tconversionApi.writer.remove( currentSlot );\n\t}\n\n\tconversionApi.mapper.off( 'modelToViewPosition', toViewPositionMapping );\n\n\tfunction toViewPositionMapping( evt, data ) {\n\t\tconst element = data.modelPosition.nodeAfter;\n\n\t\t// Find the proper offset within the slot.\n\t\tconst index = currentSlotNodes.indexOf( element );\n\n\t\tif ( index < 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdata.viewPosition = data.mapper.findPositionIn( currentSlot, index );\n\t}\n}\n\n// Inserts view representation of `nodes` into the `viewElement` either by bringing back just removed view nodes\n// or by triggering conversion for them.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {Iterable.<module:engine/model/element~Element>} modelNodes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\nfunction reinsertOrConvertNodes( viewElement, modelNodes, conversionApi, options ) {\n\t// Fill with nested view nodes.\n\tfor ( const modelChildNode of modelNodes ) {\n\t\t// Try reinserting the view node for the specified model node...\n\t\tif ( !reinsertNode( viewElement.root, modelChildNode, conversionApi, options ) ) {\n\t\t\t// ...or else convert the model element to the view.\n\t\t\tconversionApi.convertItem( modelChildNode );\n\t\t}\n\t}\n}\n\n// Checks if the view for the given model element could be reused and reinserts it to the view.\n//\n// @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewRoot\n// @param {module:engine/model/element~Element} modelElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\n// @returns {Boolean} `false` if view element can't be reused.\nfunction reinsertNode( viewRoot, modelElement, conversionApi, options ) {\n\tconst { writer, mapper } = conversionApi;\n\n\t// Don't reinsert if this is not a reconversion...\n\tif ( !options.reconversion ) {\n\t\treturn false;\n\t}\n\n\tconst viewChildNode = mapper.toViewElement( modelElement );\n\n\t// ...or there is no view to reinsert or it was already inserted to the view structure...\n\tif ( !viewChildNode || viewChildNode.root == viewRoot ) {\n\t\treturn false;\n\t}\n\n\t// ...or it was strictly marked as not to be reused.\n\tif ( !conversionApi.canReuseView( viewChildNode ) ) {\n\t\treturn false;\n\t}\n\n\t// Otherwise reinsert the view node.\n\twriter.move(\n\t\twriter.createRangeOn( viewChildNode ),\n\t\tmapper.toViewPosition( ModelPosition._createBefore( modelElement ) )\n\t);\n\n\treturn true;\n}\n\n// The default consumer for insert events.\n// @param {module:engine/model/item~Item} item Model item.\n// @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The model consumable.\n// @param {Object} [options]\n// @param {Boolean} [options.preflight=false] Whether should consume or just check if can be consumed.\n// @returns {Boolean}\nfunction defaultConsumer( item, consumable, { preflight } = {} ) {\n\tif ( preflight ) {\n\t\treturn consumable.test( item, 'insert' );\n\t} else {\n\t\treturn consumable.consume( item, 'insert' );\n\t}\n}\n\n/**\n * An object describing how the marker highlight should be represented in the view.\n *\n * Each text node contained in a highlighted range will be wrapped in a `<span>`\n * {@link module:engine/view/attributeelement~AttributeElement view attribute element} with CSS class(es), attributes and a priority\n * described by this object.\n *\n * Additionally, each {@link module:engine/view/containerelement~ContainerElement container element} can handle displaying the highlight\n * separately by providing the `addHighlight` and `removeHighlight` custom properties. In this case:\n *\n *  * The `HighlightDescriptor` object is passed to the `addHighlight` function upon conversion and should be used to apply the highlight to\n *  the element.\n *  * The descriptor `id` is passed to the `removeHighlight` function upon conversion and should be used to remove the highlight with the\n *  given ID from the element.\n *\n * @typedef {Object} module:engine/conversion/downcasthelpers~HighlightDescriptor\n *\n * @property {String|Array.<String>} classes A CSS class or an array of classes to set. If the descriptor is used to\n * create an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these classes will be set\n * on that attribute element. If the descriptor is applied to an element, usually these classes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n *\n * @property {String} [id] Descriptor identifier. If not provided, it defaults to the converted marker's name.\n *\n * @property {Number} [priority] Descriptor priority. If not provided, it defaults to `10`. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element}, it will be that element's\n * {@link module:engine/view/attributeelement~AttributeElement#priority priority}. If the descriptor is applied to an element,\n * the priority will be used to determine which descriptor is more important.\n *\n * @property {Object} [attributes] Attributes to set. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these attributes will be set on that\n * attribute element. If the descriptor is applied to an element, usually these attributes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n */\n\n/**\n * A filtering function used to choose model child nodes to be downcasted into the specific view\n * {@link module:engine/view/downcastwriter~DowncastWriter#createSlot \"slot\"} while executing the\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`} converter.\n *\n * @callback module:engine/conversion/downcasthelpers~SlotFilter\n *\n * @param {module:engine/model/node~Node} node A model node.\n * @returns {Boolean} Whether the provided model node should be downcasted into this slot.\n *\n * @see module:engine/view/downcastwriter~DowncastWriter#createSlot\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n * @see module:engine/conversion/downcasthelpers~insertStructure\n */\n\n/**\n * A view element creator function that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi\n * downcast conversion API} as parameters and returns a view container element.\n *\n * @callback module:engine/conversion/downcasthelpers~ElementCreatorFunction\n * @param {module:engine/model/element~Element} element The model element to be converted to the view structure.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} event).\n * @param {module:engine/model/item~Item} data.item Inserted item.\n * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n * @returns {module:engine/view/element~Element} The view element.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement\n * @see module:engine/conversion/downcasthelpers~insertElement\n */\n\n/**\n * A function that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast\n * conversion API} as parameters and returns a view container element with slots for model child nodes to be converted into.\n *\n * @callback module:engine/conversion/downcasthelpers~StructureCreatorFunction\n * @param {module:engine/model/element~Element} element The model element to be converted to the view structure.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} event).\n * @param {module:engine/model/item~Item} data.item Inserted item.\n * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n * @returns {module:engine/view/element~Element} The view structure with slots for model child nodes.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n * @see module:engine/conversion/downcasthelpers~insertStructure\n */\n\n/**\n * A view element creator function that takes the model attribute value and\n * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view\n * attribute element.\n *\n * @callback module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction\n * @param {*} attributeValue The model attribute value to be converted to the view attribute element.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} event).\n * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n * or converted selection.\n * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n * @param {String} data.attributeKey Attribute key.\n * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n * @param {*} data.attributeNewValue New attribute value.\n * @returns {module:engine/view/attributeelement~AttributeElement} The view attribute element.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement\n * @see module:engine/conversion/downcasthelpers~wrap\n */\n\n/**\n * A function that takes the model attribute value and\n * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n * as parameters.\n *\n * @callback module:engine/conversion/downcasthelpers~AttributeCreatorFunction\n * @param {*} attributeValue The model attribute value to be converted to the view attribute element.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} event).\n * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n * or converted selection.\n * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n * @param {String} data.attributeKey Attribute key.\n * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n * @param {*} data.attributeNewValue New attribute value.\n * @returns {Object|null} A `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n * array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute\n */\n\n/**\n * A function that is expected to consume all the consumables that were used by the element creator.\n *\n * @callback module:engine/conversion/downcasthelpers~ConsumerFunction\n * @param {module:engine/model/element~Element} element The model element to be converted to the view structure.\n * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The `ModelConsumable` same as in\n * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#consumable `DowncastConversionApi.consumable`}.\n * @param {Object} [options]\n * @param {Boolean} [options.preflight=false] Whether should consume or just check if can be consumed.\n * @returns {Boolean} `true` if all consumable values were available and were consumed, `false` otherwise.\n *\n * @see module:engine/conversion/downcasthelpers~insertStructure\n */\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA,OAAOA,UAAP,MAAuB,gBAAvB;AACA,OAAOC,cAAP,MAA2B,oBAA3B;AACA,OAAOC,YAAP,MAAyB,kBAAzB;AACA,OAAOC,aAAP,MAA0B,mBAA1B;AAEA,OAAOC,oBAAP,MAAiC,0BAAjC;AACA,OAAOC,iBAAP,MAA8B,4BAA9B;AACA,OAAOC,iBAAP,MAA8B,qBAA9B;AAEA,SAASC,SAAT,QAA0B,WAA1B;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,OAAP,MAAoB,uCAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,eAAN,SAA8BJ,iBAA9B,CAAgD;EAC9D;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCK,gBAAgB,CAAEC,MAAF,EAAW;IAC1B,OAAO,KAAKC,GAAL,CAAUC,wBAAwB,CAAEF,MAAF,CAAlC,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCG,kBAAkB,CAAEH,MAAF,EAAW;IAC5B,OAAO,KAAKC,GAAL,CAAUG,0BAA0B,CAAEJ,MAAF,CAApC,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCK,kBAAkB,CAAEL,MAAF,EAAW;IAC5B,OAAO,KAAKC,GAAL,CAAUK,0BAA0B,CAAEN,MAAF,CAApC,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCO,oBAAoB,CAAEP,MAAF,EAAW;IAC9B,OAAO,KAAKC,GAAL,CAAUO,4BAA4B,CAAER,MAAF,CAAtC,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCS,eAAe,CAAET,MAAF,EAAW;IACzB,OAAO,KAAKC,GAAL,CAAUS,uBAAuB,CAAEV,MAAF,CAAjC,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCW,iBAAiB,CAAEX,MAAF,EAAW;IAC3B,OAAO,KAAKC,GAAL,CAAUW,yBAAyB,CAAEZ,MAAF,CAAnC,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCa,YAAY,CAAEb,MAAF,EAAW;IACtB,OAAO,KAAKC,GAAL,CAAUa,oBAAoB,CAAEd,MAAF,CAA9B,CAAP;EACA;;AAprB6D;AAurB/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASe,UAAT,GAAsB;EAC5B,OAAO,CAAEC,GAAF,EAAOC,IAAP,EAAaC,aAAb,KAAgC;IACtC,IAAK,CAACA,aAAa,CAACC,UAAd,CAAyBC,OAAzB,CAAkCH,IAAI,CAACI,IAAvC,EAA6CL,GAAG,CAACM,IAAjD,CAAN,EAAgE;MAC/D;IACA;;IAED,MAAMC,UAAU,GAAGL,aAAa,CAACM,MAAjC;IACA,MAAMC,YAAY,GAAGP,aAAa,CAACQ,MAAd,CAAqBC,cAArB,CAAqCV,IAAI,CAACW,KAAL,CAAWC,KAAhD,CAArB;IACA,MAAMC,QAAQ,GAAGP,UAAU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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}