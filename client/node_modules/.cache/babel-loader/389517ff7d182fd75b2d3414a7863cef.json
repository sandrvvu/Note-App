{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/modelconsumable\n */\nimport TextProxy from '../model/textproxy';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Manages a list of consumable values for the {@link module:engine/model/item~Item model items}.\n *\n * Consumables are various aspects of the model. A model item can be broken down into separate, single properties that might be\n * taken into consideration when converting that item.\n *\n * `ModelConsumable` is used by {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} while analyzing the changed\n * parts of {@link module:engine/model/document~Document the document}. The added / changed / removed model items are broken down\n * into singular properties (the item itself and its attributes). All those parts are saved in `ModelConsumable`. Then,\n * during conversion, when the given part of a model item is converted (i.e. the view element has been inserted into the view,\n * but without attributes), the consumable value is removed from `ModelConsumable`.\n *\n * For model items, `ModelConsumable` stores consumable values of one of following types: `insert`, `addattribute:<attributeKey>`,\n * `changeattributes:<attributeKey>`, `removeattributes:<attributeKey>`.\n *\n * In most cases, it is enough to let th {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * gather consumable values, so there is no need to use\n * the {@link module:engine/conversion/modelconsumable~ModelConsumable#add add method} directly.\n * However, it is important to understand how consumable values can be\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n * See {@link module:engine/conversion/downcasthelpers default downcast converters} for more information.\n *\n * Keep in mind that one conversion event may have multiple callbacks (converters) attached to it. Each of those is\n * able to convert one or more parts of the model. However, when one of those callbacks actually converts\n * something, the others should not, because they would duplicate the results. Using `ModelConsumable` helps to avoid\n * this situation, because callbacks should only convert these values that were not yet consumed from `ModelConsumable`.\n *\n * Consuming multiple values in a single callback:\n *\n *\t\t// Converter for custom `imageBlock` element that might have a `caption` element inside which changes\n *\t\t// how the image is displayed in the view:\n *\t\t//\n *\t\t// Model:\n *\t\t//\n *\t\t// [imageBlock]\n *\t\t//   └─ [caption]\n *\t\t//       └─ foo\n *\t\t//\n *\t\t// View:\n *\t\t//\n *\t\t// <figure>\n *\t\t//   ├─ <img />\n *\t\t//   └─ <caption>\n *\t\t//       └─ foo\n *\t\tmodelConversionDispatcher.on( 'insert:imageBlock', ( evt, data, conversionApi ) => {\n *\t\t\t// First, consume the `imageBlock` element.\n *\t\t\tconversionApi.consumable.consume( data.item, 'insert' );\n *\n *\t\t\t// Just create normal image element for the view.\n *\t\t\t// Maybe it will be \"decorated\" later.\n *\t\t\tconst viewImage = new ViewElement( 'img' );\n *\t\t\tconst insertPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\t\t\tconst viewWriter = conversionApi.writer;\n *\n *\t\t\t// Check if the `imageBlock` element has children.\n *\t\t\tif ( data.item.childCount > 0 ) {\n *\t\t\t\tconst modelCaption = data.item.getChild( 0 );\n *\n *\t\t\t\t// `modelCaption` insertion change is consumed from consumable values.\n *\t\t\t\t// It will not be converted by other converters, but it's children (probably some text) will be.\n *\t\t\t\t// Through mapping, converters for text will know where to insert contents of `modelCaption`.\n *\t\t\t\tif ( conversionApi.consumable.consume( modelCaption, 'insert' ) ) {\n *\t\t\t\t\tconst viewCaption = new ViewElement( 'figcaption' );\n *\n *\t\t\t\t\tconst viewImageHolder = new ViewElement( 'figure', null, [ viewImage, viewCaption ] );\n *\n *\t\t\t\t\tconversionApi.mapper.bindElements( modelCaption, viewCaption );\n *\t\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImageHolder );\n *\t\t\t\t\tviewWriter.insert( insertPosition, viewImageHolder );\n *\t\t\t\t}\n *\t\t\t} else {\n *\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImage );\n *\t\t\t\tviewWriter.insert( insertPosition, viewImage );\n *\t\t\t}\n *\n *\t\t\tevt.stop();\n *\t\t} );\n */\n\nexport default class ModelConsumable {\n  /**\n   * Creates an empty consumables list.\n   */\n  constructor() {\n    /**\n     * Contains list of consumable values.\n     *\n     * @private\n     * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_consumable\n     */\n    this._consumable = new Map();\n    /**\n     * For each {@link module:engine/model/textproxy~TextProxy} added to `ModelConsumable`, this registry holds a parent\n     * of that `TextProxy` and the start and end indices of that `TextProxy`. This allows identification of the `TextProxy`\n     * instances that point to the same part of the model but are different instances. Each distinct `TextProxy`\n     * is given a unique `Symbol` which is then registered as consumable. This process is transparent for the `ModelConsumable`\n     * API user because whenever `TextProxy` is added, tested, consumed or reverted, the internal mechanisms of\n     * `ModelConsumable` translate `TextProxy` to that unique `Symbol`.\n     *\n     * @private\n     * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_textProxyRegistry\n     */\n\n    this._textProxyRegistry = new Map();\n  }\n  /**\n   * Adds a consumable value to the consumables list and links it with a given model item.\n   *\n   *\t\tmodelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.\n   *\t\tmodelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.\n   *\t\tmodelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.\n   *\t\tmodelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.\n   *\t\tmodelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n   * Model item, range or selection that has the consumable.\n   * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n   * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n   */\n\n\n  add(item, type) {\n    type = _normalizeConsumableType(type);\n\n    if (item instanceof TextProxy) {\n      item = this._getSymbolForTextProxy(item);\n    }\n\n    if (!this._consumable.has(item)) {\n      this._consumable.set(item, new Map());\n    }\n\n    this._consumable.get(item).set(type, true);\n  }\n  /**\n   * Removes a given consumable value from a given model item.\n   *\n   *\t\tmodelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.\n   *\t\tmodelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.\n   *\t\tmodelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.\n   *\t\tmodelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.\n   *\t\tmodelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n   * Model item, range or selection from which consumable will be consumed.\n   * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n   * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n   * @returns {Boolean} `true` if consumable value was available and was consumed, `false` otherwise.\n   */\n\n\n  consume(item, type) {\n    type = _normalizeConsumableType(type);\n\n    if (item instanceof TextProxy) {\n      item = this._getSymbolForTextProxy(item);\n    }\n\n    if (this.test(item, type)) {\n      this._consumable.get(item).set(type, false);\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Tests whether there is a consumable value of a given type connected with a given model item.\n   *\n   *\t\tmodelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.\n   *\t\tmodelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.\n   *\t\tmodelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.\n   *\t\tmodelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.\n   *\t\tmodelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n   * Model item, range or selection to be tested.\n   * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n   * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n   * @returns {null|Boolean} `null` if such consumable was never added, `false` if the consumable values was\n   * already consumed or `true` if it was added and not consumed yet.\n   */\n\n\n  test(item, type) {\n    type = _normalizeConsumableType(type);\n\n    if (item instanceof TextProxy) {\n      item = this._getSymbolForTextProxy(item);\n    }\n\n    const itemConsumables = this._consumable.get(item);\n\n    if (itemConsumables === undefined) {\n      return null;\n    }\n\n    const value = itemConsumables.get(type);\n\n    if (value === undefined) {\n      return null;\n    }\n\n    return value;\n  }\n  /**\n   * Reverts consuming of a consumable value.\n   *\n   *\t\tmodelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.\n   *\t\tmodelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.\n   *\t\tmodelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.\n   *\t\tmodelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.\n   *\t\tmodelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n   * Model item, range or selection to be reverted.\n   * @param {String} type Consumable type.\n   * @returns {null|Boolean} `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has\n   * never been added.\n   */\n\n\n  revert(item, type) {\n    type = _normalizeConsumableType(type);\n\n    if (item instanceof TextProxy) {\n      item = this._getSymbolForTextProxy(item);\n    }\n\n    const test = this.test(item, type);\n\n    if (test === false) {\n      this._consumable.get(item).set(type, true);\n\n      return true;\n    } else if (test === true) {\n      return false;\n    }\n\n    return null;\n  }\n  /**\n   * Verifies if all events from the specified group were consumed.\n   *\n   * @param {String} eventGroup The events group to verify.\n   */\n\n\n  verifyAllConsumed(eventGroup) {\n    const items = [];\n\n    for (const [item, consumables] of this._consumable) {\n      for (const [event, canConsume] of consumables) {\n        const eventPrefix = event.split(':')[0];\n\n        if (canConsume && eventGroup == eventPrefix) {\n          items.push({\n            event,\n            item: item.name || item.description\n          });\n        }\n      }\n    }\n\n    if (items.length) {\n      /**\n       * Some of the {@link module:engine/model/item~Item model items} were not consumed while downcasting the model to view.\n       *\n       * This might be the effect of:\n       *\n       * * A missing converter for some model elements. Make sure that you registered downcast converters for all model elements.\n       * * A custom converter that does not consume converted items. Make sure that you\n       * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} all model elements that you converted\n       * from the model to the view.\n       * * A custom converter that called `event.stop()`. When providing a custom converter, keep in mind that you should not stop\n       * the event. If you stop it then the default converter at the `lowest` priority will not trigger the conversion of this node's\n       * attributes and child nodes.\n       *\n       * @error conversion-model-consumable-not-consumed\n       * @param {Array.<module:engine/model/item~Item>} items Items that were not consumed.\n       */\n      throw new CKEditorError('conversion-model-consumable-not-consumed', null, {\n        items\n      });\n    }\n  }\n  /**\n   * Gets a unique symbol for the passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that\n   * have same parent, same start index and same end index will get the same symbol.\n   *\n   * Used internally to correctly consume `TextProxy` instances.\n   *\n   * @protected\n   * @param {module:engine/model/textproxy~TextProxy} textProxy `TextProxy` instance to get a symbol for.\n   * @returns {Symbol} Symbol representing all equal instances of `TextProxy`.\n   */\n\n\n  _getSymbolForTextProxy(textProxy) {\n    let symbol = null;\n\n    const startMap = this._textProxyRegistry.get(textProxy.startOffset);\n\n    if (startMap) {\n      const endMap = startMap.get(textProxy.endOffset);\n\n      if (endMap) {\n        symbol = endMap.get(textProxy.parent);\n      }\n    }\n\n    if (!symbol) {\n      symbol = this._addSymbolForTextProxy(textProxy);\n    }\n\n    return symbol;\n  }\n  /**\n   * Adds a symbol for the given {@link module:engine/model/textproxy~TextProxy} instance.\n   *\n   * Used internally to correctly consume `TextProxy` instances.\n   *\n   * @private\n   * @param {module:engine/model/textproxy~TextProxy} textProxy Text proxy instance.\n   * @returns {Symbol} Symbol generated for given `TextProxy`.\n   */\n\n\n  _addSymbolForTextProxy(textProxy) {\n    const start = textProxy.startOffset;\n    const end = textProxy.endOffset;\n    const parent = textProxy.parent;\n    const symbol = Symbol('$textProxy:' + textProxy.data);\n    let startMap, endMap;\n    startMap = this._textProxyRegistry.get(start);\n\n    if (!startMap) {\n      startMap = new Map();\n\n      this._textProxyRegistry.set(start, startMap);\n    }\n\n    endMap = startMap.get(end);\n\n    if (!endMap) {\n      endMap = new Map();\n      startMap.set(end, endMap);\n    }\n\n    endMap.set(parent, symbol);\n    return symbol;\n  }\n\n} // Returns a normalized consumable type name from the given string. A normalized consumable type name is a string that has\n// at most one colon, for example: `insert` or `addMarker:highlight`. If a string to normalize has more \"parts\" (more colons),\n// the further parts are dropped, for example: `addattribute:bold:$text` -> `addattributes:bold`.\n//\n// @param {String} type Consumable type.\n// @returns {String} Normalized consumable type.\n\nfunction _normalizeConsumableType(type) {\n  const parts = type.split(':'); // For inserts allow passing event name, it's stored in the context of a specified element so the element name is not needed.\n\n  if (parts[0] == 'insert') {\n    return parts[0];\n  } // Markers are identified by the whole name (otherwise we would consume the whole markers group).\n\n\n  if (parts[0] == 'addMarker' || parts[0] == 'removeMarker') {\n    return type;\n  }\n\n  return parts.length > 1 ? parts[0] + ':' + parts[1] : parts[0];\n}","map":{"version":3,"names":["TextProxy","CKEditorError","ModelConsumable","constructor","_consumable","Map","_textProxyRegistry","add","item","type","_normalizeConsumableType","_getSymbolForTextProxy","has","set","get","consume","test","itemConsumables","undefined","value","revert","verifyAllConsumed","eventGroup","items","consumables","event","canConsume","eventPrefix","split","push","name","description","length","textProxy","symbol","startMap","startOffset","endMap","endOffset","parent","_addSymbolForTextProxy","start","end","Symbol","data","parts"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/modelconsumable\n */\n\nimport TextProxy from '../model/textproxy';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Manages a list of consumable values for the {@link module:engine/model/item~Item model items}.\n *\n * Consumables are various aspects of the model. A model item can be broken down into separate, single properties that might be\n * taken into consideration when converting that item.\n *\n * `ModelConsumable` is used by {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} while analyzing the changed\n * parts of {@link module:engine/model/document~Document the document}. The added / changed / removed model items are broken down\n * into singular properties (the item itself and its attributes). All those parts are saved in `ModelConsumable`. Then,\n * during conversion, when the given part of a model item is converted (i.e. the view element has been inserted into the view,\n * but without attributes), the consumable value is removed from `ModelConsumable`.\n *\n * For model items, `ModelConsumable` stores consumable values of one of following types: `insert`, `addattribute:<attributeKey>`,\n * `changeattributes:<attributeKey>`, `removeattributes:<attributeKey>`.\n *\n * In most cases, it is enough to let th {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * gather consumable values, so there is no need to use\n * the {@link module:engine/conversion/modelconsumable~ModelConsumable#add add method} directly.\n * However, it is important to understand how consumable values can be\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n * See {@link module:engine/conversion/downcasthelpers default downcast converters} for more information.\n *\n * Keep in mind that one conversion event may have multiple callbacks (converters) attached to it. Each of those is\n * able to convert one or more parts of the model. However, when one of those callbacks actually converts\n * something, the others should not, because they would duplicate the results. Using `ModelConsumable` helps to avoid\n * this situation, because callbacks should only convert these values that were not yet consumed from `ModelConsumable`.\n *\n * Consuming multiple values in a single callback:\n *\n *\t\t// Converter for custom `imageBlock` element that might have a `caption` element inside which changes\n *\t\t// how the image is displayed in the view:\n *\t\t//\n *\t\t// Model:\n *\t\t//\n *\t\t// [imageBlock]\n *\t\t//   └─ [caption]\n *\t\t//       └─ foo\n *\t\t//\n *\t\t// View:\n *\t\t//\n *\t\t// <figure>\n *\t\t//   ├─ <img />\n *\t\t//   └─ <caption>\n *\t\t//       └─ foo\n *\t\tmodelConversionDispatcher.on( 'insert:imageBlock', ( evt, data, conversionApi ) => {\n *\t\t\t// First, consume the `imageBlock` element.\n *\t\t\tconversionApi.consumable.consume( data.item, 'insert' );\n *\n *\t\t\t// Just create normal image element for the view.\n *\t\t\t// Maybe it will be \"decorated\" later.\n *\t\t\tconst viewImage = new ViewElement( 'img' );\n *\t\t\tconst insertPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\t\t\tconst viewWriter = conversionApi.writer;\n *\n *\t\t\t// Check if the `imageBlock` element has children.\n *\t\t\tif ( data.item.childCount > 0 ) {\n *\t\t\t\tconst modelCaption = data.item.getChild( 0 );\n *\n *\t\t\t\t// `modelCaption` insertion change is consumed from consumable values.\n *\t\t\t\t// It will not be converted by other converters, but it's children (probably some text) will be.\n *\t\t\t\t// Through mapping, converters for text will know where to insert contents of `modelCaption`.\n *\t\t\t\tif ( conversionApi.consumable.consume( modelCaption, 'insert' ) ) {\n *\t\t\t\t\tconst viewCaption = new ViewElement( 'figcaption' );\n *\n *\t\t\t\t\tconst viewImageHolder = new ViewElement( 'figure', null, [ viewImage, viewCaption ] );\n *\n *\t\t\t\t\tconversionApi.mapper.bindElements( modelCaption, viewCaption );\n *\t\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImageHolder );\n *\t\t\t\t\tviewWriter.insert( insertPosition, viewImageHolder );\n *\t\t\t\t}\n *\t\t\t} else {\n *\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImage );\n *\t\t\t\tviewWriter.insert( insertPosition, viewImage );\n *\t\t\t}\n *\n *\t\t\tevt.stop();\n *\t\t} );\n */\nexport default class ModelConsumable {\n\t/**\n\t * Creates an empty consumables list.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Contains list of consumable values.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_consumable\n\t\t */\n\t\tthis._consumable = new Map();\n\n\t\t/**\n\t\t * For each {@link module:engine/model/textproxy~TextProxy} added to `ModelConsumable`, this registry holds a parent\n\t\t * of that `TextProxy` and the start and end indices of that `TextProxy`. This allows identification of the `TextProxy`\n\t\t * instances that point to the same part of the model but are different instances. Each distinct `TextProxy`\n\t\t * is given a unique `Symbol` which is then registered as consumable. This process is transparent for the `ModelConsumable`\n\t\t * API user because whenever `TextProxy` is added, tested, consumed or reverted, the internal mechanisms of\n\t\t * `ModelConsumable` translate `TextProxy` to that unique `Symbol`.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_textProxyRegistry\n\t\t */\n\t\tthis._textProxyRegistry = new Map();\n\t}\n\n\t/**\n\t * Adds a consumable value to the consumables list and links it with a given model item.\n\t *\n\t *\t\tmodelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.\n\t *\t\tmodelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.\n\t *\t\tmodelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection that has the consumable.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t */\n\tadd( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tif ( !this._consumable.has( item ) ) {\n\t\t\tthis._consumable.set( item, new Map() );\n\t\t}\n\n\t\tthis._consumable.get( item ).set( type, true );\n\t}\n\n\t/**\n\t * Removes a given consumable value from a given model item.\n\t *\n\t *\t\tmodelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.\n\t *\t\tmodelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.\n\t *\t\tmodelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection from which consumable will be consumed.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t * @returns {Boolean} `true` if consumable value was available and was consumed, `false` otherwise.\n\t */\n\tconsume( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tif ( this.test( item, type ) ) {\n\t\t\tthis._consumable.get( item ).set( type, false );\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Tests whether there is a consumable value of a given type connected with a given model item.\n\t *\n\t *\t\tmodelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.\n\t *\t\tmodelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.\n\t *\t\tmodelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection to be tested.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t * @returns {null|Boolean} `null` if such consumable was never added, `false` if the consumable values was\n\t * already consumed or `true` if it was added and not consumed yet.\n\t */\n\ttest( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tconst itemConsumables = this._consumable.get( item );\n\n\t\tif ( itemConsumables === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst value = itemConsumables.get( type );\n\n\t\tif ( value === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * Reverts consuming of a consumable value.\n\t *\n\t *\t\tmodelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.\n\t *\t\tmodelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.\n\t *\t\tmodelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.\n\t *\t\tmodelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.\n\t *\t\tmodelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection to be reverted.\n\t * @param {String} type Consumable type.\n\t * @returns {null|Boolean} `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has\n\t * never been added.\n\t */\n\trevert( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tconst test = this.test( item, type );\n\n\t\tif ( test === false ) {\n\t\t\tthis._consumable.get( item ).set( type, true );\n\n\t\t\treturn true;\n\t\t} else if ( test === true ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Verifies if all events from the specified group were consumed.\n\t *\n\t * @param {String} eventGroup The events group to verify.\n\t */\n\tverifyAllConsumed( eventGroup ) {\n\t\tconst items = [];\n\n\t\tfor ( const [ item, consumables ] of this._consumable ) {\n\t\t\tfor ( const [ event, canConsume ] of consumables ) {\n\t\t\t\tconst eventPrefix = event.split( ':' )[ 0 ];\n\n\t\t\t\tif ( canConsume && eventGroup == eventPrefix ) {\n\t\t\t\t\titems.push( {\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\titem: item.name || item.description\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( items.length ) {\n\t\t\t/**\n\t\t\t * Some of the {@link module:engine/model/item~Item model items} were not consumed while downcasting the model to view.\n\t\t\t *\n\t\t\t * This might be the effect of:\n\t\t\t *\n\t\t\t * * A missing converter for some model elements. Make sure that you registered downcast converters for all model elements.\n\t\t\t * * A custom converter that does not consume converted items. Make sure that you\n\t\t\t * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} all model elements that you converted\n\t\t\t * from the model to the view.\n\t\t\t * * A custom converter that called `event.stop()`. When providing a custom converter, keep in mind that you should not stop\n\t\t\t * the event. If you stop it then the default converter at the `lowest` priority will not trigger the conversion of this node's\n\t\t\t * attributes and child nodes.\n\t\t\t *\n\t\t\t * @error conversion-model-consumable-not-consumed\n\t\t\t * @param {Array.<module:engine/model/item~Item>} items Items that were not consumed.\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-model-consumable-not-consumed', null, { items } );\n\t\t}\n\t}\n\n\t/**\n\t * Gets a unique symbol for the passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that\n\t * have same parent, same start index and same end index will get the same symbol.\n\t *\n\t * Used internally to correctly consume `TextProxy` instances.\n\t *\n\t * @protected\n\t * @param {module:engine/model/textproxy~TextProxy} textProxy `TextProxy` instance to get a symbol for.\n\t * @returns {Symbol} Symbol representing all equal instances of `TextProxy`.\n\t */\n\t_getSymbolForTextProxy( textProxy ) {\n\t\tlet symbol = null;\n\n\t\tconst startMap = this._textProxyRegistry.get( textProxy.startOffset );\n\n\t\tif ( startMap ) {\n\t\t\tconst endMap = startMap.get( textProxy.endOffset );\n\n\t\t\tif ( endMap ) {\n\t\t\t\tsymbol = endMap.get( textProxy.parent );\n\t\t\t}\n\t\t}\n\n\t\tif ( !symbol ) {\n\t\t\tsymbol = this._addSymbolForTextProxy( textProxy );\n\t\t}\n\n\t\treturn symbol;\n\t}\n\n\t/**\n\t * Adds a symbol for the given {@link module:engine/model/textproxy~TextProxy} instance.\n\t *\n\t * Used internally to correctly consume `TextProxy` instances.\n\t *\n\t * @private\n\t * @param {module:engine/model/textproxy~TextProxy} textProxy Text proxy instance.\n\t * @returns {Symbol} Symbol generated for given `TextProxy`.\n\t */\n\t_addSymbolForTextProxy( textProxy ) {\n\t\tconst start = textProxy.startOffset;\n\t\tconst end = textProxy.endOffset;\n\t\tconst parent = textProxy.parent;\n\n\t\tconst symbol = Symbol( '$textProxy:' + textProxy.data );\n\t\tlet startMap, endMap;\n\n\t\tstartMap = this._textProxyRegistry.get( start );\n\n\t\tif ( !startMap ) {\n\t\t\tstartMap = new Map();\n\t\t\tthis._textProxyRegistry.set( start, startMap );\n\t\t}\n\n\t\tendMap = startMap.get( end );\n\n\t\tif ( !endMap ) {\n\t\t\tendMap = new Map();\n\t\t\tstartMap.set( end, endMap );\n\t\t}\n\n\t\tendMap.set( parent, symbol );\n\n\t\treturn symbol;\n\t}\n}\n\n// Returns a normalized consumable type name from the given string. A normalized consumable type name is a string that has\n// at most one colon, for example: `insert` or `addMarker:highlight`. If a string to normalize has more \"parts\" (more colons),\n// the further parts are dropped, for example: `addattribute:bold:$text` -> `addattributes:bold`.\n//\n// @param {String} type Consumable type.\n// @returns {String} Normalized consumable type.\nfunction _normalizeConsumableType( type ) {\n\tconst parts = type.split( ':' );\n\n\t// For inserts allow passing event name, it's stored in the context of a specified element so the element name is not needed.\n\tif ( parts[ 0 ] == 'insert' ) {\n\t\treturn parts[ 0 ];\n\t}\n\n\t// Markers are identified by the whole name (otherwise we would consume the whole markers group).\n\tif ( parts[ 0 ] == 'addMarker' || parts[ 0 ] == 'removeMarker' ) {\n\t\treturn type;\n\t}\n\n\treturn parts.length > 1 ? parts[ 0 ] + ':' + parts[ 1 ] : parts[ 0 ];\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,SAAP,MAAsB,oBAAtB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,eAAN,CAAsB;EACpC;AACD;AACA;EACCC,WAAW,GAAG;IACb;AACF;AACA;AACA;AACA;AACA;IACE,KAAKC,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACE,KAAKC,kBAAL,GAA0B,IAAID,GAAJ,EAA1B;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACCE,GAAG,CAAEC,IAAF,EAAQC,IAAR,EAAe;IACjBA,IAAI,GAAGC,wBAAwB,CAAED,IAAF,CAA/B;;IAEA,IAAKD,IAAI,YAAYR,SAArB,EAAiC;MAChCQ,IAAI,GAAG,KAAKG,sBAAL,CAA6BH,IAA7B,CAAP;IACA;;IAED,IAAK,CAAC,KAAKJ,WAAL,CAAiBQ,GAAjB,CAAsBJ,IAAtB,CAAN,EAAqC;MACpC,KAAKJ,WAAL,CAAiBS,GAAjB,CAAsBL,IAAtB,EAA4B,IAAIH,GAAJ,EAA5B;IACA;;IAED,KAAKD,WAAL,CAAiBU,GAAjB,CAAsBN,IAAtB,EAA6BK,GAA7B,CAAkCJ,IAAlC,EAAwC,IAAxC;EACA;EAED;AACD;AACA;AACA;AACA;A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"},"metadata":{},"sourceType":"module"}