{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { CKEditorError } from '@ckeditor/ckeditor5-utils';\n/**\n * @module engine/model/history\n */\n\n/**\n * `History` keeps the track of all the operations applied to the {@link module:engine/model/document~Document document}.\n */\n\nexport default class History {\n  /**\n   * Creates an empty History instance.\n   */\n  constructor() {\n    /**\n     * Operations added to the history.\n     *\n     * @private\n     * @readonly\n     * @type {Array.<module:engine/model/operation/operation~Operation>}\n     */\n    this._operations = [];\n    /**\n     * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which\n     * {@link module:engine/model/operation/operation~Operation operation}.\n     *\n     * Keys of the map are \"undoing operations\", that is operations that undone some other operations. For each key, the\n     * value is an operation that has been undone by the \"undoing operation\".\n     *\n     * @private\n     * @member {Map} module:engine/model/history~History#_undoPairs\n     */\n\n    this._undoPairs = new Map();\n    /**\n     * Holds all undone operations.\n     *\n     * @private\n     * @type {Set.<module:engine/model/operation/operation~Operation>}\n     */\n\n    this._undoneOperations = new Set();\n    /**\n     * A map that allows retrieving the operations fast based on the given base version.\n     *\n     * @private\n     * @type Map.<Number,Number>\n     */\n\n    this._baseVersionToOperationIndex = new Map();\n    /**\n     * The history version.\n     *\n     * @private\n     * @type {Number}\n     */\n\n    this._version = 0;\n    /**\n     * The gap pairs kept in the <from,to> format.\n     *\n     * Anytime the `history.version` is set to a version larger than `history.version + 1`,\n     * a new <lastHistoryVersion, newHistoryVersion> entry is added to the map.\n     *\n     * @private\n     * @type Map.<number,number>\n     */\n\n    this._gaps = new Map();\n  }\n  /**\n   * The version of the last operation in the history.\n   *\n   * The history version is incremented automatically when a new operation is added to the history.\n   * Setting the version manually should be done only in rare circumstances when a gap is planned\n   * between history versions. When doing so, a gap will be created and the history will accept adding\n   * an operation with base version equal to the new history version.\n   *\n   * @type {Number}\n   */\n\n\n  get version() {\n    return this._version;\n  }\n\n  set version(version) {\n    // Store a gap if there are some operations already in the history and the\n    // new version does not increment the latest one.\n    if (this._operations.length && version > this._version + 1) {\n      this._gaps.set(this._version, version);\n    }\n\n    this._version = version;\n  }\n  /**\n   * The last history operation.\n   *\n   * @readonly\n   * @type {module:engine/model/operation/operation~Operation|undefined}\n   */\n\n\n  get lastOperation() {\n    return this._operations[this._operations.length - 1];\n  }\n  /**\n   * Adds an operation to the history and increments the history version.\n   *\n   * The operation's base version should be equal to the history version. Otherwise an error is thrown.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to add.\n   */\n\n\n  addOperation(operation) {\n    if (operation.baseVersion !== this.version) {\n      /**\n       * Only operations with matching versions can be added to the history.\n       *\n       * @error model-document-history-addoperation-incorrect-version\n       * @param {Object} errorData The operation and the current document history version.\n       */\n      throw new CKEditorError('model-document-history-addoperation-incorrect-version', this, {\n        operation,\n        historyVersion: this.version\n      });\n    }\n\n    this._operations.push(operation);\n\n    this._version++;\n\n    this._baseVersionToOperationIndex.set(operation.baseVersion, this._operations.length - 1);\n  }\n  /**\n   * Returns operations from the given range of operation base versions that were added to the history.\n   *\n   * Note that there may be gaps in operations base versions.\n   *\n   * @param {Number} [fromBaseVersion] Base version from which operations should be returned (inclusive).\n   * @param {Number} [toBaseVersion] Base version up to which operations should be returned (exclusive).\n      * @returns {Array.<module:engine/model/operation/operation~Operation>} History operations for the given range, in chronological order.\n   */\n\n\n  getOperations(fromBaseVersion) {\n    let toBaseVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.version;\n\n    // When there is no operation in the history, return an empty array.\n    // After that we can be sure that `firstOperation`, `lastOperation` are not nullish.\n    if (!this._operations.length) {\n      return [];\n    }\n\n    const firstOperation = this._operations[0];\n\n    if (fromBaseVersion === undefined) {\n      fromBaseVersion = firstOperation.baseVersion;\n    } // Change exclusive `toBaseVersion` to inclusive, so it will refer to the actual index.\n    // Thanks to that mapping from base versions to operation indexes are possible.\n\n\n    let inclusiveTo = toBaseVersion - 1; // Check if \"from\" or \"to\" point to a gap between versions.\n    // If yes, then change the incorrect position to the proper side of the gap.\n    // Thanks to it, it will be possible to get index of the operation.\n\n    for (const [gapFrom, gapTo] of this._gaps) {\n      if (fromBaseVersion > gapFrom && fromBaseVersion < gapTo) {\n        fromBaseVersion = gapTo;\n      }\n\n      if (inclusiveTo > gapFrom && inclusiveTo < gapTo) {\n        inclusiveTo = gapFrom - 1;\n      }\n    } // If the whole range is outside of the operation versions, then return an empty array.\n\n\n    if (inclusiveTo < firstOperation.baseVersion || fromBaseVersion > this.lastOperation.baseVersion) {\n      return [];\n    }\n\n    let fromIndex = this._baseVersionToOperationIndex.get(fromBaseVersion); // If the range starts before the first operation, then use the first operation as the range's start.\n\n\n    if (fromIndex === undefined) {\n      fromIndex = 0;\n    }\n\n    let toIndex = this._baseVersionToOperationIndex.get(inclusiveTo); // If the range ends after the last operation, then use the last operation as the range's end.\n\n\n    if (toIndex === undefined) {\n      toIndex = this._operations.length - 1;\n    } // Return the part of the history operations based on the calculated start index and end index.\n\n\n    return this._operations.slice(fromIndex, // The `toIndex` should be included in the returned operations, so add `1`.\n    toIndex + 1);\n  }\n  /**\n   * Returns operation from the history that bases on given `baseVersion`.\n   *\n   * @param {Number} baseVersion Base version of the operation to get.\n   * @returns {module:engine/model/operation/operation~Operation|undefined} Operation with given base version or `undefined` if\n   * there is no such operation in history.\n   */\n\n\n  getOperation(baseVersion) {\n    const operationIndex = this._baseVersionToOperationIndex.get(baseVersion);\n\n    if (operationIndex === undefined) {\n      return;\n    }\n\n    return this._operations[operationIndex];\n  }\n  /**\n   * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,\n   * history is keeping more context information about operations, which helps in operational transformation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} undoneOperation Operation which is undone by `undoingOperation`.\n   * @param {module:engine/model/operation/operation~Operation} undoingOperation Operation which undoes `undoneOperation`.\n   */\n\n\n  setOperationAsUndone(undoneOperation, undoingOperation) {\n    this._undoPairs.set(undoingOperation, undoneOperation);\n\n    this._undoneOperations.add(undoneOperation);\n  }\n  /**\n   * Checks whether given `operation` is undoing any other operation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n   * @returns {Boolean} `true` if given `operation` is undoing any other operation, `false` otherwise.\n   */\n\n\n  isUndoingOperation(operation) {\n    return this._undoPairs.has(operation);\n  }\n  /**\n   * Checks whether given `operation` has been undone by any other operation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n   * @returns {Boolean} `true` if given `operation` has been undone any other operation, `false` otherwise.\n   */\n\n\n  isUndoneOperation(operation) {\n    return this._undoneOperations.has(operation);\n  }\n  /**\n   * For given `undoingOperation`, returns the operation which has been undone by it.\n   *\n   * @param {module:engine/model/operation/operation~Operation} undoingOperation\n   * @returns {module:engine/model/operation/operation~Operation|undefined} Operation that has been undone by given\n   * `undoingOperation` or `undefined` if given `undoingOperation` is not undoing any other operation.\n   */\n\n\n  getUndoneOperation(undoingOperation) {\n    return this._undoPairs.get(undoingOperation);\n  }\n  /**\n   * Resets the history of operations.\n   */\n\n\n  reset() {\n    this._version = 0;\n    this._undoPairs = new Map();\n    this._operations = [];\n    this._undoneOperations = new Set();\n    this._gaps = new Map();\n    this._baseVersionToOperationIndex = new Map();\n  }\n\n}","map":{"version":3,"names":["CKEditorError","History","constructor","_operations","_undoPairs","Map","_undoneOperations","Set","_baseVersionToOperationIndex","_version","_gaps","version","length","set","lastOperation","addOperation","operation","baseVersion","historyVersion","push","getOperations","fromBaseVersion","toBaseVersion","firstOperation","undefined","inclusiveTo","gapFrom","gapTo","fromIndex","get","toIndex","slice","getOperation","operationIndex","setOperationAsUndone","undoneOperation","undoingOperation","add","isUndoingOperation","has","isUndoneOperation","getUndoneOperation","reset"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/model/history.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport { CKEditorError } from '@ckeditor/ckeditor5-utils';\n\n/**\n * @module engine/model/history\n */\n\n/**\n * `History` keeps the track of all the operations applied to the {@link module:engine/model/document~Document document}.\n */\nexport default class History {\n\t/**\n\t * Creates an empty History instance.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Operations added to the history.\n\t\t *\n\t\t * @private\n\t\t * @readonly\n\t\t * @type {Array.<module:engine/model/operation/operation~Operation>}\n\t\t */\n\t\tthis._operations = [];\n\n\t\t/**\n\t\t * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which\n\t\t * {@link module:engine/model/operation/operation~Operation operation}.\n\t\t *\n\t\t * Keys of the map are \"undoing operations\", that is operations that undone some other operations. For each key, the\n\t\t * value is an operation that has been undone by the \"undoing operation\".\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/model/history~History#_undoPairs\n\t\t */\n\t\tthis._undoPairs = new Map();\n\n\t\t/**\n\t\t * Holds all undone operations.\n\t\t *\n\t\t * @private\n\t\t * @type {Set.<module:engine/model/operation/operation~Operation>}\n\t\t */\n\t\tthis._undoneOperations = new Set();\n\n\t\t/**\n\t\t * A map that allows retrieving the operations fast based on the given base version.\n\t\t *\n\t\t * @private\n\t\t * @type Map.<Number,Number>\n\t\t */\n\t\tthis._baseVersionToOperationIndex = new Map();\n\n\t\t/**\n\t\t * The history version.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t */\n\t\tthis._version = 0;\n\n\t\t/**\n\t\t * The gap pairs kept in the <from,to> format.\n\t\t *\n\t\t * Anytime the `history.version` is set to a version larger than `history.version + 1`,\n\t\t * a new <lastHistoryVersion, newHistoryVersion> entry is added to the map.\n\t\t *\n\t\t * @private\n\t\t * @type Map.<number,number>\n\t\t */\n\t\tthis._gaps = new Map();\n\t}\n\n\t/**\n\t * The version of the last operation in the history.\n\t *\n\t * The history version is incremented automatically when a new operation is added to the history.\n\t * Setting the version manually should be done only in rare circumstances when a gap is planned\n\t * between history versions. When doing so, a gap will be created and the history will accept adding\n\t * an operation with base version equal to the new history version.\n\t *\n\t * @type {Number}\n\t */\n\tget version() {\n\t\treturn this._version;\n\t}\n\n\tset version( version ) {\n\t\t// Store a gap if there are some operations already in the history and the\n\t\t// new version does not increment the latest one.\n\t\tif ( this._operations.length && version > this._version + 1 ) {\n\t\t\tthis._gaps.set( this._version, version );\n\t\t}\n\n\t\tthis._version = version;\n\t}\n\n\t/**\n\t * The last history operation.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/operation/operation~Operation|undefined}\n\t */\n\tget lastOperation() {\n\t\treturn this._operations[ this._operations.length - 1 ];\n\t}\n\n\t/**\n\t * Adds an operation to the history and increments the history version.\n\t *\n\t * The operation's base version should be equal to the history version. Otherwise an error is thrown.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to add.\n\t */\n\taddOperation( operation ) {\n\t\tif ( operation.baseVersion !== this.version ) {\n\t\t\t/**\n\t\t\t * Only operations with matching versions can be added to the history.\n\t\t\t *\n\t\t\t * @error model-document-history-addoperation-incorrect-version\n\t\t\t * @param {Object} errorData The operation and the current document history version.\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-document-history-addoperation-incorrect-version', this, {\n\t\t\t\toperation,\n\t\t\t\thistoryVersion: this.version\n\t\t\t} );\n\t\t}\n\n\t\tthis._operations.push( operation );\n\t\tthis._version++;\n\n\t\tthis._baseVersionToOperationIndex.set( operation.baseVersion, this._operations.length - 1 );\n\t}\n\n\t/**\n\t * Returns operations from the given range of operation base versions that were added to the history.\n\t *\n\t * Note that there may be gaps in operations base versions.\n\t *\n\t * @param {Number} [fromBaseVersion] Base version from which operations should be returned (inclusive).\n\t * @param {Number} [toBaseVersion] Base version up to which operations should be returned (exclusive).\n     * @returns {Array.<module:engine/model/operation/operation~Operation>} History operations for the given range, in chronological order.\n\t */\n\tgetOperations( fromBaseVersion, toBaseVersion = this.version ) {\n\t\t// When there is no operation in the history, return an empty array.\n\t\t// After that we can be sure that `firstOperation`, `lastOperation` are not nullish.\n\t\tif ( !this._operations.length ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst firstOperation = this._operations[ 0 ];\n\n\t\tif ( fromBaseVersion === undefined ) {\n\t\t\tfromBaseVersion = firstOperation.baseVersion;\n\t\t}\n\n\t\t// Change exclusive `toBaseVersion` to inclusive, so it will refer to the actual index.\n\t\t// Thanks to that mapping from base versions to operation indexes are possible.\n\t\tlet inclusiveTo = toBaseVersion - 1;\n\n\t\t// Check if \"from\" or \"to\" point to a gap between versions.\n\t\t// If yes, then change the incorrect position to the proper side of the gap.\n\t\t// Thanks to it, it will be possible to get index of the operation.\n\t\tfor ( const [ gapFrom, gapTo ] of this._gaps ) {\n\t\t\tif ( fromBaseVersion > gapFrom && fromBaseVersion < gapTo ) {\n\t\t\t\tfromBaseVersion = gapTo;\n\t\t\t}\n\n\t\t\tif ( inclusiveTo > gapFrom && inclusiveTo < gapTo ) {\n\t\t\t\tinclusiveTo = gapFrom - 1;\n\t\t\t}\n\t\t}\n\n\t\t// If the whole range is outside of the operation versions, then return an empty array.\n\t\tif ( inclusiveTo < firstOperation.baseVersion || fromBaseVersion > this.lastOperation.baseVersion ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet fromIndex = this._baseVersionToOperationIndex.get( fromBaseVersion );\n\n\t\t// If the range starts before the first operation, then use the first operation as the range's start.\n\t\tif ( fromIndex === undefined ) {\n\t\t\tfromIndex = 0;\n\t\t}\n\n\t\tlet toIndex = this._baseVersionToOperationIndex.get( inclusiveTo );\n\n\t\t// If the range ends after the last operation, then use the last operation as the range's end.\n\t\tif ( toIndex === undefined ) {\n\t\t\ttoIndex = this._operations.length - 1;\n\t\t}\n\n\t\t// Return the part of the history operations based on the calculated start index and end index.\n\t\treturn this._operations.slice(\n\t\t\tfromIndex,\n\n\t\t\t// The `toIndex` should be included in the returned operations, so add `1`.\n\t\t\ttoIndex + 1\n\t\t);\n\t}\n\n\t/**\n\t * Returns operation from the history that bases on given `baseVersion`.\n\t *\n\t * @param {Number} baseVersion Base version of the operation to get.\n\t * @returns {module:engine/model/operation/operation~Operation|undefined} Operation with given base version or `undefined` if\n\t * there is no such operation in history.\n\t */\n\tgetOperation( baseVersion ) {\n\t\tconst operationIndex = this._baseVersionToOperationIndex.get( baseVersion );\n\n\t\tif ( operationIndex === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this._operations[ operationIndex ];\n\t}\n\n\t/**\n\t * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,\n\t * history is keeping more context information about operations, which helps in operational transformation.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} undoneOperation Operation which is undone by `undoingOperation`.\n\t * @param {module:engine/model/operation/operation~Operation} undoingOperation Operation which undoes `undoneOperation`.\n\t */\n\tsetOperationAsUndone( undoneOperation, undoingOperation ) {\n\t\tthis._undoPairs.set( undoingOperation, undoneOperation );\n\t\tthis._undoneOperations.add( undoneOperation );\n\t}\n\n\t/**\n\t * Checks whether given `operation` is undoing any other operation.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n\t * @returns {Boolean} `true` if given `operation` is undoing any other operation, `false` otherwise.\n\t */\n\tisUndoingOperation( operation ) {\n\t\treturn this._undoPairs.has( operation );\n\t}\n\n\t/**\n\t * Checks whether given `operation` has been undone by any other operation.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n\t * @returns {Boolean} `true` if given `operation` has been undone any other operation, `false` otherwise.\n\t */\n\tisUndoneOperation( operation ) {\n\t\treturn this._undoneOperations.has( operation );\n\t}\n\n\t/**\n\t * For given `undoingOperation`, returns the operation which has been undone by it.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} undoingOperation\n\t * @returns {module:engine/model/operation/operation~Operation|undefined} Operation that has been undone by given\n\t * `undoingOperation` or `undefined` if given `undoingOperation` is not undoing any other operation.\n\t */\n\tgetUndoneOperation( undoingOperation ) {\n\t\treturn this._undoPairs.get( undoingOperation );\n\t}\n\n\t/**\n\t * Resets the history of operations.\n\t */\n\treset() {\n\t\tthis._version = 0;\n\t\tthis._undoPairs = new Map();\n\t\tthis._operations = [];\n\t\tthis._undoneOperations = new Set();\n\t\tthis._gaps = new Map();\n\t\tthis._baseVersionToOperationIndex = new Map();\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}