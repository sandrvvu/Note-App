{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/schema\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport Range from './range';\nimport Position from './position';\nimport Element from './element';\nimport Text from './text';\nimport TreeWalker from './treewalker';\n/**\n * The model's schema. It defines the allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by the features and based on them, the editing framework and features\n * make decisions on how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * Read more about the schema in:\n *\n * * The {@glink framework/guides/architecture/editing-engine#schema schema section} of the\n * {@glink framework/guides/architecture/editing-engine Introduction to the Editing engine architecture} guide.\n * * The {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nexport default class Schema {\n  /**\n   * Creates a schema instance.\n   */\n  constructor() {\n    this._sourceDefinitions = {};\n    /**\n     * A dictionary containing attribute properties.\n     *\n     * @private\n     * @member {Object.<String,String>}\n     */\n\n    this._attributeProperties = {};\n    this.decorate('checkChild');\n    this.decorate('checkAttribute');\n    this.on('checkAttribute', (evt, args) => {\n      args[0] = new SchemaContext(args[0]);\n    }, {\n      priority: 'highest'\n    });\n    this.on('checkChild', (evt, args) => {\n      args[0] = new SchemaContext(args[0]);\n      args[1] = this.getDefinition(args[1]);\n    }, {\n      priority: 'highest'\n    });\n  }\n  /**\n   * Registers a schema item. Can only be called once for every item name.\n   *\n   *\t\tschema.register( 'paragraph', {\n   *\t\t\tinheritAllFrom: '$block'\n   *\t\t} );\n   *\n   * @param {String} itemName\n   * @param {module:engine/model/schema~SchemaItemDefinition} definition\n   */\n\n\n  register(itemName, definition) {\n    if (this._sourceDefinitions[itemName]) {\n      /**\n       * A single item cannot be registered twice in the schema.\n       *\n       * This situation may happen when:\n       *\n       * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that\n       * there is a collision between plugins which try to use the same element in the model. Unfortunately,\n       * the only way to solve this is by modifying one of these plugins to use a unique model element name.\n       * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions\n       * and usually means one or more of the following issues:\n       *     * a version mismatch (two of your dependencies require two different versions of this plugin),\n       *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),\n       *     * mess in `node_modules/` (`rm -rf node_modules/` may help).\n       *\n       * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.\n       *\n       * @param itemName The name of the model element that is being registered twice.\n       * @error schema-cannot-register-item-twice\n       */\n      throw new CKEditorError('schema-cannot-register-item-twice', this, {\n        itemName\n      });\n    }\n\n    this._sourceDefinitions[itemName] = [Object.assign({}, definition)];\n\n    this._clearCache();\n  }\n  /**\n   * Extends a {@link #register registered} item's definition.\n   *\n   * Extending properties such as `allowIn` will add more items to the existing properties,\n   * while redefining properties such as `isBlock` will override the previously defined ones.\n   *\n   *\t\tschema.register( 'foo', {\n   *\t\t\tallowIn: '$root',\n   *\t\t\tisBlock: true;\n   *\t\t} );\n   *\t\tschema.extend( 'foo', {\n   *\t\t\tallowIn: 'blockQuote',\n   *\t\t\tisBlock: false\n   *\t\t} );\n   *\n   *\t\tschema.getDefinition( 'foo' );\n   *\t\t//\t{\n   *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n   *\t\t// \t\tisBlock: false\n   *\t\t//\t}\n   *\n   * @param {String} itemName\n   * @param {module:engine/model/schema~SchemaItemDefinition} definition\n   */\n\n\n  extend(itemName, definition) {\n    if (!this._sourceDefinitions[itemName]) {\n      /**\n       * Cannot extend an item which was not registered yet.\n       *\n       * This error happens when a plugin tries to extend the schema definition of an item which was not\n       * {@link #register registered} yet.\n       *\n       * @param itemName The name of the model element which is being extended.\n       * @error schema-cannot-extend-missing-item\n       */\n      throw new CKEditorError('schema-cannot-extend-missing-item', this, {\n        itemName\n      });\n    }\n\n    this._sourceDefinitions[itemName].push(Object.assign({}, definition));\n\n    this._clearCache();\n  }\n  /**\n   * Returns data of all registered items.\n   *\n   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n   * checking a list of all block elements, etc).\n   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n   * in other cases.\n   *\n   * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n   */\n\n\n  getDefinitions() {\n    if (!this._compiledDefinitions) {\n      this._compile();\n    }\n\n    return this._compiledDefinitions;\n  }\n  /**\n   * Returns a definition of the given item or `undefined` if an item is not registered.\n   *\n   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n   * checking a list of all block elements, etc).\n   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n   * in other cases.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n   */\n\n\n  getDefinition(item) {\n    let itemName;\n\n    if (typeof item == 'string') {\n      itemName = item;\n    } else if (item.is && (item.is('$text') || item.is('$textProxy'))) {\n      itemName = '$text';\n    } // Element or module:engine/model/schema~SchemaContextItem.\n    else {\n      itemName = item.name;\n    }\n\n    return this.getDefinitions()[itemName];\n  }\n  /**\n   * Returns `true` if the given item is registered in the schema.\n   *\n   *\t\tschema.isRegistered( 'paragraph' ); // -> true\n   *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n   *\t\tschema.isRegistered( 'foo' ); // -> false\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n  \t * @returns {Boolean}\n   */\n\n\n  isRegistered(item) {\n    return !!this.getDefinition(item);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n   *\n   *\t\tschema.isBlock( 'paragraph' ); // -> true\n   *\t\tschema.isBlock( '$root' ); // -> false\n   *\n   *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n   *\t\tschema.isBlock( paragraphElement ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#block-elements Block elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   \t * @returns {Boolean}\n   */\n\n\n  isBlock(item) {\n    const def = this.getDefinition(item);\n    return !!(def && def.isBlock);\n  }\n  /**\n   * Returns `true` if the given item should be treated as a limit element.\n   *\n   * It considers an item to be a limit element if its\n   * {@link module:engine/model/schema~SchemaItemDefinition}'s\n   * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or\n   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n   * was set to `true`.\n   *\n   *\t\tschema.isLimit( 'paragraph' ); // -> false\n   *\t\tschema.isLimit( '$root' ); // -> true\n   *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n   *\t\tschema.isLimit( 'imageBlock' ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#limit-elements Limit elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   \t * @returns {Boolean}\n   */\n\n\n  isLimit(item) {\n    const def = this.getDefinition(item);\n\n    if (!def) {\n      return false;\n    }\n\n    return !!(def.isLimit || def.isObject);\n  }\n  /**\n   * Returns `true` if the given item should be treated as an object element.\n   *\n   * It considers an item to be an object element if its\n   * {@link module:engine/model/schema~SchemaItemDefinition}'s\n   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n   * was set to `true`.\n   *\n   *\t\tschema.isObject( 'paragraph' ); // -> false\n   *\t\tschema.isObject( 'imageBlock' ); // -> true\n   *\n   *\t\tconst imageElement = writer.createElement( 'imageBlock' );\n   *\t\tschema.isObject( imageElement ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#object-elements Object elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   \t * @returns {Boolean}\n   */\n\n\n  isObject(item) {\n    const def = this.getDefinition(item);\n\n    if (!def) {\n      return false;\n    } // Note: Check out the implementation of #isLimit(), #isSelectable(), and #isContent()\n    // to understand why these three constitute an object.\n\n\n    return !!(def.isObject || def.isLimit && def.isSelectable && def.isContent);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.\n   *\n   *\t\tschema.isInline( 'paragraph' ); // -> false\n   *\t\tschema.isInline( 'softBreak' ); // -> true\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\tschema.isInline( text ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#inline-elements Inline elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n\n\n  isInline(item) {\n    const def = this.getDefinition(item);\n    return !!(def && def.isInline);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.\n   *\n   *\t\tschema.isSelectable( 'paragraph' ); // -> false\n   *\t\tschema.isSelectable( 'heading1' ); // -> false\n   *\t\tschema.isSelectable( 'imageBlock' ); // -> true\n   *\t\tschema.isSelectable( 'tableCell' ); // -> true\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\tschema.isSelectable( text ); // -> false\n   *\n   * See the {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n\n\n  isSelectable(item) {\n    const def = this.getDefinition(item);\n\n    if (!def) {\n      return false;\n    }\n\n    return !!(def.isSelectable || def.isObject);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.\n   *\n   *\t\tschema.isContent( 'paragraph' ); // -> false\n   *\t\tschema.isContent( 'heading1' ); // -> false\n   *\t\tschema.isContent( 'imageBlock' ); // -> true\n   *\t\tschema.isContent( 'horizontalLine' ); // -> true\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\tschema.isContent( text ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n\n\n  isContent(item) {\n    const def = this.getDefinition(item);\n\n    if (!def) {\n      return false;\n    }\n\n    return !!(def.isContent || def.isObject);\n  }\n  /**\n   * Checks whether the given node (`child`) can be a child of the given context.\n   *\n   *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n   *\n   *\t\tschema.register( 'paragraph', {\n   *\t\t\tallowIn: '$root'\n   *\t\t} );\n   *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n   *\n   * Note: When verifying whether the given node can be a child of the given context, the\n   * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n   * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n   * It happens if one of the context's elements does not allow its child.\n   *\n   * @fires checkChild\n   * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n   * @param {module:engine/model/node~Node|String} def The child to check.\n   * @returns {Boolean}\n   */\n\n\n  checkChild(context, def) {\n    // Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n    if (!def) {\n      return false;\n    }\n\n    return this._checkContextMatch(def, context);\n  }\n  /**\n   * Checks whether the given attribute can be applied in the given context (on the last\n   * item of the context).\n   *\n   *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n   *\n   *\t\tschema.extend( '$text', {\n   *\t\t\tallowAttributes: 'bold'\n   *\t\t} );\n   *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n   *\n   * @fires checkAttribute\n   * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n   * @param {String} attributeName\n   * @returns {Boolean}\n   */\n\n\n  checkAttribute(context, attributeName) {\n    const def = this.getDefinition(context.last);\n\n    if (!def) {\n      return false;\n    }\n\n    return def.allowAttributes.includes(attributeName);\n  }\n  /**\n   * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n   *\n   * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n   *\n   * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n   * will be valid.\n   *\n   * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n   * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n   *\n   * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n   * element to which the `elementToMerge` will be merged.\n   * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n   * @returns {Boolean}\n   */\n\n\n  checkMerge(positionOrBaseElement) {\n    let elementToMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (positionOrBaseElement instanceof Position) {\n      const nodeBefore = positionOrBaseElement.nodeBefore;\n      const nodeAfter = positionOrBaseElement.nodeAfter;\n\n      if (!(nodeBefore instanceof Element)) {\n        /**\n         * The node before the merge position must be an element.\n         *\n         * @error schema-check-merge-no-element-before\n         */\n        throw new CKEditorError('schema-check-merge-no-element-before', this);\n      }\n\n      if (!(nodeAfter instanceof Element)) {\n        /**\n         * The node after the merge position must be an element.\n         *\n         * @error schema-check-merge-no-element-after\n         */\n        throw new CKEditorError('schema-check-merge-no-element-after', this);\n      }\n\n      return this.checkMerge(nodeBefore, nodeAfter);\n    }\n\n    for (const child of elementToMerge.getChildren()) {\n      if (!this.checkChild(positionOrBaseElement, child)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Allows registering a callback to the {@link #checkChild} method calls.\n   *\n   * Callbacks allow you to implement rules which are not otherwise possible to achieve\n   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n   * For example, by using this method you can disallow elements in specific contexts.\n   *\n   * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n   * you can use that event instead.\n   *\n   * Example:\n   *\n   *\t\t// Disallow heading1 directly inside a blockQuote.\n   *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n   *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n   *\t\t\t\treturn false;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Which translates to:\n   *\n   *\t\tschema.on( 'checkChild', ( evt, args ) => {\n   *\t\t\tconst context = args[ 0 ];\n   *\t\t\tconst childDefinition = args[ 1 ];\n   *\n   *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n   *\t\t\t\t// Prevent next listeners from being called.\n   *\t\t\t\tevt.stop();\n   *\t\t\t\t// Set the checkChild()'s return value.\n   *\t\t\t\tevt.return = false;\n   *\t\t\t}\n   *\t\t}, { priority: 'high' } );\n   *\n   * @param {Function} callback The callback to be called. It is called with two parameters:\n   * {@link module:engine/model/schema~SchemaContext} (context) instance and\n   * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n   * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n   * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n   */\n\n\n  addChildCheck(callback) {\n    this.on('checkChild', (evt, _ref) => {\n      let [ctx, childDef] = _ref;\n\n      // checkChild() was called with a non-registered child.\n      // In 99% cases such check should return false, so not to overcomplicate all callbacks\n      // don't even execute them.\n      if (!childDef) {\n        return;\n      }\n\n      const retValue = callback(ctx, childDef);\n\n      if (typeof retValue == 'boolean') {\n        evt.stop();\n        evt.return = retValue;\n      }\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * Allows registering a callback to the {@link #checkAttribute} method calls.\n   *\n   * Callbacks allow you to implement rules which are not otherwise possible to achieve\n   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n   * For example, by using this method you can disallow attribute if node to which it is applied\n   * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n   *\n   * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n   * you can use that event instead.\n   *\n   * Example:\n   *\n   *\t\t// Disallow bold on $text inside heading1.\n   *\t\tschema.addAttributeCheck( ( context, attributeName ) => {\n   *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n   *\t\t\t\treturn false;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Which translates to:\n   *\n   *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n   *\t\t\tconst context = args[ 0 ];\n   *\t\t\tconst attributeName = args[ 1 ];\n   *\n   *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n   *\t\t\t\t// Prevent next listeners from being called.\n   *\t\t\t\tevt.stop();\n   *\t\t\t\t// Set the checkAttribute()'s return value.\n   *\t\t\t\tevt.return = false;\n   *\t\t\t}\n   *\t\t}, { priority: 'high' } );\n   *\n   * @param {Function} callback The callback to be called. It is called with two parameters:\n   * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n   * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n   * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n   */\n\n\n  addAttributeCheck(callback) {\n    this.on('checkAttribute', (evt, _ref2) => {\n      let [ctx, attributeName] = _ref2;\n      const retValue = callback(ctx, attributeName);\n\n      if (typeof retValue == 'boolean') {\n        evt.stop();\n        evt.return = retValue;\n      }\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * This method allows assigning additional metadata to the model attributes. For example,\n   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is\n   * used to mark formatting attributes (like `bold` or `italic`).\n   *\n   *\t\t// Mark bold as a formatting attribute.\n   *\t\tschema.setAttributeProperties( 'bold', {\n   *\t\t\tisFormatting: true\n   *\t\t} );\n   *\n   *\t\t// Override code not to be considered a formatting markup.\n   *\t\tschema.setAttributeProperties( 'code', {\n   *\t\t\tisFormatting: false\n   *\t\t} );\n   *\n   * Properties are not limited to members defined in the\n   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:\n   *\n   *\t\tschema.setAttributeProperties( 'blockQuote', {\n   *\t\t\tcustomProperty: 'value'\n   *\t\t} );\n   *\n   * Subsequent calls with the same attribute will extend its custom properties:\n   *\n   *\t\tschema.setAttributeProperties( 'blockQuote', {\n   *\t\t\tone: 1\n   *\t\t} );\n   *\n   *\t\tschema.setAttributeProperties( 'blockQuote', {\n   *\t\t\ttwo: 2\n   *\t\t} );\n   *\n   *\t\tconsole.log( schema.getAttributeProperties( 'blockQuote' ) );\n   *\t\t// Logs: { one: 1, two: 2 }\n   *\n   * @param {String} attributeName A name of the attribute to receive the properties.\n   * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.\n   */\n\n\n  setAttributeProperties(attributeName, properties) {\n    this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);\n  }\n  /**\n   * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.\n   *\n   * @param {String} attributeName A name of the attribute.\n   * @returns {module:engine/model/schema~AttributeProperties}\n   */\n\n\n  getAttributeProperties(attributeName) {\n    return this._attributeProperties[attributeName] || {};\n  }\n  /**\n   * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n   * selection/range/position or the root otherwise.\n   *\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n   * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n   * The selection/range/position to check.\n   * @returns {module:engine/model/element~Element} The lowest limit element containing\n   * the entire `selectionOrRangeOrPosition`.\n   */\n\n\n  getLimitElement(selectionOrRangeOrPosition) {\n    let element;\n\n    if (selectionOrRangeOrPosition instanceof Position) {\n      element = selectionOrRangeOrPosition.parent;\n    } else {\n      const ranges = selectionOrRangeOrPosition instanceof Range ? [selectionOrRangeOrPosition] : Array.from(selectionOrRangeOrPosition.getRanges()); // Find the common ancestor for all selection's ranges.\n\n      element = ranges.reduce((element, range) => {\n        const rangeCommonAncestor = range.getCommonAncestor();\n\n        if (!element) {\n          return rangeCommonAncestor;\n        }\n\n        return element.getCommonAncestor(rangeCommonAncestor, {\n          includeSelf: true\n        });\n      }, null);\n    }\n\n    while (!this.isLimit(element)) {\n      if (element.parent) {\n        element = element.parent;\n      } else {\n        break;\n      }\n    }\n\n    return element;\n  }\n  /**\n   * Checks whether the attribute is allowed in selection:\n   *\n   * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n   * * if the selection is collapsed, then checks if on the selection position there's a text with the\n   * specified attribute allowed.\n   *\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n   * Selection which will be checked.\n   * @param {String} attribute The name of the attribute to check.\n   * @returns {Boolean}\n   */\n\n\n  checkAttributeInSelection(selection, attribute) {\n    if (selection.isCollapsed) {\n      const firstPosition = selection.getFirstPosition();\n      const context = [...firstPosition.getAncestors(), new Text('', selection.getAttributes())]; // Check whether schema allows for a text with the attribute in the selection.\n\n      return this.checkAttribute(context, attribute);\n    } else {\n      const ranges = selection.getRanges(); // For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n\n      for (const range of ranges) {\n        for (const value of range) {\n          if (this.checkAttribute(value.item, attribute)) {\n            // If we found a node that is allowed to have the attribute, return true.\n            return true;\n          }\n        }\n      }\n    } // If we haven't found such node, return false.\n\n\n    return false;\n  }\n  /**\n   * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n   *\n   * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.\n   * @param {String} attribute The name of the attribute to check.\n   * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n   */\n\n\n  *getValidRanges(ranges, attribute) {\n    ranges = convertToMinimalFlatRanges(ranges);\n\n    for (const range of ranges) {\n      yield* this._getValidRangesForRange(range, attribute);\n    }\n  }\n  /**\n   * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n   * nearest to that `position` and is a correct range for selection.\n   *\n   * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n   * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n   * the {@link module:engine/model/schema~Schema schema}.\n   *\n   * Direction of searching for the nearest correct selection range can be specified as:\n   *\n   * * `both` - searching will be performed in both ways,\n   * * `forward` - searching will be performed only forward,\n   * * `backward` - searching will be performed only backward.\n   *\n   * When valid selection range cannot be found, `null` is returned.\n   *\n   * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n   * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n   * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n   */\n\n\n  getNearestSelectionRange(position) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'both';\n\n    // Return collapsed range if provided position is valid.\n    if (this.checkChild(position, '$text')) {\n      return new Range(position);\n    }\n\n    let backwardWalker, forwardWalker; // Never leave a limit element.\n\n    const limitElement = position.getAncestors().reverse().find(item => this.isLimit(item)) || position.root;\n\n    if (direction == 'both' || direction == 'backward') {\n      backwardWalker = new TreeWalker({\n        boundaries: Range._createIn(limitElement),\n        startPosition: position,\n        direction: 'backward'\n      });\n    }\n\n    if (direction == 'both' || direction == 'forward') {\n      forwardWalker = new TreeWalker({\n        boundaries: Range._createIn(limitElement),\n        startPosition: position\n      });\n    }\n\n    for (const data of combineWalkers(backwardWalker, forwardWalker)) {\n      const type = data.walker == backwardWalker ? 'elementEnd' : 'elementStart';\n      const value = data.value;\n\n      if (value.type == type && this.isObject(value.item)) {\n        return Range._createOn(value.item);\n      }\n\n      if (this.checkChild(value.nextPosition, '$text')) {\n        return new Range(value.nextPosition);\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Tries to find position ancestors that allow to insert a given node.\n   * It starts searching from the given position and goes node by node to the top of the model tree\n   * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an\n   * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.\n   *\n   * @param {module:engine/model/position~Position} position The position that the search will start from.\n   * @param {module:engine/model/node~Node|String} node The node for which an allowed parent should be found or its name.\n   * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n   */\n\n\n  findAllowedParent(position, node) {\n    let parent = position.parent;\n\n    while (parent) {\n      if (this.checkChild(parent, node)) {\n        return parent;\n      } // Do not split limit elements.\n\n\n      if (this.isLimit(parent)) {\n        return null;\n      }\n\n      parent = parent.parent;\n    }\n\n    return null;\n  }\n  /**\n   * Sets attributes allowed by the schema on a given node.\n   *\n   * @param {module:engine/model/node~Node} node A node to set attributes on.\n   * @param {Object} attributes Attributes keys and values.\n   * @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n   */\n\n\n  setAllowedAttributes(node, attributes, writer) {\n    const model = writer.model;\n\n    for (const [attributeName, attributeValue] of Object.entries(attributes)) {\n      if (model.schema.checkAttribute(node, attributeName)) {\n        writer.setAttribute(attributeName, attributeValue, node);\n      }\n    }\n  }\n  /**\n   * Removes attributes disallowed by the schema.\n   *\n   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n   * @param {module:engine/model/writer~Writer} writer\n   */\n\n\n  removeDisallowedAttributes(nodes, writer) {\n    for (const node of nodes) {\n      // When node is a `Text` it has no children, so just filter it out.\n      if (node.is('$text')) {\n        removeDisallowedAttributeFromNode(this, node, writer);\n      } // In a case of `Element` iterates through positions between nodes inside this element\n      // and filter out node before the current position, or position parent when position\n      // is at start of an element. Using positions prevent from omitting merged nodes\n      // see https://github.com/ckeditor/ckeditor5-engine/issues/1789.\n      else {\n        const rangeInNode = Range._createIn(node);\n\n        const positionsInRange = rangeInNode.getPositions();\n\n        for (const position of positionsInRange) {\n          const item = position.nodeBefore || position.parent;\n          removeDisallowedAttributeFromNode(this, item, writer);\n        }\n      }\n    }\n  }\n  /**\n   * Gets attributes of a node that have a given property.\n   *\n   * @param {module:engine/model/node~Node} node Node to get attributes from.\n   * @param {String} propertyName Name of the property that attribute must have to return it.\n   * @param {Boolean|Symbol|String|Number|Object|null|undefined} propertyValue Desired value of the property that we want to check.\n   * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will\n   * return attributes which given property's value is equal to this parameter.\n   * @returns {Object} Object with attributes' names as key and attributes' values as value.\n   */\n\n\n  getAttributesWithProperty(node, propertyName, propertyValue) {\n    const attributes = {};\n\n    for (const [attributeName, attributeValue] of node.getAttributes()) {\n      const attributeProperties = this.getAttributeProperties(attributeName);\n\n      if (attributeProperties[propertyName] === undefined) {\n        continue;\n      }\n\n      if (propertyValue === undefined || propertyValue === attributeProperties[propertyName]) {\n        attributes[attributeName] = attributeValue;\n      }\n    }\n\n    return attributes;\n  }\n  /**\n   * Creates an instance of the schema context.\n   *\n   * @param {module:engine/model/schema~SchemaContextDefinition} context\n   * @returns {module:engine/model/schema~SchemaContext}\n   */\n\n\n  createContext(context) {\n    return new SchemaContext(context);\n  }\n  /**\n   * @private\n   */\n\n\n  _clearCache() {\n    this._compiledDefinitions = null;\n  }\n  /**\n   * @private\n   */\n\n\n  _compile() {\n    const compiledDefinitions = {};\n    const sourceRules = this._sourceDefinitions;\n    const itemNames = Object.keys(sourceRules);\n\n    for (const itemName of itemNames) {\n      compiledDefinitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);\n    }\n\n    for (const itemName of itemNames) {\n      compileAllowChildren(compiledDefinitions, itemName);\n    }\n\n    for (const itemName of itemNames) {\n      compileAllowContentOf(compiledDefinitions, itemName);\n    }\n\n    for (const itemName of itemNames) {\n      compileAllowWhere(compiledDefinitions, itemName);\n    }\n\n    for (const itemName of itemNames) {\n      compileAllowAttributesOf(compiledDefinitions, itemName);\n      compileInheritPropertiesFrom(compiledDefinitions, itemName);\n    }\n\n    for (const itemName of itemNames) {\n      cleanUpAllowIn(compiledDefinitions, itemName);\n      setupAllowChildren(compiledDefinitions, itemName);\n      cleanUpAllowAttributes(compiledDefinitions, itemName);\n    }\n\n    this._compiledDefinitions = compiledDefinitions;\n  }\n  /**\n   * @private\n   * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n   * @param {module:engine/model/schema~SchemaContext} context\n   * @param {Number} contextItemIndex\n   */\n\n\n  _checkContextMatch(def, context) {\n    let contextItemIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context.length - 1;\n    const contextItem = context.getItem(contextItemIndex);\n\n    if (def.allowIn.includes(contextItem.name)) {\n      if (contextItemIndex == 0) {\n        return true;\n      } else {\n        const parentRule = this.getDefinition(contextItem);\n        return this._checkContextMatch(parentRule, context, contextItemIndex - 1);\n      }\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges\n   * inside the given range on which the attribute can be applied.\n   *\n   * This is a helper function for {@link ~Schema#getValidRanges}.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range The range to process.\n   * @param {String} attribute The name of the attribute to check.\n   * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n   */\n\n\n  *_getValidRangesForRange(range, attribute) {\n    let start = range.start;\n    let end = range.start;\n\n    for (const item of range.getItems({\n      shallow: true\n    })) {\n      if (item.is('element')) {\n        yield* this._getValidRangesForRange(Range._createIn(item), attribute);\n      }\n\n      if (!this.checkAttribute(item, attribute)) {\n        if (!start.isEqual(end)) {\n          yield new Range(start, end);\n        }\n\n        start = Position._createAfter(item);\n      }\n\n      end = Position._createAfter(item);\n    }\n\n    if (!start.isEqual(end)) {\n      yield new Range(start, end);\n    }\n  }\n\n}\nmix(Schema, ObservableMixin);\n/**\n * Event fired when the {@link #checkChild} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addChildCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkChild} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding standard behavior of the\n * `checkChild()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkChild( context, child )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance and `child` to a\n * {@link module:engine/model/schema~SchemaCompiledItemDefinition} instance, so you do not have to worry about\n * the various ways how `context` and `child` may be passed to `checkChild()`.\n *\n * **Note:** `childDefinition` may be `undefined` if `checkChild()` was called with a non-registered element.\n *\n * So, in order to implement a rule \"disallow `heading1` in `blockQuote`\", you can add such a listener:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing elements in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowIn` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `listItem` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo' ) && childDefinition.name == 'listItem' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkChild\n * @param {Array} args The `checkChild()`'s arguments.\n */\n\n/**\n * Event fired when the {@link #checkAttribute} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addAttributeCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkAttribute} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding the standard behavior of the\n * `checkAttribute()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkAttribute( context, attributeName )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance, so you do not have to worry about\n * the various ways how `context` may be passed to `checkAttribute()`.\n *\n * So, in order to implement a rule \"disallow `bold` in a text which is in a `heading1`, you can add such a listener:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing attributes in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowAttributes` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `bold` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkAttribute\n * @param {Array} args The `checkAttribute()`'s arguments.\n */\n\n/**\n * A definition of a {@link module:engine/model/schema~Schema schema} item.\n *\n * You can define the following rules:\n *\n * * {@link ~SchemaItemDefinition#allowIn `allowIn`} &ndash; Defines in which other items this item will be allowed.\n * * {@link ~SchemaItemDefinition#allowChildren `allowChildren`} &ndash; Defines which other items are allowed inside this item.\n * * {@link ~SchemaItemDefinition#allowAttributes `allowAttributes`} &ndash; Defines allowed attributes of the given item.\n * * {@link ~SchemaItemDefinition#allowContentOf `allowContentOf`} &ndash; Inherits \"allowed children\" from other items.\n * * {@link ~SchemaItemDefinition#allowWhere `allowWhere`} &ndash; Inherits \"allowed in\" from other items.\n * * {@link ~SchemaItemDefinition#allowAttributesOf `allowAttributesOf`} &ndash; Inherits attributes from other items.\n * * {@link ~SchemaItemDefinition#inheritTypesFrom `inheritTypesFrom`} &ndash; Inherits `is*` properties of other items.\n * * {@link ~SchemaItemDefinition#inheritAllFrom `inheritAllFrom`} &ndash;\n * A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * # The `is*` properties\n *\n * There are a couple commonly used `is*` properties. Their role is to assign additional semantics to schema items.\n * You can define more properties but you will also need to implement support for them in the existing editor features.\n *\n * * {@link ~SchemaItemDefinition#isBlock `isBlock`} &ndash; Whether this item is paragraph-like.\n * Generally speaking, content is usually made out of blocks like paragraphs, list items, images, headings, etc.\n * * {@link ~SchemaItemDefinition#isInline `isInline`} &ndash; Whether an item is \"text-like\" and should be treated as an inline node.\n * Examples of inline elements: `$text`, `softBreak` (`<br>`), etc.\n * * {@link ~SchemaItemDefinition#isLimit `isLimit`} &ndash; It can be understood as whether this element\n * should not be split by <kbd>Enter</kbd>. Examples of limit elements: `$root`, table cell, image caption, etc.\n * In other words, all actions that happen inside a limit element are limited to its content.\n * All objects are treated as limit elements, too.\n * * {@link ~SchemaItemDefinition#isObject `isObject`} &ndash; Whether an item is \"self-contained\" and should be treated as a whole.\n * Examples of object elements: `imageBlock`, `table`, `video`, etc. An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the meaning of these types in the\n * {@glink framework/guides/deep-dive/schema#defining-additional-semantics dedicated section of the Schema deep dive} guide.\n *\n * # Generic items\n *\n * There are several generic items (classes of elements) available: `$root`, `$container`, `$block`, `$blockObject`,\n * `$inlineObject`, and `$text`. They are defined as follows:\n *\n *\t\tschema.register( '$root', {\n *\t\t\tisLimit: true\n *\t\t} );\n *\n *\t\tschema.register( '$container', {\n *\t\t\tallowIn: [ '$root', '$container' ]\n *\t\t} );\n *\n *\t\tschema.register( '$block', {\n *\t\t\tallowIn: [ '$root', '$container' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n *\t\tschema.register( '$blockObject', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n *\t\tschema.register( '$inlineObject', {\n *\t\t\tallowWhere: '$text',\n *\t\t\tallowAttributesOf: '$text',\n *\t\t\tisInline: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n *\t\tschema.register( '$text', {\n *\t\t\tallowIn: '$block',\n *\t\t\tisInline: true,\n *\t\t\tisContent: true\n *\t\t} );\n *\n * They reflect typical editor content that is contained within one root, consists of several blocks\n * (paragraphs, lists items, headings, images) which, in turn, may contain text inside.\n *\n * By inheriting from the generic items you can define new items which will get extended by other editor features.\n * Read more about generic types in the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * # Example definitions\n *\n * Allow `paragraph` in roots and block quotes:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: [ '$root', 'blockQuote' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` everywhere where `$block` is allowed (i.e. in `$root`):\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` inside a `$root` and allow `$text` as a `paragraph` child:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: '$root',\n *\t\t\tallowChildren: '$text',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * The previous rule can be written in a shorter form using inheritance:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tinheritAllFrom: '$block'\n *\t\t} );\n *\n * Make `imageBlock` a block object, which is allowed everywhere where `$block` is.\n * Also, allow `src` and `alt` attributes in it:\n *\n *\t\tschema.register( 'imageBlock', {\n *\t\t\tinheritAllFrom: '$blockObject',\n *\t\t\tallowAttributes: [ 'src', 'alt' ],\n *\t\t} );\n *\n * Make `caption` allowed in `imageBlock` and make it allow all the content of `$block`s (usually, `$text`).\n * Also, mark it as a limit element so it cannot be split:\n *\n *\t\tschema.register( 'caption', {\n *\t\t\tallowIn: 'imageBlock',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tisLimit: true\n *\t\t} );\n *\n * Make `listItem` inherit all from `$block` but also allow additional attributes:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tinheritAllFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * Which translates to:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tallowAttributesOf: '$block',\n *\t\t\tinheritTypesFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * # Tips\n *\n * * Check schema definitions of existing features to see how they are defined.\n * * If you want to publish your feature so other developers can use it, try to use\n * generic items as much as possible.\n * * Keep your model clean. Limit it to the actual data and store information in a normalized way.\n * * Remember about defining the `is*` properties. They do not affect the allowed structures, but they can\n * affect how the editor features treat your elements.\n *\n * @typedef {Object} module:engine/model/schema~SchemaItemDefinition\n *\n * @property {String|Array.<String>} allowIn Defines in which other items this item will be allowed.\n * @property {String|Array.<String>} allowChildren Defines which other items are allowed inside this item.\n * @property {String|Array.<String>} allowAttributes Defines allowed attributes of the given item.\n * @property {String|Array.<String>} allowContentOf Inherits \"allowed children\" from other items.\n * @property {String|Array.<String>} allowWhere Inherits \"allowed in\" from other items.\n * @property {String|Array.<String>} allowAttributesOf Inherits attributes from other items.\n * @property {String|Array.<String>} inheritTypesFrom Inherits `is*` properties of other items.\n * @property {String} inheritAllFrom A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * @property {Boolean} isBlock\n * Whether this item is paragraph-like. Generally speaking, content is usually made out of blocks\n * like paragraphs, list items, images, headings, etc. All these elements are marked as blocks. A block\n * should not allow another block inside. Note: There is also the `$block` generic item which has `isBlock` set to `true`.\n * Most block type items will inherit from `$block` (through `inheritAllFrom`).\n *\n * Read more about the block elements in the\n * {@glink framework/guides/deep-dive/schema#block-elements Block elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive}.\n *\n * @property {Boolean} isInline\n * Whether an item is \"text-like\" and should be treated as an inline node. Examples of inline elements:\n * `$text`, `softBreak` (`<br>`), etc.\n *\n * Read more about the inline elements in the\n * {@glink framework/guides/deep-dive/schema#inline-elements Inline elements section} of the Schema deep dive guide.\n *\n * @property {Boolean} isLimit\n * It can be understood as whether this element should not be split by <kbd>Enter</kbd>.\n * Examples of limit elements: `$root`, table cell, image caption, etc. In other words, all actions that happen inside\n * a limit element are limited to its content.\n *\n * Read more about the limit elements in the\n * {@glink framework/guides/deep-dive/schema#limit-elements Limit elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @property {Boolean} isObject\n * Whether an item is \"self-contained\" and should be treated as a whole. Examples of object elements:\n * `imageBlock`, `table`, `video`, etc.\n *\n * **Note:** An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the object elements in the\n * {@glink framework/guides/deep-dive/schema#object-elements Object elements section} of the Schema deep dive guide.\n *\n * @property {Boolean} isSelectable\n * `true` when an element should be selectable as a whole by the user. Examples of selectable elements: `imageBlock`, `table`, `tableCell`,\n * etc.\n *\n * **Note:** An object is also a selectable element, so\n * {@link module:engine/model/schema~Schema#isSelectable `isSelectable()`} returns `true` for object elements automatically.\n *\n * Read more about selectable elements in the\n * {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @property {Boolean} isContent\n * An item is a content when it always finds its way to the editor data output regardless of the number and type of its descendants.\n * Examples of content elements: `$text`, `imageBlock`, `table`, etc. (but not `paragraph`, `heading1` or `tableCell`).\n *\n * **Note:** An object is also a content element, so\n * {@link module:engine/model/schema~Schema#isContent `isContent()`} returns `true` for object elements automatically.\n *\n * Read more about content elements in the\n * {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n */\n\n/**\n * A simplified version of {@link module:engine/model/schema~SchemaItemDefinition} after\n * compilation by the {@link module:engine/model/schema~Schema schema}.\n * Rules fed to the schema by {@link module:engine/model/schema~Schema#register}\n * and {@link module:engine/model/schema~Schema#extend} methods are defined in the\n * {@link module:engine/model/schema~SchemaItemDefinition} format.\n * Later on, they are compiled to `SchemaCompiledItemDefinition` so when you use e.g.\n * the {@link module:engine/model/schema~Schema#getDefinition} method you get the compiled version.\n *\n * The compiled version contains only the following properties:\n *\n * * The `name` property,\n * * The `is*` properties,\n * * The `allowIn` array,\n * * The `allowChildren` array,\n * * The `allowAttributes` array.\n *\n * @typedef {Object} module:engine/model/schema~SchemaCompiledItemDefinition\n */\n\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\n\nexport class SchemaContext {\n  /**\n   * Creates an instance of the context.\n   *\n   * @param {module:engine/model/schema~SchemaContextDefinition} context\n   */\n  constructor(context) {\n    if (context instanceof SchemaContext) {\n      return context;\n    }\n\n    if (typeof context == 'string') {\n      context = [context];\n    } else if (!Array.isArray(context)) {\n      // `context` is item or position.\n      // Position#getAncestors() doesn't accept any parameters but it works just fine here.\n      context = context.getAncestors({\n        includeSelf: true\n      });\n    }\n\n    this._items = context.map(mapContextItem);\n  }\n  /**\n   * The number of items.\n   *\n   * @type {Number}\n   */\n\n\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * The last item (the lowest node).\n   *\n   * @type {module:engine/model/schema~SchemaContextItem}\n   */\n\n\n  get last() {\n    return this._items[this._items.length - 1];\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all context items.\n   *\n   * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this._items[Symbol.iterator]();\n  }\n  /**\n   * Returns a new schema context instance with an additional item.\n   *\n   * Item can be added as:\n   *\n   * \t\tconst context = new SchemaContext( [ '$root' ] );\n   *\n   * \t\t// An element.\n   * \t\tconst fooElement = writer.createElement( 'fooElement' );\n   * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n   *\n   * \t\t// A text node.\n   * \t\tconst text = writer.createText( 'foobar' );\n   * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n   *\n   * \t\t// A string (element name).\n   * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n   *\n   * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item\n   * (without ancestors).\n   *\n   * @param {String|module:engine/model/node~Node|Array<String|module:engine/model/node~Node>} item An item that will be added\n   * to the current context.\n   * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n   */\n\n\n  push(item) {\n    const ctx = new SchemaContext([item]);\n    ctx._items = [...this._items, ...ctx._items];\n    return ctx;\n  }\n  /**\n   * Gets an item on the given index.\n   *\n   * @returns {module:engine/model/schema~SchemaContextItem}\n   */\n\n\n  getItem(index) {\n    return this._items[index];\n  }\n  /**\n   * Returns the names of items.\n   *\n   * @returns {Iterable.<String>}\n   */\n\n\n  *getNames() {\n    yield* this._items.map(item => item.name);\n  }\n  /**\n   * Checks whether the context ends with the given nodes.\n   *\n   *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n   *\n   *\t\tctx.endsWith( '$text' ); // -> true\n   *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n   *\t\tctx.endsWith( '$root' ); // -> false\n   *\t\tctx.endsWith( 'paragraph' ); // -> false\n   *\n   * @param {String} query\n   * @returns {Boolean}\n   */\n\n\n  endsWith(query) {\n    return Array.from(this.getNames()).join(' ').endsWith(query);\n  }\n  /**\n   * Checks whether the context starts with the given nodes.\n   *\n   *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n   *\n   *\t\tctx.endsWith( '$root' ); // -> true\n   *\t\tctx.endsWith( '$root paragraph' ); // -> true\n   *\t\tctx.endsWith( '$text' ); // -> false\n   *\t\tctx.endsWith( 'paragraph' ); // -> false\n   *\n   * @param {String} query\n   * @returns {Boolean}\n   */\n\n\n  startsWith(query) {\n    return Array.from(this.getNames()).join(' ').startsWith(query);\n  }\n\n}\n/**\n * The definition of a {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * Contexts can be created in multiple ways:\n *\n * * By defining a **node** – in this cases this node and all its ancestors will be used.\n * * By defining a **position** in the document – in this case all its ancestors will be used.\n * * By defining an **array of nodes** – in this case this array defines the entire context.\n * * By defining a **name of node** - in this case node will be \"mocked\". It is not recommended because context\n * will be unrealistic (e.g. attributes of these nodes are not specified). However, at times this may be the only\n * way to define the context (e.g. when checking some hypothetical situation).\n * * By defining an **array of node names** (potentially, mixed with real nodes) – The same as **name of node**\n * but it is possible to create a path.\n * * By defining a {@link module:engine/model/schema~SchemaContext} instance - in this case the same instance as provided\n * will be return.\n *\n * Examples of context definitions passed to the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`}\n * method:\n *\n *\t\t// Assuming that we have a $root > blockQuote > paragraph structure, the following code\n *\t\t// will check node 'foo' in the following context:\n *\t\t// [ rootElement, blockQuoteElement, paragraphElement ]\n *\t\tconst contextDefinition = paragraphElement;\n * \t\tconst childToCheck = 'foo';\n *\t\tschema.checkChild( contextDefinition, childToCheck );\n *\n *\t\t// Also check in [ rootElement, blockQuoteElement, paragraphElement ].\n *\t\tschema.checkChild( model.createPositionAt( paragraphElement, 0 ), 'foo' );\n *\n *\t\t// Check in [ rootElement, paragraphElement ].\n *\t\tschema.checkChild( [ rootElement, paragraphElement ], 'foo' );\n *\n *\t\t// Check only fakeParagraphElement.\n *\t\tschema.checkChild( 'paragraph', 'foo' );\n *\n *\t\t// Check in [ fakeRootElement, fakeBarElement, paragraphElement ].\n *\t\tschema.checkChild( [ '$root', 'bar', paragraphElement ], 'foo' );\n *\n * All these `checkChild()` calls will fire {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`}\n * events in which `args[ 0 ]` is an instance of the context. Therefore, you can write a listener like this:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\n *\t\t\tconsole.log( Array.from( ctx.getNames() ) );\n *\t\t} );\n *\n * Which will log the following:\n *\n *\t\t[ '$root', 'blockQuote', 'paragraph' ]\n *\t\t[ '$root', 'paragraph' ]\n *\t\t[ '$root', 'bar', 'paragraph' ]\n *\n * Note: When using the {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} method\n * you may want to check whether a text node may have an attribute. A {@link module:engine/model/text~Text} is a\n * correct way to define a context so you can do this:\n *\n *\t\tschema.checkAttribute( textNode, 'bold' );\n *\n * But sometimes you want to check whether a text at a given position might've had some attribute,\n * in which case you can create a context by mixing in an array of elements with a `'$text'` string:\n *\n *\t\t// Check in [ rootElement, paragraphElement, textNode ].\n *\t\tschema.checkChild( [ ...positionInParagraph.getAncestors(), '$text' ], 'bold' );\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/position~Position|module:engine/model/schema~SchemaContext|\n * String|Array.<String|module:engine/model/node~Node>} module:engine/model/schema~SchemaContextDefinition\n */\n\n/**\n * An item of the {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * It contains 3 properties:\n *\n * * `name` – the name of this item,\n * * `* getAttributeKeys()` – a generator of keys of item attributes,\n * * `getAttribute( keyName )` – a method to get attribute values.\n *\n * The context item interface is a highly simplified version of {@link module:engine/model/node~Node} and its role\n * is to expose only the information which schema checks are able to provide (which is the name of the node and\n * node's attributes).\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\t\t\tconst firstItem = ctx.getItem( 0 );\n *\n *\t\t\tconsole.log( firstItem.name ); // -> '$root'\n *\t\t\tconsole.log( firstItem.getAttribute( 'foo' ) ); // -> 'bar'\n *\t\t\tconsole.log( Array.from( firstItem.getAttributeKeys() ) ); // -> [ 'foo', 'faa' ]\n *\t\t} );\n *\n * @typedef {Object} module:engine/model/schema~SchemaContextItem\n */\n\n/**\n * A structure containing additional metadata describing the attribute.\n *\n * See {@link module:engine/model/schema~Schema#setAttributeProperties `Schema#setAttributeProperties()`} for usage examples.\n *\n * @typedef {Object} module:engine/model/schema~AttributeProperties\n * @property {Boolean} [isFormatting] Indicates that the attribute should be considered as a visual formatting, like `bold`, `italic` or\n * `fontSize` rather than semantic attribute (such as `src`, `listType`, etc.). For example, it is used by the \"Remove format\" feature.\n * @property {Boolean} [copyOnEnter] Indicates that given text attribute should be copied to the next block when enter is pressed.\n */\n\nfunction compileBaseItemRule(sourceItemRules, itemName) {\n  const itemRule = {\n    name: itemName,\n    allowIn: [],\n    allowContentOf: [],\n    allowWhere: [],\n    allowAttributes: [],\n    allowAttributesOf: [],\n    allowChildren: [],\n    inheritTypesFrom: []\n  };\n  copyTypes(sourceItemRules, itemRule);\n  copyProperty(sourceItemRules, itemRule, 'allowIn');\n  copyProperty(sourceItemRules, itemRule, 'allowContentOf');\n  copyProperty(sourceItemRules, itemRule, 'allowWhere');\n  copyProperty(sourceItemRules, itemRule, 'allowAttributes');\n  copyProperty(sourceItemRules, itemRule, 'allowAttributesOf');\n  copyProperty(sourceItemRules, itemRule, 'allowChildren');\n  copyProperty(sourceItemRules, itemRule, 'inheritTypesFrom');\n  makeInheritAllWork(sourceItemRules, itemRule);\n  return itemRule;\n}\n\nfunction compileAllowChildren(compiledDefinitions, itemName) {\n  const item = compiledDefinitions[itemName];\n\n  for (const allowChildrenItem of item.allowChildren) {\n    const allowedChildren = compiledDefinitions[allowChildrenItem]; // The allowChildren property may point to an unregistered element.\n\n    if (!allowedChildren) {\n      continue;\n    }\n\n    allowedChildren.allowIn.push(itemName);\n  } // The allowIn property already includes correct items, reset the allowChildren property\n  // to avoid duplicates later when setting up compilation results.\n\n\n  item.allowChildren.length = 0;\n}\n\nfunction compileAllowContentOf(compiledDefinitions, itemName) {\n  for (const allowContentOfItemName of compiledDefinitions[itemName].allowContentOf) {\n    // The allowContentOf property may point to an unregistered element.\n    if (compiledDefinitions[allowContentOfItemName]) {\n      const allowedChildren = getAllowedChildren(compiledDefinitions, allowContentOfItemName);\n      allowedChildren.forEach(allowedItem => {\n        allowedItem.allowIn.push(itemName);\n      });\n    }\n  }\n\n  delete compiledDefinitions[itemName].allowContentOf;\n}\n\nfunction compileAllowWhere(compiledDefinitions, itemName) {\n  for (const allowWhereItemName of compiledDefinitions[itemName].allowWhere) {\n    const inheritFrom = compiledDefinitions[allowWhereItemName]; // The allowWhere property may point to an unregistered element.\n\n    if (inheritFrom) {\n      const allowedIn = inheritFrom.allowIn;\n      compiledDefinitions[itemName].allowIn.push(...allowedIn);\n    }\n  }\n\n  delete compiledDefinitions[itemName].allowWhere;\n}\n\nfunction compileAllowAttributesOf(compiledDefinitions, itemName) {\n  for (const allowAttributeOfItem of compiledDefinitions[itemName].allowAttributesOf) {\n    const inheritFrom = compiledDefinitions[allowAttributeOfItem];\n\n    if (inheritFrom) {\n      const inheritAttributes = inheritFrom.allowAttributes;\n      compiledDefinitions[itemName].allowAttributes.push(...inheritAttributes);\n    }\n  }\n\n  delete compiledDefinitions[itemName].allowAttributesOf;\n}\n\nfunction compileInheritPropertiesFrom(compiledDefinitions, itemName) {\n  const item = compiledDefinitions[itemName];\n\n  for (const inheritPropertiesOfItem of item.inheritTypesFrom) {\n    const inheritFrom = compiledDefinitions[inheritPropertiesOfItem];\n\n    if (inheritFrom) {\n      const typeNames = Object.keys(inheritFrom).filter(name => name.startsWith('is'));\n\n      for (const name of typeNames) {\n        if (!(name in item)) {\n          item[name] = inheritFrom[name];\n        }\n      }\n    }\n  }\n\n  delete item.inheritTypesFrom;\n} // Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\n\n\nfunction cleanUpAllowIn(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n  const existingItems = itemRule.allowIn.filter(itemToCheck => compiledDefinitions[itemToCheck]);\n  itemRule.allowIn = Array.from(new Set(existingItems));\n} // Setup allowChildren items based on allowIn.\n\n\nfunction setupAllowChildren(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n\n  for (const allowedParentItemName of itemRule.allowIn) {\n    const allowedParentItem = compiledDefinitions[allowedParentItemName];\n    allowedParentItem.allowChildren.push(itemName);\n  }\n}\n\nfunction cleanUpAllowAttributes(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n  itemRule.allowAttributes = Array.from(new Set(itemRule.allowAttributes));\n}\n\nfunction copyTypes(sourceItemRules, itemRule) {\n  for (const sourceItemRule of sourceItemRules) {\n    const typeNames = Object.keys(sourceItemRule).filter(name => name.startsWith('is'));\n\n    for (const name of typeNames) {\n      itemRule[name] = sourceItemRule[name];\n    }\n  }\n}\n\nfunction copyProperty(sourceItemRules, itemRule, propertyName) {\n  for (const sourceItemRule of sourceItemRules) {\n    if (typeof sourceItemRule[propertyName] == 'string') {\n      itemRule[propertyName].push(sourceItemRule[propertyName]);\n    } else if (Array.isArray(sourceItemRule[propertyName])) {\n      itemRule[propertyName].push(...sourceItemRule[propertyName]);\n    }\n  }\n}\n\nfunction makeInheritAllWork(sourceItemRules, itemRule) {\n  for (const sourceItemRule of sourceItemRules) {\n    const inheritFrom = sourceItemRule.inheritAllFrom;\n\n    if (inheritFrom) {\n      itemRule.allowContentOf.push(inheritFrom);\n      itemRule.allowWhere.push(inheritFrom);\n      itemRule.allowAttributesOf.push(inheritFrom);\n      itemRule.inheritTypesFrom.push(inheritFrom);\n    }\n  }\n}\n\nfunction getAllowedChildren(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n  return getValues(compiledDefinitions).filter(def => def.allowIn.includes(itemRule.name));\n}\n\nfunction getValues(obj) {\n  return Object.keys(obj).map(key => obj[key]);\n}\n\nfunction mapContextItem(ctxItem) {\n  if (typeof ctxItem == 'string' || ctxItem.is('documentFragment')) {\n    return {\n      name: typeof ctxItem == 'string' ? ctxItem : '$documentFragment',\n\n      *getAttributeKeys() {},\n\n      getAttribute() {}\n\n    };\n  } else {\n    return {\n      // '$text' means text nodes and text proxies.\n      name: ctxItem.is('element') ? ctxItem.name : '$text',\n\n      *getAttributeKeys() {\n        yield* ctxItem.getAttributeKeys();\n      },\n\n      getAttribute(key) {\n        return ctxItem.getAttribute(key);\n      }\n\n    };\n  }\n} // Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\n\n\nfunction* combineWalkers(backward, forward) {\n  let done = false;\n\n  while (!done) {\n    done = true;\n\n    if (backward) {\n      const step = backward.next();\n\n      if (!step.done) {\n        done = false;\n        yield {\n          walker: backward,\n          value: step.value\n        };\n      }\n    }\n\n    if (forward) {\n      const step = forward.next();\n\n      if (!step.done) {\n        done = false;\n        yield {\n          walker: forward,\n          value: step.value\n        };\n      }\n    }\n  }\n} // Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns\n// all those minimal flat ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.\n// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.\n\n\nfunction* convertToMinimalFlatRanges(ranges) {\n  for (const range of ranges) {\n    yield* range.getMinimalFlatRanges();\n  }\n}\n\nfunction removeDisallowedAttributeFromNode(schema, node, writer) {\n  for (const attribute of node.getAttributeKeys()) {\n    if (!schema.checkAttribute(node, attribute)) {\n      writer.removeAttribute(attribute, node);\n    }\n  }\n}","map":{"version":3,"names":["CKEditorError","ObservableMixin","mix","Range","Position","Element","Text","TreeWalker","Schema","constructor","_sourceDefinitions","_attributeProperties","decorate","on","evt","args","SchemaContext","priority","getDefinition","register","itemName","definition","Object","assign","_clearCache","extend","push","getDefinitions","_compiledDefinitions","_compile","item","is","name","isRegistered","isBlock","def","isLimit","isObject","isSelectable","isContent","isInline","checkChild","context","_checkContextMatch","checkAttribute","attributeName","last","allowAttributes","includes","checkMerge","positionOrBaseElement","elementToMerge","nodeBefore","nodeAfter","child","getChildren","addChildCheck","callback","ctx","childDef","retValue","stop","return","addAttributeCheck","setAttributeProperties","properties","getAttributeProperties","getLimitElement","selectionOrRangeOrPosition","element","parent","ranges","Array","from","getRanges","reduce","range","rangeCommonAncestor","getCommonAncestor","includeSelf","checkAttributeInSelection","selection","attribute","isCollapsed","firstPosition","getFirstPosition","getAncestors","getAttributes","value","getValidRanges","convertToMinimalFlatRanges","_getValidRangesForRange","getNearestSelectionRange","position","direction","backwardWalker","forwardWalker","limitElement","reverse","find","root","boundaries","_createIn","startPosition","data","combineWalkers","type","walker","_createOn","nextPosition","findAllowedParent","node","setAllowedAttributes","attributes","writer","model","attributeValue","entries","schema","setAttribute","removeDisallowedAttributes","nodes","removeDisallowedAttributeFromNode","rangeInNode","positionsInRange","getPositions","getAttributesWithProperty","propertyName","propertyValue","attributeProperties","undefined","createContext","compiledDefinitions","sourceRules","itemNames","keys","compileBaseItemRule","compileAllowChildren","compileAllowContentOf","compileAllowWhere","compileAllowAttributesOf","compileInheritPropertiesFrom","cleanUpAllowIn","setupAllowChildren","cleanUpAllowAttributes","contextItemIndex","length","contextItem","getItem","allowIn","parentRule","start","end","getItems","shallow","isEqual","_createAfter","isArray","_items","map","mapContextItem","Symbol","iterator","index","getNames","endsWith","query","join","startsWith","sourceItemRules","itemRule","allowContentOf","allowWhere","allowAttributesOf","allowChildren","inheritTypesFrom","copyTypes","copyProperty","makeInheritAllWork","allowChildrenItem","allowedChildren","allowContentOfItemName","getAllowedChildren","forEach","allowedItem","allowWhereItemName","inheritFrom","allowedIn","allowAttributeOfItem","inheritAttributes","inheritPropertiesOfItem","typeNames","filter","existingItems","itemToCheck","Set","allowedParentItemName","allowedParentItem","sourceItemRule","inheritAllFrom","getValues","obj","key","ctxItem","getAttributeKeys","getAttribute","backward","forward","done","step","next","getMinimalFlatRanges","removeAttribute"],"sources":["C:/kpii/KYRSACH/note_app/client/node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/schema\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\nimport Range from './range';\nimport Position from './position';\nimport Element from './element';\nimport Text from './text';\nimport TreeWalker from './treewalker';\n\n/**\n * The model's schema. It defines the allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by the features and based on them, the editing framework and features\n * make decisions on how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * Read more about the schema in:\n *\n * * The {@glink framework/guides/architecture/editing-engine#schema schema section} of the\n * {@glink framework/guides/architecture/editing-engine Introduction to the Editing engine architecture} guide.\n * * The {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Schema {\n\t/**\n\t * Creates a schema instance.\n\t */\n\tconstructor() {\n\t\tthis._sourceDefinitions = {};\n\n\t\t/**\n\t\t * A dictionary containing attribute properties.\n\t\t *\n\t\t * @private\n\t\t * @member {Object.<String,String>}\n\t\t */\n\t\tthis._attributeProperties = {};\n\n\t\tthis.decorate( 'checkChild' );\n\t\tthis.decorate( 'checkAttribute' );\n\n\t\tthis.on( 'checkAttribute', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t}, { priority: 'highest' } );\n\n\t\tthis.on( 'checkChild', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t\targs[ 1 ] = this.getDefinition( args[ 1 ] );\n\t\t}, { priority: 'highest' } );\n\t}\n\n\t/**\n\t * Registers a schema item. Can only be called once for every item name.\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tinheritAllFrom: '$block'\n\t *\t\t} );\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\tregister( itemName, definition ) {\n\t\tif ( this._sourceDefinitions[ itemName ] ) {\n\t\t\t/**\n\t\t\t * A single item cannot be registered twice in the schema.\n\t\t\t *\n\t\t\t * This situation may happen when:\n\t\t\t *\n\t\t\t * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that\n\t\t\t * there is a collision between plugins which try to use the same element in the model. Unfortunately,\n\t\t\t * the only way to solve this is by modifying one of these plugins to use a unique model element name.\n\t\t\t * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions\n\t\t\t * and usually means one or more of the following issues:\n\t\t\t *     * a version mismatch (two of your dependencies require two different versions of this plugin),\n\t\t\t *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),\n\t\t\t *     * mess in `node_modules/` (`rm -rf node_modules/` may help).\n\t\t\t *\n\t\t\t * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.\n\t\t\t *\n\t\t\t * @param itemName The name of the model element that is being registered twice.\n\t\t\t * @error schema-cannot-register-item-twice\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'schema-cannot-register-item-twice',\n\t\t\t\tthis,\n\t\t\t\t{\n\t\t\t\t\titemName\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ] = [\n\t\t\tObject.assign( {}, definition )\n\t\t];\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Extends a {@link #register registered} item's definition.\n\t *\n\t * Extending properties such as `allowIn` will add more items to the existing properties,\n\t * while redefining properties such as `isBlock` will override the previously defined ones.\n\t *\n\t *\t\tschema.register( 'foo', {\n\t *\t\t\tallowIn: '$root',\n\t *\t\t\tisBlock: true;\n\t *\t\t} );\n\t *\t\tschema.extend( 'foo', {\n\t *\t\t\tallowIn: 'blockQuote',\n\t *\t\t\tisBlock: false\n\t *\t\t} );\n\t *\n\t *\t\tschema.getDefinition( 'foo' );\n\t *\t\t//\t{\n\t *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n\t *\t\t// \t\tisBlock: false\n\t *\t\t//\t}\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\textend( itemName, definition ) {\n\t\tif ( !this._sourceDefinitions[ itemName ] ) {\n\t\t\t/**\n\t\t\t * Cannot extend an item which was not registered yet.\n\t\t\t *\n\t\t\t * This error happens when a plugin tries to extend the schema definition of an item which was not\n\t\t\t * {@link #register registered} yet.\n\t\t\t *\n\t\t\t * @param itemName The name of the model element which is being extended.\n\t\t\t * @error schema-cannot-extend-missing-item\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'schema-cannot-extend-missing-item', this, {\n\t\t\t\titemName\n\t\t\t} );\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ].push( Object.assign( {}, definition ) );\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Returns data of all registered items.\n\t *\n\t * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n\t * checking a list of all block elements, etc).\n\t * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n\t * in other cases.\n\t *\n\t * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n\t */\n\tgetDefinitions() {\n\t\tif ( !this._compiledDefinitions ) {\n\t\t\tthis._compile();\n\t\t}\n\n\t\treturn this._compiledDefinitions;\n\t}\n\n\t/**\n\t * Returns a definition of the given item or `undefined` if an item is not registered.\n\t *\n\t * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n\t * checking a list of all block elements, etc).\n\t * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n\t * in other cases.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n\t */\n\tgetDefinition( item ) {\n\t\tlet itemName;\n\n\t\tif ( typeof item == 'string' ) {\n\t\t\titemName = item;\n\t\t} else if ( item.is && ( item.is( '$text' ) || item.is( '$textProxy' ) ) ) {\n\t\t\titemName = '$text';\n\t\t}\n\t\t// Element or module:engine/model/schema~SchemaContextItem.\n\t\telse {\n\t\t\titemName = item.name;\n\t\t}\n\n\t\treturn this.getDefinitions()[ itemName ];\n\t}\n\n\t/**\n\t * Returns `true` if the given item is registered in the schema.\n\t *\n\t *\t\tschema.isRegistered( 'paragraph' ); // -> true\n\t *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isRegistered( 'foo' ); // -> false\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n \t * @returns {Boolean}\n\t */\n\tisRegistered( item ) {\n\t\treturn !!this.getDefinition( item );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n\t *\n\t *\t\tschema.isBlock( 'paragraph' ); // -> true\n\t *\t\tschema.isBlock( '$root' ); // -> false\n\t *\n\t *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n\t *\t\tschema.isBlock( paragraphElement ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#block-elements Block elements} section of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n  \t * @returns {Boolean}\n\t */\n\tisBlock( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isBlock );\n\t}\n\n\t/**\n\t * Returns `true` if the given item should be treated as a limit element.\n\t *\n\t * It considers an item to be a limit element if its\n\t * {@link module:engine/model/schema~SchemaItemDefinition}'s\n\t * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or\n\t * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n\t * was set to `true`.\n\t *\n\t *\t\tschema.isLimit( 'paragraph' ); // -> false\n\t *\t\tschema.isLimit( '$root' ); // -> true\n\t *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isLimit( 'imageBlock' ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#limit-elements Limit elements} section of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n  \t * @returns {Boolean}\n\t */\n\tisLimit( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isLimit || def.isObject );\n\t}\n\n\t/**\n\t * Returns `true` if the given item should be treated as an object element.\n\t *\n\t * It considers an item to be an object element if its\n\t * {@link module:engine/model/schema~SchemaItemDefinition}'s\n\t * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n\t * was set to `true`.\n\t *\n\t *\t\tschema.isObject( 'paragraph' ); // -> false\n\t *\t\tschema.isObject( 'imageBlock' ); // -> true\n\t *\n\t *\t\tconst imageElement = writer.createElement( 'imageBlock' );\n\t *\t\tschema.isObject( imageElement ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#object-elements Object elements} section of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n  \t * @returns {Boolean}\n\t */\n\tisObject( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Note: Check out the implementation of #isLimit(), #isSelectable(), and #isContent()\n\t\t// to understand why these three constitute an object.\n\t\treturn !!( def.isObject || ( def.isLimit && def.isSelectable && def.isContent ) );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.\n\t *\n\t *\t\tschema.isInline( 'paragraph' ); // -> false\n\t *\t\tschema.isInline( 'softBreak' ); // -> true\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\tschema.isInline( text ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#inline-elements Inline elements} section of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {Boolean}\n\t */\n\tisInline( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isInline );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.\n\t *\n\t *\t\tschema.isSelectable( 'paragraph' ); // -> false\n\t *\t\tschema.isSelectable( 'heading1' ); // -> false\n\t *\t\tschema.isSelectable( 'imageBlock' ); // -> true\n\t *\t\tschema.isSelectable( 'tableCell' ); // -> true\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\tschema.isSelectable( text ); // -> false\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {Boolean}\n\t */\n\tisSelectable( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isSelectable || def.isObject );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.\n\t *\n\t *\t\tschema.isContent( 'paragraph' ); // -> false\n\t *\t\tschema.isContent( 'heading1' ); // -> false\n\t *\t\tschema.isContent( 'imageBlock' ); // -> true\n\t *\t\tschema.isContent( 'horizontalLine' ); // -> true\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\tschema.isContent( text ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {Boolean}\n\t */\n\tisContent( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isContent || def.isObject );\n\t}\n\n\t/**\n\t * Checks whether the given node (`child`) can be a child of the given context.\n\t *\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tallowIn: '$root'\n\t *\t\t} );\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n\t *\n\t * Note: When verifying whether the given node can be a child of the given context, the\n\t * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n\t * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n\t * It happens if one of the context's elements does not allow its child.\n\t *\n\t * @fires checkChild\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n\t * @param {module:engine/model/node~Node|String} def The child to check.\n\t * @returns {Boolean}\n\t */\n\tcheckChild( context, def ) {\n\t\t// Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._checkContextMatch( def, context );\n\t}\n\n\t/**\n\t * Checks whether the given attribute can be applied in the given context (on the last\n\t * item of the context).\n\t *\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n\t *\n\t *\t\tschema.extend( '$text', {\n\t *\t\t\tallowAttributes: 'bold'\n\t *\t\t} );\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n\t *\n\t * @fires checkAttribute\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n\t * @param {String} attributeName\n\t * @returns {Boolean}\n\t */\n\tcheckAttribute( context, attributeName ) {\n\t\tconst def = this.getDefinition( context.last );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn def.allowAttributes.includes( attributeName );\n\t}\n\n\t/**\n\t * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n\t *\n\t * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n\t *\n\t * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n\t * will be valid.\n\t *\n\t * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n\t * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n\t *\n\t * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n\t * element to which the `elementToMerge` will be merged.\n\t * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n\t * @returns {Boolean}\n\t */\n\tcheckMerge( positionOrBaseElement, elementToMerge = null ) {\n\t\tif ( positionOrBaseElement instanceof Position ) {\n\t\t\tconst nodeBefore = positionOrBaseElement.nodeBefore;\n\t\t\tconst nodeAfter = positionOrBaseElement.nodeAfter;\n\n\t\t\tif ( !( nodeBefore instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node before the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-before\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'schema-check-merge-no-element-before',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( !( nodeAfter instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node after the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-after\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'schema-check-merge-no-element-after',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.checkMerge( nodeBefore, nodeAfter );\n\t\t}\n\n\t\tfor ( const child of elementToMerge.getChildren() ) {\n\t\t\tif ( !this.checkChild( positionOrBaseElement, child ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkChild} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow elements in specific contexts.\n\t *\n\t * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow heading1 directly inside a blockQuote.\n\t *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkChild', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst childDefinition = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkChild()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and\n\t * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n\t * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n\t */\n\taddChildCheck( callback ) {\n\t\tthis.on( 'checkChild', ( evt, [ ctx, childDef ] ) => {\n\t\t\t// checkChild() was called with a non-registered child.\n\t\t\t// In 99% cases such check should return false, so not to overcomplicate all callbacks\n\t\t\t// don't even execute them.\n\t\t\tif ( !childDef ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst retValue = callback( ctx, childDef );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkAttribute} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow attribute if node to which it is applied\n\t * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n\t *\n\t * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow bold on $text inside heading1.\n\t *\t\tschema.addAttributeCheck( ( context, attributeName ) => {\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst attributeName = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkAttribute()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n\t * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n\t */\n\taddAttributeCheck( callback ) {\n\t\tthis.on( 'checkAttribute', ( evt, [ ctx, attributeName ] ) => {\n\t\t\tconst retValue = callback( ctx, attributeName );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * This method allows assigning additional metadata to the model attributes. For example,\n\t * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is\n\t * used to mark formatting attributes (like `bold` or `italic`).\n\t *\n\t *\t\t// Mark bold as a formatting attribute.\n\t *\t\tschema.setAttributeProperties( 'bold', {\n\t *\t\t\tisFormatting: true\n\t *\t\t} );\n\t *\n\t *\t\t// Override code not to be considered a formatting markup.\n\t *\t\tschema.setAttributeProperties( 'code', {\n\t *\t\t\tisFormatting: false\n\t *\t\t} );\n\t *\n\t * Properties are not limited to members defined in the\n\t * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\tcustomProperty: 'value'\n\t *\t\t} );\n\t *\n\t * Subsequent calls with the same attribute will extend its custom properties:\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\tone: 1\n\t *\t\t} );\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\ttwo: 2\n\t *\t\t} );\n\t *\n\t *\t\tconsole.log( schema.getAttributeProperties( 'blockQuote' ) );\n\t *\t\t// Logs: { one: 1, two: 2 }\n\t *\n\t * @param {String} attributeName A name of the attribute to receive the properties.\n\t * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.\n\t */\n\tsetAttributeProperties( attributeName, properties ) {\n\t\tthis._attributeProperties[ attributeName ] = Object.assign( this.getAttributeProperties( attributeName ), properties );\n\t}\n\n\t/**\n\t * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.\n\t *\n\t * @param {String} attributeName A name of the attribute.\n\t * @returns {module:engine/model/schema~AttributeProperties}\n\t */\n\tgetAttributeProperties( attributeName ) {\n\t\treturn this._attributeProperties[ attributeName ] || {};\n\t}\n\n\t/**\n\t * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n\t * selection/range/position or the root otherwise.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n\t * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n\t * The selection/range/position to check.\n\t * @returns {module:engine/model/element~Element} The lowest limit element containing\n\t * the entire `selectionOrRangeOrPosition`.\n\t */\n\tgetLimitElement( selectionOrRangeOrPosition ) {\n\t\tlet element;\n\n\t\tif ( selectionOrRangeOrPosition instanceof Position ) {\n\t\t\telement = selectionOrRangeOrPosition.parent;\n\t\t} else {\n\t\t\tconst ranges = selectionOrRangeOrPosition instanceof Range ?\n\t\t\t\t[ selectionOrRangeOrPosition ] :\n\t\t\t\tArray.from( selectionOrRangeOrPosition.getRanges() );\n\n\t\t\t// Find the common ancestor for all selection's ranges.\n\t\t\telement = ranges\n\t\t\t\t.reduce( ( element, range ) => {\n\t\t\t\t\tconst rangeCommonAncestor = range.getCommonAncestor();\n\n\t\t\t\t\tif ( !element ) {\n\t\t\t\t\t\treturn rangeCommonAncestor;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn element.getCommonAncestor( rangeCommonAncestor, { includeSelf: true } );\n\t\t\t\t}, null );\n\t\t}\n\n\t\twhile ( !this.isLimit( element ) ) {\n\t\t\tif ( element.parent ) {\n\t\t\t\telement = element.parent;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn element;\n\t}\n\n\t/**\n\t * Checks whether the attribute is allowed in selection:\n\t *\n\t * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n\t * * if the selection is collapsed, then checks if on the selection position there's a text with the\n\t * specified attribute allowed.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection which will be checked.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Boolean}\n\t */\n\tcheckAttributeInSelection( selection, attribute ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\tconst firstPosition = selection.getFirstPosition();\n\t\t\tconst context = [\n\t\t\t\t...firstPosition.getAncestors(),\n\t\t\t\tnew Text( '', selection.getAttributes() )\n\t\t\t];\n\n\t\t\t// Check whether schema allows for a text with the attribute in the selection.\n\t\t\treturn this.checkAttribute( context, attribute );\n\t\t} else {\n\t\t\tconst ranges = selection.getRanges();\n\n\t\t\t// For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tfor ( const value of range ) {\n\t\t\t\t\tif ( this.checkAttribute( value.item, attribute ) ) {\n\t\t\t\t\t\t// If we found a node that is allowed to have the attribute, return true.\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't found such node, return false.\n\t\treturn false;\n\t}\n\n\t/**\n\t * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n\t *\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n\t */\n\t* getValidRanges( ranges, attribute ) {\n\t\tranges = convertToMinimalFlatRanges( ranges );\n\n\t\tfor ( const range of ranges ) {\n\t\t\tyield* this._getValidRangesForRange( range, attribute );\n\t\t}\n\t}\n\n\t/**\n\t * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n\t * nearest to that `position` and is a correct range for selection.\n\t *\n\t * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n\t * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n\t * the {@link module:engine/model/schema~Schema schema}.\n\t *\n\t * Direction of searching for the nearest correct selection range can be specified as:\n\t *\n\t * * `both` - searching will be performed in both ways,\n\t * * `forward` - searching will be performed only forward,\n\t * * `backward` - searching will be performed only backward.\n\t *\n\t * When valid selection range cannot be found, `null` is returned.\n\t *\n\t * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n\t * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n\t * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n\t */\n\tgetNearestSelectionRange( position, direction = 'both' ) {\n\t\t// Return collapsed range if provided position is valid.\n\t\tif ( this.checkChild( position, '$text' ) ) {\n\t\t\treturn new Range( position );\n\t\t}\n\n\t\tlet backwardWalker, forwardWalker;\n\n\t\t// Never leave a limit element.\n\t\tconst limitElement = position.getAncestors().reverse().find( item => this.isLimit( item ) ) || position.root;\n\n\t\tif ( direction == 'both' || direction == 'backward' ) {\n\t\t\tbackwardWalker = new TreeWalker( {\n\t\t\t\tboundaries: Range._createIn( limitElement ),\n\t\t\t\tstartPosition: position,\n\t\t\t\tdirection: 'backward'\n\t\t\t} );\n\t\t}\n\n\t\tif ( direction == 'both' || direction == 'forward' ) {\n\t\t\tforwardWalker = new TreeWalker( {\n\t\t\t\tboundaries: Range._createIn( limitElement ),\n\t\t\t\tstartPosition: position\n\t\t\t} );\n\t\t}\n\n\t\tfor ( const data of combineWalkers( backwardWalker, forwardWalker ) ) {\n\t\t\tconst type = ( data.walker == backwardWalker ? 'elementEnd' : 'elementStart' );\n\t\t\tconst value = data.value;\n\n\t\t\tif ( value.type == type && this.isObject( value.item ) ) {\n\t\t\t\treturn Range._createOn( value.item );\n\t\t\t}\n\n\t\t\tif ( this.checkChild( value.nextPosition, '$text' ) ) {\n\t\t\t\treturn new Range( value.nextPosition );\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Tries to find position ancestors that allow to insert a given node.\n\t * It starts searching from the given position and goes node by node to the top of the model tree\n\t * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an\n\t * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.\n\t *\n\t * @param {module:engine/model/position~Position} position The position that the search will start from.\n\t * @param {module:engine/model/node~Node|String} node The node for which an allowed parent should be found or its name.\n\t * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n\t */\n\tfindAllowedParent( position, node ) {\n\t\tlet parent = position.parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( this.checkChild( parent, node ) ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\t// Do not split limit elements.\n\t\t\tif ( this.isLimit( parent ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets attributes allowed by the schema on a given node.\n\t *\n\t * @param {module:engine/model/node~Node} node A node to set attributes on.\n\t * @param {Object} attributes Attributes keys and values.\n\t * @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n\t */\n\tsetAllowedAttributes( node, attributes, writer ) {\n\t\tconst model = writer.model;\n\n\t\tfor ( const [ attributeName, attributeValue ] of Object.entries( attributes ) ) {\n\t\t\tif ( model.schema.checkAttribute( node, attributeName ) ) {\n\t\t\t\twriter.setAttribute( attributeName, attributeValue, node );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes attributes disallowed by the schema.\n\t *\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n\t * @param {module:engine/model/writer~Writer} writer\n\t */\n\tremoveDisallowedAttributes( nodes, writer ) {\n\t\tfor ( const node of nodes ) {\n\t\t\t// When node is a `Text` it has no children, so just filter it out.\n\t\t\tif ( node.is( '$text' ) ) {\n\t\t\t\tremoveDisallowedAttributeFromNode( this, node, writer );\n\t\t\t}\n\t\t\t// In a case of `Element` iterates through positions between nodes inside this element\n\t\t\t// and filter out node before the current position, or position parent when position\n\t\t\t// is at start of an element. Using positions prevent from omitting merged nodes\n\t\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/1789.\n\t\t\telse {\n\t\t\t\tconst rangeInNode = Range._createIn( node );\n\t\t\t\tconst positionsInRange = rangeInNode.getPositions();\n\n\t\t\t\tfor ( const position of positionsInRange ) {\n\t\t\t\t\tconst item = position.nodeBefore || position.parent;\n\n\t\t\t\t\tremoveDisallowedAttributeFromNode( this, item, writer );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets attributes of a node that have a given property.\n\t *\n\t * @param {module:engine/model/node~Node} node Node to get attributes from.\n\t * @param {String} propertyName Name of the property that attribute must have to return it.\n\t * @param {Boolean|Symbol|String|Number|Object|null|undefined} propertyValue Desired value of the property that we want to check.\n\t * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will\n\t * return attributes which given property's value is equal to this parameter.\n\t * @returns {Object} Object with attributes' names as key and attributes' values as value.\n\t */\n\tgetAttributesWithProperty( node, propertyName, propertyValue ) {\n\t\tconst attributes = {};\n\n\t\tfor ( const [ attributeName, attributeValue ] of node.getAttributes() ) {\n\t\t\tconst attributeProperties = this.getAttributeProperties( attributeName );\n\n\t\t\tif ( attributeProperties[ propertyName ] === undefined ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( propertyValue === undefined || propertyValue === attributeProperties[ propertyName ] ) {\n\t\t\t\tattributes[ attributeName ] = attributeValue;\n\t\t\t}\n\t\t}\n\n\t\treturn attributes;\n\t}\n\n\t/**\n\t * Creates an instance of the schema context.\n\t *\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context\n\t * @returns {module:engine/model/schema~SchemaContext}\n\t */\n\tcreateContext( context ) {\n\t\treturn new SchemaContext( context );\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_clearCache() {\n\t\tthis._compiledDefinitions = null;\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_compile() {\n\t\tconst compiledDefinitions = {};\n\t\tconst sourceRules = this._sourceDefinitions;\n\t\tconst itemNames = Object.keys( sourceRules );\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompiledDefinitions[ itemName ] = compileBaseItemRule( sourceRules[ itemName ], itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowChildren( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowContentOf( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowWhere( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowAttributesOf( compiledDefinitions, itemName );\n\t\t\tcompileInheritPropertiesFrom( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcleanUpAllowIn( compiledDefinitions, itemName );\n\t\t\tsetupAllowChildren( compiledDefinitions, itemName );\n\t\t\tcleanUpAllowAttributes( compiledDefinitions, itemName );\n\t\t}\n\n\t\tthis._compiledDefinitions = compiledDefinitions;\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n\t * @param {module:engine/model/schema~SchemaContext} context\n\t * @param {Number} contextItemIndex\n\t */\n\t_checkContextMatch( def, context, contextItemIndex = context.length - 1 ) {\n\t\tconst contextItem = context.getItem( contextItemIndex );\n\n\t\tif ( def.allowIn.includes( contextItem.name ) ) {\n\t\t\tif ( contextItemIndex == 0 ) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tconst parentRule = this.getDefinition( contextItem );\n\n\t\t\t\treturn this._checkContextMatch( parentRule, context, contextItemIndex - 1 );\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges\n\t * inside the given range on which the attribute can be applied.\n\t *\n\t * This is a helper function for {@link ~Schema#getValidRanges}.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range The range to process.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n\t */\n\t* _getValidRangesForRange( range, attribute ) {\n\t\tlet start = range.start;\n\t\tlet end = range.start;\n\n\t\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\tyield* this._getValidRangesForRange( Range._createIn( item ), attribute );\n\t\t\t}\n\n\t\t\tif ( !this.checkAttribute( item, attribute ) ) {\n\t\t\t\tif ( !start.isEqual( end ) ) {\n\t\t\t\t\tyield new Range( start, end );\n\t\t\t\t}\n\n\t\t\t\tstart = Position._createAfter( item );\n\t\t\t}\n\n\t\t\tend = Position._createAfter( item );\n\t\t}\n\n\t\tif ( !start.isEqual( end ) ) {\n\t\t\tyield new Range( start, end );\n\t\t}\n\t}\n}\n\nmix( Schema, ObservableMixin );\n\n/**\n * Event fired when the {@link #checkChild} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addChildCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkChild} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding standard behavior of the\n * `checkChild()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkChild( context, child )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance and `child` to a\n * {@link module:engine/model/schema~SchemaCompiledItemDefinition} instance, so you do not have to worry about\n * the various ways how `context` and `child` may be passed to `checkChild()`.\n *\n * **Note:** `childDefinition` may be `undefined` if `checkChild()` was called with a non-registered element.\n *\n * So, in order to implement a rule \"disallow `heading1` in `blockQuote`\", you can add such a listener:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing elements in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowIn` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `listItem` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo' ) && childDefinition.name == 'listItem' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkChild\n * @param {Array} args The `checkChild()`'s arguments.\n */\n\n/**\n * Event fired when the {@link #checkAttribute} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addAttributeCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkAttribute} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding the standard behavior of the\n * `checkAttribute()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkAttribute( context, attributeName )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance, so you do not have to worry about\n * the various ways how `context` may be passed to `checkAttribute()`.\n *\n * So, in order to implement a rule \"disallow `bold` in a text which is in a `heading1`, you can add such a listener:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing attributes in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowAttributes` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `bold` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkAttribute\n * @param {Array} args The `checkAttribute()`'s arguments.\n */\n\n/**\n * A definition of a {@link module:engine/model/schema~Schema schema} item.\n *\n * You can define the following rules:\n *\n * * {@link ~SchemaItemDefinition#allowIn `allowIn`} &ndash; Defines in which other items this item will be allowed.\n * * {@link ~SchemaItemDefinition#allowChildren `allowChildren`} &ndash; Defines which other items are allowed inside this item.\n * * {@link ~SchemaItemDefinition#allowAttributes `allowAttributes`} &ndash; Defines allowed attributes of the given item.\n * * {@link ~SchemaItemDefinition#allowContentOf `allowContentOf`} &ndash; Inherits \"allowed children\" from other items.\n * * {@link ~SchemaItemDefinition#allowWhere `allowWhere`} &ndash; Inherits \"allowed in\" from other items.\n * * {@link ~SchemaItemDefinition#allowAttributesOf `allowAttributesOf`} &ndash; Inherits attributes from other items.\n * * {@link ~SchemaItemDefinition#inheritTypesFrom `inheritTypesFrom`} &ndash; Inherits `is*` properties of other items.\n * * {@link ~SchemaItemDefinition#inheritAllFrom `inheritAllFrom`} &ndash;\n * A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * # The `is*` properties\n *\n * There are a couple commonly used `is*` properties. Their role is to assign additional semantics to schema items.\n * You can define more properties but you will also need to implement support for them in the existing editor features.\n *\n * * {@link ~SchemaItemDefinition#isBlock `isBlock`} &ndash; Whether this item is paragraph-like.\n * Generally speaking, content is usually made out of blocks like paragraphs, list items, images, headings, etc.\n * * {@link ~SchemaItemDefinition#isInline `isInline`} &ndash; Whether an item is \"text-like\" and should be treated as an inline node.\n * Examples of inline elements: `$text`, `softBreak` (`<br>`), etc.\n * * {@link ~SchemaItemDefinition#isLimit `isLimit`} &ndash; It can be understood as whether this element\n * should not be split by <kbd>Enter</kbd>. Examples of limit elements: `$root`, table cell, image caption, etc.\n * In other words, all actions that happen inside a limit element are limited to its content.\n * All objects are treated as limit elements, too.\n * * {@link ~SchemaItemDefinition#isObject `isObject`} &ndash; Whether an item is \"self-contained\" and should be treated as a whole.\n * Examples of object elements: `imageBlock`, `table`, `video`, etc. An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the meaning of these types in the\n * {@glink framework/guides/deep-dive/schema#defining-additional-semantics dedicated section of the Schema deep dive} guide.\n *\n * # Generic items\n *\n * There are several generic items (classes of elements) available: `$root`, `$container`, `$block`, `$blockObject`,\n * `$inlineObject`, and `$text`. They are defined as follows:\n *\n *\t\tschema.register( '$root', {\n *\t\t\tisLimit: true\n *\t\t} );\n *\n *\t\tschema.register( '$container', {\n *\t\t\tallowIn: [ '$root', '$container' ]\n *\t\t} );\n *\n *\t\tschema.register( '$block', {\n *\t\t\tallowIn: [ '$root', '$container' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n *\t\tschema.register( '$blockObject', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n *\t\tschema.register( '$inlineObject', {\n *\t\t\tallowWhere: '$text',\n *\t\t\tallowAttributesOf: '$text',\n *\t\t\tisInline: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n *\t\tschema.register( '$text', {\n *\t\t\tallowIn: '$block',\n *\t\t\tisInline: true,\n *\t\t\tisContent: true\n *\t\t} );\n *\n * They reflect typical editor content that is contained within one root, consists of several blocks\n * (paragraphs, lists items, headings, images) which, in turn, may contain text inside.\n *\n * By inheriting from the generic items you can define new items which will get extended by other editor features.\n * Read more about generic types in the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * # Example definitions\n *\n * Allow `paragraph` in roots and block quotes:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: [ '$root', 'blockQuote' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` everywhere where `$block` is allowed (i.e. in `$root`):\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` inside a `$root` and allow `$text` as a `paragraph` child:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: '$root',\n *\t\t\tallowChildren: '$text',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * The previous rule can be written in a shorter form using inheritance:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tinheritAllFrom: '$block'\n *\t\t} );\n *\n * Make `imageBlock` a block object, which is allowed everywhere where `$block` is.\n * Also, allow `src` and `alt` attributes in it:\n *\n *\t\tschema.register( 'imageBlock', {\n *\t\t\tinheritAllFrom: '$blockObject',\n *\t\t\tallowAttributes: [ 'src', 'alt' ],\n *\t\t} );\n *\n * Make `caption` allowed in `imageBlock` and make it allow all the content of `$block`s (usually, `$text`).\n * Also, mark it as a limit element so it cannot be split:\n *\n *\t\tschema.register( 'caption', {\n *\t\t\tallowIn: 'imageBlock',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tisLimit: true\n *\t\t} );\n *\n * Make `listItem` inherit all from `$block` but also allow additional attributes:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tinheritAllFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * Which translates to:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tallowAttributesOf: '$block',\n *\t\t\tinheritTypesFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * # Tips\n *\n * * Check schema definitions of existing features to see how they are defined.\n * * If you want to publish your feature so other developers can use it, try to use\n * generic items as much as possible.\n * * Keep your model clean. Limit it to the actual data and store information in a normalized way.\n * * Remember about defining the `is*` properties. They do not affect the allowed structures, but they can\n * affect how the editor features treat your elements.\n *\n * @typedef {Object} module:engine/model/schema~SchemaItemDefinition\n *\n * @property {String|Array.<String>} allowIn Defines in which other items this item will be allowed.\n * @property {String|Array.<String>} allowChildren Defines which other items are allowed inside this item.\n * @property {String|Array.<String>} allowAttributes Defines allowed attributes of the given item.\n * @property {String|Array.<String>} allowContentOf Inherits \"allowed children\" from other items.\n * @property {String|Array.<String>} allowWhere Inherits \"allowed in\" from other items.\n * @property {String|Array.<String>} allowAttributesOf Inherits attributes from other items.\n * @property {String|Array.<String>} inheritTypesFrom Inherits `is*` properties of other items.\n * @property {String} inheritAllFrom A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * @property {Boolean} isBlock\n * Whether this item is paragraph-like. Generally speaking, content is usually made out of blocks\n * like paragraphs, list items, images, headings, etc. All these elements are marked as blocks. A block\n * should not allow another block inside. Note: There is also the `$block` generic item which has `isBlock` set to `true`.\n * Most block type items will inherit from `$block` (through `inheritAllFrom`).\n *\n * Read more about the block elements in the\n * {@glink framework/guides/deep-dive/schema#block-elements Block elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive}.\n *\n * @property {Boolean} isInline\n * Whether an item is \"text-like\" and should be treated as an inline node. Examples of inline elements:\n * `$text`, `softBreak` (`<br>`), etc.\n *\n * Read more about the inline elements in the\n * {@glink framework/guides/deep-dive/schema#inline-elements Inline elements section} of the Schema deep dive guide.\n *\n * @property {Boolean} isLimit\n * It can be understood as whether this element should not be split by <kbd>Enter</kbd>.\n * Examples of limit elements: `$root`, table cell, image caption, etc. In other words, all actions that happen inside\n * a limit element are limited to its content.\n *\n * Read more about the limit elements in the\n * {@glink framework/guides/deep-dive/schema#limit-elements Limit elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @property {Boolean} isObject\n * Whether an item is \"self-contained\" and should be treated as a whole. Examples of object elements:\n * `imageBlock`, `table`, `video`, etc.\n *\n * **Note:** An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the object elements in the\n * {@glink framework/guides/deep-dive/schema#object-elements Object elements section} of the Schema deep dive guide.\n *\n * @property {Boolean} isSelectable\n * `true` when an element should be selectable as a whole by the user. Examples of selectable elements: `imageBlock`, `table`, `tableCell`,\n * etc.\n *\n * **Note:** An object is also a selectable element, so\n * {@link module:engine/model/schema~Schema#isSelectable `isSelectable()`} returns `true` for object elements automatically.\n *\n * Read more about selectable elements in the\n * {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @property {Boolean} isContent\n * An item is a content when it always finds its way to the editor data output regardless of the number and type of its descendants.\n * Examples of content elements: `$text`, `imageBlock`, `table`, etc. (but not `paragraph`, `heading1` or `tableCell`).\n *\n * **Note:** An object is also a content element, so\n * {@link module:engine/model/schema~Schema#isContent `isContent()`} returns `true` for object elements automatically.\n *\n * Read more about content elements in the\n * {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n */\n\n/**\n * A simplified version of {@link module:engine/model/schema~SchemaItemDefinition} after\n * compilation by the {@link module:engine/model/schema~Schema schema}.\n * Rules fed to the schema by {@link module:engine/model/schema~Schema#register}\n * and {@link module:engine/model/schema~Schema#extend} methods are defined in the\n * {@link module:engine/model/schema~SchemaItemDefinition} format.\n * Later on, they are compiled to `SchemaCompiledItemDefinition` so when you use e.g.\n * the {@link module:engine/model/schema~Schema#getDefinition} method you get the compiled version.\n *\n * The compiled version contains only the following properties:\n *\n * * The `name` property,\n * * The `is*` properties,\n * * The `allowIn` array,\n * * The `allowChildren` array,\n * * The `allowAttributes` array.\n *\n * @typedef {Object} module:engine/model/schema~SchemaCompiledItemDefinition\n */\n\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\nexport class SchemaContext {\n\t/**\n\t * Creates an instance of the context.\n\t *\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context\n\t */\n\tconstructor( context ) {\n\t\tif ( context instanceof SchemaContext ) {\n\t\t\treturn context;\n\t\t}\n\n\t\tif ( typeof context == 'string' ) {\n\t\t\tcontext = [ context ];\n\t\t} else if ( !Array.isArray( context ) ) {\n\t\t\t// `context` is item or position.\n\t\t\t// Position#getAncestors() doesn't accept any parameters but it works just fine here.\n\t\t\tcontext = context.getAncestors( { includeSelf: true } );\n\t\t}\n\n\t\tthis._items = context.map( mapContextItem );\n\t}\n\n\t/**\n\t * The number of items.\n\t *\n\t * @type {Number}\n\t */\n\tget length() {\n\t\treturn this._items.length;\n\t}\n\n\t/**\n\t * The last item (the lowest node).\n\t *\n\t * @type {module:engine/model/schema~SchemaContextItem}\n\t */\n\tget last() {\n\t\treturn this._items[ this._items.length - 1 ];\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all context items.\n\t *\n\t * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._items[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns a new schema context instance with an additional item.\n\t *\n\t * Item can be added as:\n\t *\n\t * \t\tconst context = new SchemaContext( [ '$root' ] );\n\t *\n\t * \t\t// An element.\n\t * \t\tconst fooElement = writer.createElement( 'fooElement' );\n\t * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n\t *\n\t * \t\t// A text node.\n\t * \t\tconst text = writer.createText( 'foobar' );\n\t * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n\t *\n\t * \t\t// A string (element name).\n\t * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n\t *\n\t * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item\n\t * (without ancestors).\n\t *\n\t * @param {String|module:engine/model/node~Node|Array<String|module:engine/model/node~Node>} item An item that will be added\n\t * to the current context.\n\t * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n\t */\n\tpush( item ) {\n\t\tconst ctx = new SchemaContext( [ item ] );\n\n\t\tctx._items = [ ...this._items, ...ctx._items ];\n\n\t\treturn ctx;\n\t}\n\n\t/**\n\t * Gets an item on the given index.\n\t *\n\t * @returns {module:engine/model/schema~SchemaContextItem}\n\t */\n\tgetItem( index ) {\n\t\treturn this._items[ index ];\n\t}\n\n\t/**\n\t * Returns the names of items.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\t* getNames() {\n\t\tyield* this._items.map( item => item.name );\n\t}\n\n\t/**\n\t * Checks whether the context ends with the given nodes.\n\t *\n\t *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n\t *\n\t *\t\tctx.endsWith( '$text' ); // -> true\n\t *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n\t *\t\tctx.endsWith( '$root' ); // -> false\n\t *\t\tctx.endsWith( 'paragraph' ); // -> false\n\t *\n\t * @param {String} query\n\t * @returns {Boolean}\n\t */\n\tendsWith( query ) {\n\t\treturn Array.from( this.getNames() ).join( ' ' ).endsWith( query );\n\t}\n\n\t/**\n\t * Checks whether the context starts with the given nodes.\n\t *\n\t *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n\t *\n\t *\t\tctx.endsWith( '$root' ); // -> true\n\t *\t\tctx.endsWith( '$root paragraph' ); // -> true\n\t *\t\tctx.endsWith( '$text' ); // -> false\n\t *\t\tctx.endsWith( 'paragraph' ); // -> false\n\t *\n\t * @param {String} query\n\t * @returns {Boolean}\n\t */\n\tstartsWith( query ) {\n\t\treturn Array.from( this.getNames() ).join( ' ' ).startsWith( query );\n\t}\n}\n\n/**\n * The definition of a {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * Contexts can be created in multiple ways:\n *\n * * By defining a **node** – in this cases this node and all its ancestors will be used.\n * * By defining a **position** in the document – in this case all its ancestors will be used.\n * * By defining an **array of nodes** – in this case this array defines the entire context.\n * * By defining a **name of node** - in this case node will be \"mocked\". It is not recommended because context\n * will be unrealistic (e.g. attributes of these nodes are not specified). However, at times this may be the only\n * way to define the context (e.g. when checking some hypothetical situation).\n * * By defining an **array of node names** (potentially, mixed with real nodes) – The same as **name of node**\n * but it is possible to create a path.\n * * By defining a {@link module:engine/model/schema~SchemaContext} instance - in this case the same instance as provided\n * will be return.\n *\n * Examples of context definitions passed to the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`}\n * method:\n *\n *\t\t// Assuming that we have a $root > blockQuote > paragraph structure, the following code\n *\t\t// will check node 'foo' in the following context:\n *\t\t// [ rootElement, blockQuoteElement, paragraphElement ]\n *\t\tconst contextDefinition = paragraphElement;\n * \t\tconst childToCheck = 'foo';\n *\t\tschema.checkChild( contextDefinition, childToCheck );\n *\n *\t\t// Also check in [ rootElement, blockQuoteElement, paragraphElement ].\n *\t\tschema.checkChild( model.createPositionAt( paragraphElement, 0 ), 'foo' );\n *\n *\t\t// Check in [ rootElement, paragraphElement ].\n *\t\tschema.checkChild( [ rootElement, paragraphElement ], 'foo' );\n *\n *\t\t// Check only fakeParagraphElement.\n *\t\tschema.checkChild( 'paragraph', 'foo' );\n *\n *\t\t// Check in [ fakeRootElement, fakeBarElement, paragraphElement ].\n *\t\tschema.checkChild( [ '$root', 'bar', paragraphElement ], 'foo' );\n *\n * All these `checkChild()` calls will fire {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`}\n * events in which `args[ 0 ]` is an instance of the context. Therefore, you can write a listener like this:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\n *\t\t\tconsole.log( Array.from( ctx.getNames() ) );\n *\t\t} );\n *\n * Which will log the following:\n *\n *\t\t[ '$root', 'blockQuote', 'paragraph' ]\n *\t\t[ '$root', 'paragraph' ]\n *\t\t[ '$root', 'bar', 'paragraph' ]\n *\n * Note: When using the {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} method\n * you may want to check whether a text node may have an attribute. A {@link module:engine/model/text~Text} is a\n * correct way to define a context so you can do this:\n *\n *\t\tschema.checkAttribute( textNode, 'bold' );\n *\n * But sometimes you want to check whether a text at a given position might've had some attribute,\n * in which case you can create a context by mixing in an array of elements with a `'$text'` string:\n *\n *\t\t// Check in [ rootElement, paragraphElement, textNode ].\n *\t\tschema.checkChild( [ ...positionInParagraph.getAncestors(), '$text' ], 'bold' );\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/position~Position|module:engine/model/schema~SchemaContext|\n * String|Array.<String|module:engine/model/node~Node>} module:engine/model/schema~SchemaContextDefinition\n */\n\n/**\n * An item of the {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * It contains 3 properties:\n *\n * * `name` – the name of this item,\n * * `* getAttributeKeys()` – a generator of keys of item attributes,\n * * `getAttribute( keyName )` – a method to get attribute values.\n *\n * The context item interface is a highly simplified version of {@link module:engine/model/node~Node} and its role\n * is to expose only the information which schema checks are able to provide (which is the name of the node and\n * node's attributes).\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\t\t\tconst firstItem = ctx.getItem( 0 );\n *\n *\t\t\tconsole.log( firstItem.name ); // -> '$root'\n *\t\t\tconsole.log( firstItem.getAttribute( 'foo' ) ); // -> 'bar'\n *\t\t\tconsole.log( Array.from( firstItem.getAttributeKeys() ) ); // -> [ 'foo', 'faa' ]\n *\t\t} );\n *\n * @typedef {Object} module:engine/model/schema~SchemaContextItem\n */\n\n/**\n * A structure containing additional metadata describing the attribute.\n *\n * See {@link module:engine/model/schema~Schema#setAttributeProperties `Schema#setAttributeProperties()`} for usage examples.\n *\n * @typedef {Object} module:engine/model/schema~AttributeProperties\n * @property {Boolean} [isFormatting] Indicates that the attribute should be considered as a visual formatting, like `bold`, `italic` or\n * `fontSize` rather than semantic attribute (such as `src`, `listType`, etc.). For example, it is used by the \"Remove format\" feature.\n * @property {Boolean} [copyOnEnter] Indicates that given text attribute should be copied to the next block when enter is pressed.\n */\n\nfunction compileBaseItemRule( sourceItemRules, itemName ) {\n\tconst itemRule = {\n\t\tname: itemName,\n\n\t\tallowIn: [],\n\t\tallowContentOf: [],\n\t\tallowWhere: [],\n\n\t\tallowAttributes: [],\n\t\tallowAttributesOf: [],\n\n\t\tallowChildren: [],\n\n\t\tinheritTypesFrom: []\n\t};\n\n\tcopyTypes( sourceItemRules, itemRule );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowIn' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowContentOf' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowWhere' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributes' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributesOf' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowChildren' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'inheritTypesFrom' );\n\n\tmakeInheritAllWork( sourceItemRules, itemRule );\n\n\treturn itemRule;\n}\n\nfunction compileAllowChildren( compiledDefinitions, itemName ) {\n\tconst item = compiledDefinitions[ itemName ];\n\n\tfor ( const allowChildrenItem of item.allowChildren ) {\n\t\tconst allowedChildren = compiledDefinitions[ allowChildrenItem ];\n\n\t\t// The allowChildren property may point to an unregistered element.\n\t\tif ( !allowedChildren ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tallowedChildren.allowIn.push( itemName );\n\t}\n\n\t// The allowIn property already includes correct items, reset the allowChildren property\n\t// to avoid duplicates later when setting up compilation results.\n\titem.allowChildren.length = 0;\n}\n\nfunction compileAllowContentOf( compiledDefinitions, itemName ) {\n\tfor ( const allowContentOfItemName of compiledDefinitions[ itemName ].allowContentOf ) {\n\t\t// The allowContentOf property may point to an unregistered element.\n\t\tif ( compiledDefinitions[ allowContentOfItemName ] ) {\n\t\t\tconst allowedChildren = getAllowedChildren( compiledDefinitions, allowContentOfItemName );\n\n\t\t\tallowedChildren.forEach( allowedItem => {\n\t\t\t\tallowedItem.allowIn.push( itemName );\n\t\t\t} );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowContentOf;\n}\n\nfunction compileAllowWhere( compiledDefinitions, itemName ) {\n\tfor ( const allowWhereItemName of compiledDefinitions[ itemName ].allowWhere ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowWhereItemName ];\n\n\t\t// The allowWhere property may point to an unregistered element.\n\t\tif ( inheritFrom ) {\n\t\t\tconst allowedIn = inheritFrom.allowIn;\n\n\t\t\tcompiledDefinitions[ itemName ].allowIn.push( ...allowedIn );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowWhere;\n}\n\nfunction compileAllowAttributesOf( compiledDefinitions, itemName ) {\n\tfor ( const allowAttributeOfItem of compiledDefinitions[ itemName ].allowAttributesOf ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowAttributeOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst inheritAttributes = inheritFrom.allowAttributes;\n\n\t\t\tcompiledDefinitions[ itemName ].allowAttributes.push( ...inheritAttributes );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowAttributesOf;\n}\n\nfunction compileInheritPropertiesFrom( compiledDefinitions, itemName ) {\n\tconst item = compiledDefinitions[ itemName ];\n\n\tfor ( const inheritPropertiesOfItem of item.inheritTypesFrom ) {\n\t\tconst inheritFrom = compiledDefinitions[ inheritPropertiesOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst typeNames = Object.keys( inheritFrom ).filter( name => name.startsWith( 'is' ) );\n\n\t\t\tfor ( const name of typeNames ) {\n\t\t\t\tif ( !( name in item ) ) {\n\t\t\t\t\titem[ name ] = inheritFrom[ name ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete item.inheritTypesFrom;\n}\n\n// Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\nfunction cleanUpAllowIn( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\tconst existingItems = itemRule.allowIn.filter( itemToCheck => compiledDefinitions[ itemToCheck ] );\n\n\titemRule.allowIn = Array.from( new Set( existingItems ) );\n}\n\n// Setup allowChildren items based on allowIn.\nfunction setupAllowChildren( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\tfor ( const allowedParentItemName of itemRule.allowIn ) {\n\t\tconst allowedParentItem = compiledDefinitions[ allowedParentItemName ];\n\n\t\tallowedParentItem.allowChildren.push( itemName );\n\t}\n}\n\nfunction cleanUpAllowAttributes( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\titemRule.allowAttributes = Array.from( new Set( itemRule.allowAttributes ) );\n}\n\nfunction copyTypes( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst typeNames = Object.keys( sourceItemRule ).filter( name => name.startsWith( 'is' ) );\n\n\t\tfor ( const name of typeNames ) {\n\t\t\titemRule[ name ] = sourceItemRule[ name ];\n\t\t}\n\t}\n}\n\nfunction copyProperty( sourceItemRules, itemRule, propertyName ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tif ( typeof sourceItemRule[ propertyName ] == 'string' ) {\n\t\t\titemRule[ propertyName ].push( sourceItemRule[ propertyName ] );\n\t\t} else if ( Array.isArray( sourceItemRule[ propertyName ] ) ) {\n\t\t\titemRule[ propertyName ].push( ...sourceItemRule[ propertyName ] );\n\t\t}\n\t}\n}\n\nfunction makeInheritAllWork( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst inheritFrom = sourceItemRule.inheritAllFrom;\n\n\t\tif ( inheritFrom ) {\n\t\t\titemRule.allowContentOf.push( inheritFrom );\n\t\t\titemRule.allowWhere.push( inheritFrom );\n\t\t\titemRule.allowAttributesOf.push( inheritFrom );\n\t\t\titemRule.inheritTypesFrom.push( inheritFrom );\n\t\t}\n\t}\n}\n\nfunction getAllowedChildren( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\treturn getValues( compiledDefinitions ).filter( def => def.allowIn.includes( itemRule.name ) );\n}\n\nfunction getValues( obj ) {\n\treturn Object.keys( obj ).map( key => obj[ key ] );\n}\n\nfunction mapContextItem( ctxItem ) {\n\tif ( typeof ctxItem == 'string' || ctxItem.is( 'documentFragment' ) ) {\n\t\treturn {\n\t\t\tname: typeof ctxItem == 'string' ? ctxItem : '$documentFragment',\n\n\t\t\t* getAttributeKeys() {},\n\n\t\t\tgetAttribute() {}\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\t// '$text' means text nodes and text proxies.\n\t\t\tname: ctxItem.is( 'element' ) ? ctxItem.name : '$text',\n\n\t\t\t* getAttributeKeys() {\n\t\t\t\tyield* ctxItem.getAttributeKeys();\n\t\t\t},\n\n\t\t\tgetAttribute( key ) {\n\t\t\t\treturn ctxItem.getAttribute( key );\n\t\t\t}\n\t\t};\n\t}\n}\n\n// Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\nfunction* combineWalkers( backward, forward ) {\n\tlet done = false;\n\n\twhile ( !done ) {\n\t\tdone = true;\n\n\t\tif ( backward ) {\n\t\t\tconst step = backward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: backward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( forward ) {\n\t\t\tconst step = forward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: forward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns\n// all those minimal flat ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.\n// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.\nfunction* convertToMinimalFlatRanges( ranges ) {\n\tfor ( const range of ranges ) {\n\t\tyield* range.getMinimalFlatRanges();\n\t}\n}\n\nfunction removeDisallowedAttributeFromNode( schema, node, writer ) {\n\tfor ( const attribute of node.getAttributeKeys() ) {\n\t\tif ( !schema.checkAttribute( node, attribute ) ) {\n\t\t\twriter.removeAttribute( attribute, node );\n\t\t}\n\t}\n}\n"],"mappings":"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AX,EAAkBC,GAAlB,CAAN;IACA;EACD;;AA39B0B;AA89B5BtJ,GAAG,CAAEM,MAAF,EAAUP,eAAV,CAAH;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMe,aAAN,CAAoB;EAC1B;AACD;AACA;AACA;AACA;EACCP,WAAW,CAAEiC,OAAF,EAAY;IACtB,IAAKA,OAAO,YAAY1B,aAAxB,EAAwC;MACvC,OAAO0B,OAAP;IACA;;IAED,IAAK,OAAOA,OAAP,IAAkB,QAAvB,EAAkC;MACjCA,OAAO,GAAG,CAAEA,OAAF,CAAV;IACA,CAFD,MAEO,IAAK,CAAC8B,KAAK,CAACqF,OAAN,CAAenH,OAAf,CAAN,EAAiC;MACvC;MACA;MACAA,OAAO,GAAGA,OAAO,CAAC4C,YAAR,CAAsB;QAAEP,WAAW,EAAE;MAAf,CAAtB,CAAV;IACA;;IAED,KAAK+E,MAAL,GAAcpH,OAAO,CAACqH,GAAR,CAA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"},"metadata":{},"sourceType":"module"}